(self.webpackChunkdbs_tracker_app = self.webpackChunkdbs_tracker_app || []).push([[179], { 8255: e => { function t(e) { return Promise.resolve().then(() => { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t }) } t.keys = () => [], t.resolve = t, t.id = 8255, e.exports = t }, 8583: (e, t, n) => { "use strict"; n.d(t, { mr: () => b, ez: () => we, K0: () => c, uU: () => ve, Do: () => E, V_: () => h, Ye: () => C, S$: () => v, sg: () => le, O5: () => he, tP: () => pe, b0: () => _, lw: () => l, rS: () => ye, EM: () => Ce, JF: () => Ie, NF: () => _e, PM: () => Ee, w_: () => a, bD: () => be, q: () => i, Mx: () => ae, HT: () => o }); var r = n(8720); let s = null; function i() { return s } function o(e) { s || (s = e) } class a { } const c = new r.OlP("DocumentToken"); let l = (() => { class e { historyGo(e) { throw new Error("Not implemented") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = (0, r.Yz7)({ factory: u, token: e, providedIn: "platform" }), e })(); function u() { return (0, r.LFG)(d) } const h = new r.OlP("Location Initialized"); let d = (() => { class e extends l { constructor(e) { super(), this._doc = e, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return i().getBaseHref(this._doc) } onPopState(e) { const t = i().getGlobalEventTarget(this._doc, "window"); return t.addEventListener("popstate", e, !1), () => t.removeEventListener("popstate", e) } onHashChange(e) { const t = i().getGlobalEventTarget(this._doc, "window"); return t.addEventListener("hashchange", e, !1), () => t.removeEventListener("hashchange", e) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(e) { this.location.pathname = e } pushState(e, t, n) { f() ? this._history.pushState(e, t, n) : this.location.hash = n } replaceState(e, t, n) { f() ? this._history.replaceState(e, t, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } historyGo(e = 0) { this._history.go(e) } getState() { return this._history.state } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(c)) }, e.\u0275prov = (0, r.Yz7)({ factory: p, token: e, providedIn: "platform" }), e })(); function f() { return !!window.history.pushState } function p() { return new d((0, r.LFG)(c)) } function m(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function g(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function y(e) { return e && "?" !== e[0] ? "?" + e : e } let v = (() => { class e { historyGo(e) { throw new Error("Not implemented") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = (0, r.Yz7)({ factory: w, token: e, providedIn: "root" }), e })(); function w(e) { const t = (0, r.LFG)(c).location; return new _((0, r.LFG)(l), t && t.origin || "") } const b = new r.OlP("appBaseHref"); let _ = (() => { class e extends v { constructor(e, t) { if (super(), this._platformLocation = e, this._removeListenerFns = [], null == t && (t = this._platformLocation.getBaseHrefFromDOM()), null == t) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = t } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } prepareExternalUrl(e) { return m(this._baseHref, e) } path(e = !1) { const t = this._platformLocation.pathname + y(this._platformLocation.search), n = this._platformLocation.hash; return n && e ? `${t}${n}` : t } pushState(e, t, n, r) { const s = this.prepareExternalUrl(n + y(r)); this._platformLocation.pushState(e, t, s) } replaceState(e, t, n, r) { const s = this.prepareExternalUrl(n + y(r)); this._platformLocation.replaceState(e, t, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var t, n; null === (n = (t = this._platformLocation).historyGo) || void 0 === n || n.call(t, e) } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(l), r.LFG(b, 8)) }, e.\u0275prov = r.Yz7({ token: e, factory: e.\u0275fac }), e })(), E = (() => { class e extends v { constructor(e, t) { super(), this._platformLocation = e, this._baseHref = "", this._removeListenerFns = [], null != t && (this._baseHref = t) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(e) { this._removeListenerFns.push(this._platformLocation.onPopState(e), this._platformLocation.onHashChange(e)) } getBaseHref() { return this._baseHref } path(e = !1) { let t = this._platformLocation.hash; return null == t && (t = "#"), t.length > 0 ? t.substring(1) : t } prepareExternalUrl(e) { const t = m(this._baseHref, e); return t.length > 0 ? "#" + t : t } pushState(e, t, n, r) { let s = this.prepareExternalUrl(n + y(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(e, t, s) } replaceState(e, t, n, r) { let s = this.prepareExternalUrl(n + y(r)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(e, t, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(e = 0) { var t, n; null === (n = (t = this._platformLocation).historyGo) || void 0 === n || n.call(t, e) } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(l), r.LFG(b, 8)) }, e.\u0275prov = r.Yz7({ token: e, factory: e.\u0275fac }), e })(), C = (() => { class e { constructor(e, t) { this._subject = new r.vpe, this._urlChangeListeners = [], this._platformStrategy = e; const n = this._platformStrategy.getBaseHref(); this._platformLocation = t, this._baseHref = g(T(n)), this._platformStrategy.onPopState(e => { this._subject.emit({ url: this.path(!0), pop: !0, state: e.state, type: e.type }) }) } path(e = !1) { return this.normalize(this._platformStrategy.path(e)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(e, t = "") { return this.path() == this.normalize(e + y(t)) } normalize(t) { return e.stripTrailingSlash(function (e, t) { return e && t.startsWith(e) ? t.substring(e.length) : t }(this._baseHref, T(t))) } prepareExternalUrl(e) { return e && "/" !== e[0] && (e = "/" + e), this._platformStrategy.prepareExternalUrl(e) } go(e, t = "", n = null) { this._platformStrategy.pushState(n, "", e, t), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + y(t)), n) } replaceState(e, t = "", n = null) { this._platformStrategy.replaceState(n, "", e, t), this._notifyUrlChangeListeners(this.prepareExternalUrl(e + y(t)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(e = 0) { var t, n; null === (n = (t = this._platformStrategy).historyGo) || void 0 === n || n.call(t, e) } onUrlChange(e) { this._urlChangeListeners.push(e), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(e => { this._notifyUrlChangeListeners(e.url, e.state) })) } _notifyUrlChangeListeners(e = "", t) { this._urlChangeListeners.forEach(n => n(e, t)) } subscribe(e, t, n) { return this._subject.subscribe({ next: e, error: t, complete: n }) } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(v), r.LFG(l)) }, e.normalizeQueryParams = y, e.joinWithSlash = m, e.stripTrailingSlash = g, e.\u0275prov = (0, r.Yz7)({ factory: S, token: e, providedIn: "root" }), e })(); function S() { return new C((0, r.LFG)(v), (0, r.LFG)(l)) } function T(e) { return e.replace(/\/index.html$/, "") } var I = (() => ((I = I || {})[I.Zero = 0] = "Zero", I[I.One = 1] = "One", I[I.Two = 2] = "Two", I[I.Few = 3] = "Few", I[I.Many = 4] = "Many", I[I.Other = 5] = "Other", I))(), k = (() => ((k = k || {})[k.Format = 0] = "Format", k[k.Standalone = 1] = "Standalone", k))(), A = (() => ((A = A || {})[A.Narrow = 0] = "Narrow", A[A.Abbreviated = 1] = "Abbreviated", A[A.Wide = 2] = "Wide", A[A.Short = 3] = "Short", A))(), x = (() => ((x = x || {})[x.Short = 0] = "Short", x[x.Medium = 1] = "Medium", x[x.Long = 2] = "Long", x[x.Full = 3] = "Full", x))(), D = (() => ((D = D || {})[D.Decimal = 0] = "Decimal", D[D.Group = 1] = "Group", D[D.List = 2] = "List", D[D.PercentSign = 3] = "PercentSign", D[D.PlusSign = 4] = "PlusSign", D[D.MinusSign = 5] = "MinusSign", D[D.Exponential = 6] = "Exponential", D[D.SuperscriptingExponent = 7] = "SuperscriptingExponent", D[D.PerMille = 8] = "PerMille", D[D[1 / 0] = 9] = "Infinity", D[D.NaN = 10] = "NaN", D[D.TimeSeparator = 11] = "TimeSeparator", D[D.CurrencyDecimal = 12] = "CurrencyDecimal", D[D.CurrencyGroup = 13] = "CurrencyGroup", D))(); function O(e, t) { return M((0, r.cg1)(e)[r.wAp.DateFormat], t) } function R(e, t) { return M((0, r.cg1)(e)[r.wAp.TimeFormat], t) } function N(e, t) { return M((0, r.cg1)(e)[r.wAp.DateTimeFormat], t) } function P(e, t) { const n = (0, r.cg1)(e), s = n[r.wAp.NumberSymbols][t]; if (void 0 === s) { if (t === D.CurrencyDecimal) return n[r.wAp.NumberSymbols][D.Decimal]; if (t === D.CurrencyGroup) return n[r.wAp.NumberSymbols][D.Group] } return s } const F = r.kL8; function L(e) { if (!e[r.wAp.ExtraData]) throw new Error(`Missing extra locale data for the locale "${e[r.wAp.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`) } function M(e, t) { for (let n = t; n > -1; n--)if (void 0 !== e[n]) return e[n]; throw new Error("Locale data API: locale data undefined") } function $(e) { const [t, n] = e.split(":"); return { hours: +t, minutes: +n } } const B = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/, V = {}, U = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/; var j = (() => ((j = j || {})[j.Short = 0] = "Short", j[j.ShortGMT = 1] = "ShortGMT", j[j.Long = 2] = "Long", j[j.Extended = 3] = "Extended", j))(), q = (() => ((q = q || {})[q.FullYear = 0] = "FullYear", q[q.Month = 1] = "Month", q[q.Date = 2] = "Date", q[q.Hours = 3] = "Hours", q[q.Minutes = 4] = "Minutes", q[q.Seconds = 5] = "Seconds", q[q.FractionalSeconds = 6] = "FractionalSeconds", q[q.Day = 7] = "Day", q))(), z = (() => ((z = z || {})[z.DayPeriods = 0] = "DayPeriods", z[z.Days = 1] = "Days", z[z.Months = 2] = "Months", z[z.Eras = 3] = "Eras", z))(); function H(e, t, n, r) { let s = function (e) { if (se(e)) return e; if ("number" == typeof e && !isNaN(e)) return new Date(e); if ("string" == typeof e) { if (e = e.trim(), /^(\d{4}(-\d{1,2}(-\d{1,2})?)?)$/.test(e)) { const [t, n = 1, r = 1] = e.split("-").map(e => +e); return G(t, n - 1, r) } const t = parseFloat(e); if (!isNaN(e - t)) return new Date(t); let n; if (n = e.match(B)) return function (e) { const t = new Date(0); let n = 0, r = 0; const s = e[8] ? t.setUTCFullYear : t.setFullYear, i = e[8] ? t.setUTCHours : t.setHours; e[9] && (n = Number(e[9] + e[10]), r = Number(e[9] + e[11])), s.call(t, Number(e[1]), Number(e[2]) - 1, Number(e[3])); const o = Number(e[4] || 0) - n, a = Number(e[5] || 0) - r, c = Number(e[6] || 0), l = Math.floor(1e3 * parseFloat("0." + (e[7] || 0))); return i.call(t, o, a, c, l), t }(n) } const t = new Date(e); if (!se(t)) throw new Error(`Unable to convert "${e}" into a date`); return t }(e); t = W(n, t) || t; let i, o = []; for (; t;) { if (i = U.exec(t), !i) { o.push(t); break } { o = o.concat(i.slice(1)); const e = o.pop(); if (!e) break; t = e } } let a = s.getTimezoneOffset(); r && (a = re(r, a), s = function (e, t, n) { const r = e.getTimezoneOffset(); return function (e, t) { return (e = new Date(e.getTime())).setMinutes(e.getMinutes() + t), e }(e, -1 * (re(t, r) - r)) }(s, r)); let c = ""; return o.forEach(e => { const t = function (e) { if (ne[e]) return ne[e]; let t; switch (e) { case "G": case "GG": case "GGG": t = Z(z.Eras, A.Abbreviated); break; case "GGGG": t = Z(z.Eras, A.Wide); break; case "GGGGG": t = Z(z.Eras, A.Narrow); break; case "y": t = X(q.FullYear, 1, 0, !1, !0); break; case "yy": t = X(q.FullYear, 2, 0, !0, !0); break; case "yyy": t = X(q.FullYear, 3, 0, !1, !0); break; case "yyyy": t = X(q.FullYear, 4, 0, !1, !0); break; case "Y": t = te(1); break; case "YY": t = te(2, !0); break; case "YYY": t = te(3); break; case "YYYY": t = te(4); break; case "M": case "L": t = X(q.Month, 1, 1); break; case "MM": case "LL": t = X(q.Month, 2, 1); break; case "MMM": t = Z(z.Months, A.Abbreviated); break; case "MMMM": t = Z(z.Months, A.Wide); break; case "MMMMM": t = Z(z.Months, A.Narrow); break; case "LLL": t = Z(z.Months, A.Abbreviated, k.Standalone); break; case "LLLL": t = Z(z.Months, A.Wide, k.Standalone); break; case "LLLLL": t = Z(z.Months, A.Narrow, k.Standalone); break; case "w": t = ee(1); break; case "ww": t = ee(2); break; case "W": t = ee(1, !0); break; case "d": t = X(q.Date, 1); break; case "dd": t = X(q.Date, 2); break; case "c": case "cc": t = X(q.Day, 1); break; case "ccc": t = Z(z.Days, A.Abbreviated, k.Standalone); break; case "cccc": t = Z(z.Days, A.Wide, k.Standalone); break; case "ccccc": t = Z(z.Days, A.Narrow, k.Standalone); break; case "cccccc": t = Z(z.Days, A.Short, k.Standalone); break; case "E": case "EE": case "EEE": t = Z(z.Days, A.Abbreviated); break; case "EEEE": t = Z(z.Days, A.Wide); break; case "EEEEE": t = Z(z.Days, A.Narrow); break; case "EEEEEE": t = Z(z.Days, A.Short); break; case "a": case "aa": case "aaa": t = Z(z.DayPeriods, A.Abbreviated); break; case "aaaa": t = Z(z.DayPeriods, A.Wide); break; case "aaaaa": t = Z(z.DayPeriods, A.Narrow); break; case "b": case "bb": case "bbb": t = Z(z.DayPeriods, A.Abbreviated, k.Standalone, !0); break; case "bbbb": t = Z(z.DayPeriods, A.Wide, k.Standalone, !0); break; case "bbbbb": t = Z(z.DayPeriods, A.Narrow, k.Standalone, !0); break; case "B": case "BB": case "BBB": t = Z(z.DayPeriods, A.Abbreviated, k.Format, !0); break; case "BBBB": t = Z(z.DayPeriods, A.Wide, k.Format, !0); break; case "BBBBB": t = Z(z.DayPeriods, A.Narrow, k.Format, !0); break; case "h": t = X(q.Hours, 1, -12); break; case "hh": t = X(q.Hours, 2, -12); break; case "H": t = X(q.Hours, 1); break; case "HH": t = X(q.Hours, 2); break; case "m": t = X(q.Minutes, 1); break; case "mm": t = X(q.Minutes, 2); break; case "s": t = X(q.Seconds, 1); break; case "ss": t = X(q.Seconds, 2); break; case "S": t = X(q.FractionalSeconds, 1); break; case "SS": t = X(q.FractionalSeconds, 2); break; case "SSS": t = X(q.FractionalSeconds, 3); break; case "Z": case "ZZ": case "ZZZ": t = Q(j.Short); break; case "ZZZZZ": t = Q(j.Extended); break; case "O": case "OO": case "OOO": case "z": case "zz": case "zzz": t = Q(j.ShortGMT); break; case "OOOO": case "ZZZZ": case "zzzz": t = Q(j.Long); break; default: return null }return ne[e] = t, t }(e); c += t ? t(s, n, a) : "''" === e ? "'" : e.replace(/(^'|'$)/g, "").replace(/''/g, "'") }), c } function G(e, t, n) { const r = new Date(0); return r.setFullYear(e, t, n), r.setHours(0, 0, 0), r } function W(e, t) { const n = function (e) { return (0, r.cg1)(e)[r.wAp.LocaleId] }(e); if (V[n] = V[n] || {}, V[n][t]) return V[n][t]; let s = ""; switch (t) { case "shortDate": s = O(e, x.Short); break; case "mediumDate": s = O(e, x.Medium); break; case "longDate": s = O(e, x.Long); break; case "fullDate": s = O(e, x.Full); break; case "shortTime": s = R(e, x.Short); break; case "mediumTime": s = R(e, x.Medium); break; case "longTime": s = R(e, x.Long); break; case "fullTime": s = R(e, x.Full); break; case "short": const t = W(e, "shortTime"), n = W(e, "shortDate"); s = Y(N(e, x.Short), [t, n]); break; case "medium": const r = W(e, "mediumTime"), i = W(e, "mediumDate"); s = Y(N(e, x.Medium), [r, i]); break; case "long": const o = W(e, "longTime"), a = W(e, "longDate"); s = Y(N(e, x.Long), [o, a]); break; case "full": const c = W(e, "fullTime"), l = W(e, "fullDate"); s = Y(N(e, x.Full), [c, l]) }return s && (V[n][t] = s), s } function Y(e, t) { return t && (e = e.replace(/\{([^}]+)}/g, function (e, n) { return null != t && n in t ? t[n] : e })), e } function K(e, t, n = "-", r, s) { let i = ""; (e < 0 || s && e <= 0) && (s ? e = 1 - e : (e = -e, i = n)); let o = String(e); for (; o.length < t;)o = "0" + o; return r && (o = o.substr(o.length - t)), i + o } function X(e, t, n = 0, r = !1, s = !1) { return function (i, o) { let a = function (e, t) { switch (e) { case q.FullYear: return t.getFullYear(); case q.Month: return t.getMonth(); case q.Date: return t.getDate(); case q.Hours: return t.getHours(); case q.Minutes: return t.getMinutes(); case q.Seconds: return t.getSeconds(); case q.FractionalSeconds: return t.getMilliseconds(); case q.Day: return t.getDay(); default: throw new Error(`Unknown DateType value "${e}".`) } }(e, i); if ((n > 0 || a > -n) && (a += n), e === q.Hours) 0 === a && -12 === n && (a = 12); else if (e === q.FractionalSeconds) return c = t, K(a, 3).substr(0, c); var c; const l = P(o, D.MinusSign); return K(a, t, l, r, s) } } function Z(e, t, n = k.Format, s = !1) { return function (i, o) { return function (e, t, n, s, i, o) { switch (n) { case z.Months: return function (e, t, n) { const s = (0, r.cg1)(e), i = M([s[r.wAp.MonthsFormat], s[r.wAp.MonthsStandalone]], t); return M(i, n) }(t, i, s)[e.getMonth()]; case z.Days: return function (e, t, n) { const s = (0, r.cg1)(e), i = M([s[r.wAp.DaysFormat], s[r.wAp.DaysStandalone]], t); return M(i, n) }(t, i, s)[e.getDay()]; case z.DayPeriods: const a = e.getHours(), c = e.getMinutes(); if (o) { const e = function (e) { const t = (0, r.cg1)(e); return L(t), (t[r.wAp.ExtraData][2] || []).map(e => "string" == typeof e ? $(e) : [$(e[0]), $(e[1])]) }(t), n = function (e, t, n) { const s = (0, r.cg1)(e); L(s); const i = M([s[r.wAp.ExtraData][0], s[r.wAp.ExtraData][1]], t) || []; return M(i, n) || [] }(t, i, s), o = e.findIndex(e => { if (Array.isArray(e)) { const [t, n] = e, r = a >= t.hours && c >= t.minutes, s = a < n.hours || a === n.hours && c < n.minutes; if (t.hours < n.hours) { if (r && s) return !0 } else if (r || s) return !0 } else if (e.hours === a && e.minutes === c) return !0; return !1 }); if (-1 !== o) return n[o] } return function (e, t, n) { const s = (0, r.cg1)(e), i = M([s[r.wAp.DayPeriodsFormat], s[r.wAp.DayPeriodsStandalone]], t); return M(i, n) }(t, i, s)[a < 12 ? 0 : 1]; case z.Eras: return function (e, t) { return M((0, r.cg1)(e)[r.wAp.Eras], t) }(t, s)[e.getFullYear() <= 0 ? 0 : 1]; default: throw new Error(`unexpected translation type ${n}`) } }(i, o, e, t, n, s) } } function Q(e) { return function (t, n, r) { const s = -1 * r, i = P(n, D.MinusSign), o = s > 0 ? Math.floor(s / 60) : Math.ceil(s / 60); switch (e) { case j.Short: return (s >= 0 ? "+" : "") + K(o, 2, i) + K(Math.abs(s % 60), 2, i); case j.ShortGMT: return "GMT" + (s >= 0 ? "+" : "") + K(o, 1, i); case j.Long: return "GMT" + (s >= 0 ? "+" : "") + K(o, 2, i) + ":" + K(Math.abs(s % 60), 2, i); case j.Extended: return 0 === r ? "Z" : (s >= 0 ? "+" : "") + K(o, 2, i) + ":" + K(Math.abs(s % 60), 2, i); default: throw new Error(`Unknown zone width "${e}"`) } } } function J(e) { return G(e.getFullYear(), e.getMonth(), e.getDate() + (4 - e.getDay())) } function ee(e, t = !1) { return function (n, r) { let s; if (t) { const e = new Date(n.getFullYear(), n.getMonth(), 1).getDay() - 1, t = n.getDate(); s = 1 + Math.floor((t + e) / 7) } else { const e = J(n), t = function (e) { const t = G(e, 0, 1).getDay(); return G(e, 0, 1 + (t <= 4 ? 4 : 11) - t) }(e.getFullYear()), r = e.getTime() - t.getTime(); s = 1 + Math.round(r / 6048e5) } return K(s, e, P(r, D.MinusSign)) } } function te(e, t = !1) { return function (n, r) { return K(J(n).getFullYear(), e, P(r, D.MinusSign), t) } } const ne = {}; function re(e, t) { e = e.replace(/:/g, ""); const n = Date.parse("Jan 01, 1970 00:00:00 " + e) / 6e4; return isNaN(n) ? t : n } function se(e) { return e instanceof Date && !isNaN(e.valueOf()) } class ie { } let oe = (() => { class e extends ie { constructor(e) { super(), this.locale = e } getPluralCategory(e, t) { switch (F(t || this.locale)(e)) { case I.Zero: return "zero"; case I.One: return "one"; case I.Two: return "two"; case I.Few: return "few"; case I.Many: return "many"; default: return "other" } } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(r.soG)) }, e.\u0275prov = r.Yz7({ token: e, factory: e.\u0275fac }), e })(); function ae(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const e = n.indexOf("="), [r, s] = -1 == e ? [n, ""] : [n.slice(0, e), n.slice(e + 1)]; if (r.trim() === t) return decodeURIComponent(s) } return null } class ce { constructor(e, t, n, r) { this.$implicit = e, this.ngForOf = t, this.index = n, this.count = r } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let le = (() => { class e { constructor(e, t, n) { this._viewContainer = e, this._template = t, this._differs = n, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(e) { this._ngForOf = e, this._ngForOfDirty = !0 } set ngForTrackBy(e) { this._trackByFn = e } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(e) { e && (this._template = e) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; if (!this._differ && n) try { this._differ = this._differs.find(n).create(this.ngForTrackBy) } catch (t) { throw new Error(`Cannot find a differ supporting object '${n}' of type '${e = n, e.name || typeof e}'. NgFor only supports binding to Iterables such as Arrays.`) } } var e; if (this._differ) { const e = this._differ.diff(this._ngForOf); e && this._applyChanges(e) } } _applyChanges(e) { const t = []; e.forEachOperation((e, n, r) => { if (null == e.previousIndex) { const n = this._viewContainer.createEmbeddedView(this._template, new ce(null, this._ngForOf, -1, -1), null === r ? void 0 : r), s = new ue(e, n); t.push(s) } else if (null == r) this._viewContainer.remove(null === n ? void 0 : n); else if (null !== n) { const s = this._viewContainer.get(n); this._viewContainer.move(s, r); const i = new ue(e, s); t.push(i) } }); for (let n = 0; n < t.length; n++)this._perViewChange(t[n].view, t[n].record); for (let n = 0, r = this._viewContainer.length; n < r; n++) { const e = this._viewContainer.get(n); e.context.index = n, e.context.count = r, e.context.ngForOf = this._ngForOf } e.forEachIdentityChange(e => { this._viewContainer.get(e.currentIndex).context.$implicit = e.item }) } _perViewChange(e, t) { e.context.$implicit = t.item } static ngTemplateContextGuard(e, t) { return !0 } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(r.s_b), r.Y36(r.Rgc), r.Y36(r.ZZ4)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" } }), e })(); class ue { constructor(e, t) { this.record = e, this.view = t } } let he = (() => { class e { constructor(e, t) { this._viewContainer = e, this._context = new de, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = t } set ngIf(e) { this._context.$implicit = this._context.ngIf = e, this._updateView() } set ngIfThen(e) { fe("ngIfThen", e), this._thenTemplateRef = e, this._thenViewRef = null, this._updateView() } set ngIfElse(e) { fe("ngIfElse", e), this._elseTemplateRef = e, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(e, t) { return !0 } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(r.s_b), r.Y36(r.Rgc)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), e })(); class de { constructor() { this.$implicit = null, this.ngIf = null } } function fe(e, t) { if (t && !t.createEmbeddedView) throw new Error(`${e} must be a TemplateRef, but received '${(0, r.AaK)(t)}'.`) } let pe = (() => { class e { constructor(e) { this._viewContainerRef = e, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null } ngOnChanges(e) { if (e.ngTemplateOutlet) { const e = this._viewContainerRef; this._viewRef && e.remove(e.indexOf(this._viewRef)), this._viewRef = this.ngTemplateOutlet ? e.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null } else this._viewRef && e.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(r.s_b)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet" }, features: [r.TTD] }), e })(); function me(e, t) { return Error(`InvalidPipeArgument: '${t}' for pipe '${(0, r.AaK)(e)}'`) } const ge = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g; let ye = (() => { class e { transform(t) { if (null == t) return null; if ("string" != typeof t) throw me(e, t); return t.replace(ge, e => e[0].toUpperCase() + e.substr(1).toLowerCase()) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275pipe = r.Yjl({ name: "titlecase", type: e, pure: !0 }), e })(), ve = (() => { class e { constructor(e) { this.locale = e } transform(t, n = "mediumDate", r, s) { if (null == t || "" === t || t != t) return null; try { return H(t, n, s || this.locale, r) } catch (i) { throw me(e, i.message) } } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(r.soG, 16)) }, e.\u0275pipe = r.Yjl({ name: "date", type: e, pure: !0 }), e })(), we = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ providers: [{ provide: ie, useClass: oe }] }), e })(); const be = "browser"; function _e(e) { return e === be } function Ee(e) { return "server" === e } let Ce = (() => { class e { } return e.\u0275prov = (0, r.Yz7)({ token: e, providedIn: "root", factory: () => new Se((0, r.LFG)(c), window) }), e })(); class Se { constructor(e, t) { this.document = e, this.window = t, this.offset = () => [0, 0] } setOffset(e) { this.offset = Array.isArray(e) ? () => e : e } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(e) { this.supportsScrolling() && this.window.scrollTo(e[0], e[1]) } scrollToAnchor(e) { if (!this.supportsScrolling()) return; const t = function (e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && (e.body.createShadowRoot || e.body.attachShadow)) { const n = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let r = n.currentNode; for (; r;) { const e = r.shadowRoot; if (e) { const n = e.getElementById(t) || e.querySelector(`[name="${t}"]`); if (n) return n } r = n.nextNode() } } return null }(this.document, e); t && (this.scrollToElement(t), this.attemptFocus(t)) } setHistoryScrollRestoration(e) { if (this.supportScrollRestoration()) { const t = this.window.history; t && t.scrollRestoration && (t.scrollRestoration = e) } } scrollToElement(e) { const t = e.getBoundingClientRect(), n = t.left + this.window.pageXOffset, r = t.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], r - s[1]) } attemptFocus(e) { return e.focus(), this.document.activeElement === e } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const e = Te(this.window.history) || Te(Object.getPrototypeOf(this.window.history)); return !(!e || !e.writable && !e.set) } catch (e) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (e) { return !1 } } } function Te(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class Ie { } }, 1841: (e, t, n) => { "use strict"; n.d(t, { eN: () => A, JF: () => U }); var r = n(8583), s = n(8720), i = n(5917), o = n(8891), a = n(4612), c = n(5435), l = n(8002); class u { } class h { } class d { constructor(e) { this.normalizedNames = new Map, this.lazyUpdate = null, e ? this.lazyInit = "string" == typeof e ? () => { this.headers = new Map, e.split("\n").forEach(e => { const t = e.indexOf(":"); if (t > 0) { const n = e.slice(0, t), r = n.toLowerCase(), s = e.slice(t + 1).trim(); this.maybeSetNormalizedName(n, r), this.headers.has(r) ? this.headers.get(r).push(s) : this.headers.set(r, [s]) } }) } : () => { this.headers = new Map, Object.keys(e).forEach(t => { let n = e[t]; const r = t.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(r, n), this.maybeSetNormalizedName(t, r)) }) } : this.headers = new Map } has(e) { return this.init(), this.headers.has(e.toLowerCase()) } get(e) { this.init(); const t = this.headers.get(e.toLowerCase()); return t && t.length > 0 ? t[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(e) { return this.init(), this.headers.get(e.toLowerCase()) || null } append(e, t) { return this.clone({ name: e, value: t, op: "a" }) } set(e, t) { return this.clone({ name: e, value: t, op: "s" }) } delete(e, t) { return this.clone({ name: e, value: t, op: "d" }) } maybeSetNormalizedName(e, t) { this.normalizedNames.has(t) || this.normalizedNames.set(t, e) } init() { this.lazyInit && (this.lazyInit instanceof d ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(e => this.applyUpdate(e)), this.lazyUpdate = null)) } copyFrom(e) { e.init(), Array.from(e.headers.keys()).forEach(t => { this.headers.set(t, e.headers.get(t)), this.normalizedNames.set(t, e.normalizedNames.get(t)) }) } clone(e) { const t = new d; return t.lazyInit = this.lazyInit && this.lazyInit instanceof d ? this.lazyInit : this, t.lazyUpdate = (this.lazyUpdate || []).concat([e]), t } applyUpdate(e) { const t = e.name.toLowerCase(); switch (e.op) { case "a": case "s": let n = e.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(e.name, t); const r = ("a" === e.op ? this.headers.get(t) : void 0) || []; r.push(...n), this.headers.set(t, r); break; case "d": const s = e.value; if (s) { let e = this.headers.get(t); if (!e) return; e = e.filter(e => -1 === s.indexOf(e)), 0 === e.length ? (this.headers.delete(t), this.normalizedNames.delete(t)) : this.headers.set(t, e) } else this.headers.delete(t), this.normalizedNames.delete(t) } } forEach(e) { this.init(), Array.from(this.normalizedNames.keys()).forEach(t => e(this.normalizedNames.get(t), this.headers.get(t))) } } class f { encodeKey(e) { return p(e) } encodeValue(e) { return p(e) } decodeKey(e) { return decodeURIComponent(e) } decodeValue(e) { return decodeURIComponent(e) } } function p(e) { return encodeURIComponent(e).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } function m(e) { return `${e}` } class g { constructor(e = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = e.encoder || new f, e.fromString) { if (e.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (e, t) { const n = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(e => { const r = e.indexOf("="), [s, i] = -1 == r ? [t.decodeKey(e), ""] : [t.decodeKey(e.slice(0, r)), t.decodeValue(e.slice(r + 1))], o = n.get(s) || []; o.push(i), n.set(s, o) }), n }(e.fromString, this.encoder) } else e.fromObject ? (this.map = new Map, Object.keys(e.fromObject).forEach(t => { const n = e.fromObject[t]; this.map.set(t, Array.isArray(n) ? n : [n]) })) : this.map = null } has(e) { return this.init(), this.map.has(e) } get(e) { this.init(); const t = this.map.get(e); return t ? t[0] : null } getAll(e) { return this.init(), this.map.get(e) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(e, t) { return this.clone({ param: e, value: t, op: "a" }) } appendAll(e) { const t = []; return Object.keys(e).forEach(n => { const r = e[n]; Array.isArray(r) ? r.forEach(e => { t.push({ param: n, value: e, op: "a" }) }) : t.push({ param: n, value: r, op: "a" }) }), this.clone(t) } set(e, t) { return this.clone({ param: e, value: t, op: "s" }) } delete(e, t) { return this.clone({ param: e, value: t, op: "d" }) } toString() { return this.init(), this.keys().map(e => { const t = this.encoder.encodeKey(e); return this.map.get(e).map(e => t + "=" + this.encoder.encodeValue(e)).join("&") }).filter(e => "" !== e).join("&") } clone(e) { const t = new g({ encoder: this.encoder }); return t.cloneFrom = this.cloneFrom || this, t.updates = (this.updates || []).concat(e), t } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(e => this.map.set(e, this.cloneFrom.map.get(e))), this.updates.forEach(e => { switch (e.op) { case "a": case "s": const t = ("a" === e.op ? this.map.get(e.param) : void 0) || []; t.push(m(e.value)), this.map.set(e.param, t); break; case "d": if (void 0 === e.value) { this.map.delete(e.param); break } { let t = this.map.get(e.param) || []; const n = t.indexOf(m(e.value)); -1 !== n && t.splice(n, 1), t.length > 0 ? this.map.set(e.param, t) : this.map.delete(e.param) } } }), this.cloneFrom = this.updates = null) } } class y { constructor() { this.map = new Map } set(e, t) { return this.map.set(e, t), this } get(e) { return this.map.has(e) || this.map.set(e, e.defaultValue()), this.map.get(e) } delete(e) { return this.map.delete(e), this } keys() { return this.map.keys() } } function v(e) { return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer } function w(e) { return "undefined" != typeof Blob && e instanceof Blob } function b(e) { return "undefined" != typeof FormData && e instanceof FormData } class _ { constructor(e, t, n, r) { let s; if (this.url = t, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = e.toUpperCase(), function (e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || r ? (this.body = void 0 !== n ? n : null, s = r) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new d), this.context || (this.context = new y), this.params) { const e = this.params.toString(); if (0 === e.length) this.urlWithParams = t; else { const n = t.indexOf("?"); this.urlWithParams = t + (-1 === n ? "?" : n < t.length - 1 ? "&" : "") + e } } else this.params = new g, this.urlWithParams = t } serializeBody() { return null === this.body ? null : v(this.body) || w(this.body) || b(this.body) || "undefined" != typeof URLSearchParams && this.body instanceof URLSearchParams || "string" == typeof this.body ? this.body : this.body instanceof g ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || b(this.body) ? null : w(this.body) ? this.body.type || null : v(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof g ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(e = {}) { var t; const n = e.method || this.method, r = e.url || this.url, s = e.responseType || this.responseType, i = void 0 !== e.body ? e.body : this.body, o = void 0 !== e.withCredentials ? e.withCredentials : this.withCredentials, a = void 0 !== e.reportProgress ? e.reportProgress : this.reportProgress; let c = e.headers || this.headers, l = e.params || this.params; const u = null !== (t = e.context) && void 0 !== t ? t : this.context; return void 0 !== e.setHeaders && (c = Object.keys(e.setHeaders).reduce((t, n) => t.set(n, e.setHeaders[n]), c)), e.setParams && (l = Object.keys(e.setParams).reduce((t, n) => t.set(n, e.setParams[n]), l)), new _(n, r, i, { params: l, headers: c, context: u, reportProgress: a, responseType: s, withCredentials: o }) } } var E = (() => ((E = E || {})[E.Sent = 0] = "Sent", E[E.UploadProgress = 1] = "UploadProgress", E[E.ResponseHeader = 2] = "ResponseHeader", E[E.DownloadProgress = 3] = "DownloadProgress", E[E.Response = 4] = "Response", E[E.User = 5] = "User", E))(); class C { constructor(e, t = 200, n = "OK") { this.headers = e.headers || new d, this.status = void 0 !== e.status ? e.status : t, this.statusText = e.statusText || n, this.url = e.url || null, this.ok = this.status >= 200 && this.status < 300 } } class S extends C { constructor(e = {}) { super(e), this.type = E.ResponseHeader } clone(e = {}) { return new S({ headers: e.headers || this.headers, status: void 0 !== e.status ? e.status : this.status, statusText: e.statusText || this.statusText, url: e.url || this.url || void 0 }) } } class T extends C { constructor(e = {}) { super(e), this.type = E.Response, this.body = void 0 !== e.body ? e.body : null } clone(e = {}) { return new T({ body: void 0 !== e.body ? e.body : this.body, headers: e.headers || this.headers, status: void 0 !== e.status ? e.status : this.status, statusText: e.statusText || this.statusText, url: e.url || this.url || void 0 }) } } class I extends C { constructor(e) { super(e, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${e.url || "(unknown url)"}` : `Http failure response for ${e.url || "(unknown url)"}: ${e.status} ${e.statusText}`, this.error = e.error || null } } function k(e, t) { return { body: t, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let A = (() => { class e { constructor(e) { this.handler = e } request(e, t, n = {}) { let r; if (e instanceof _) r = e; else { let s, i; s = n.headers instanceof d ? n.headers : new d(n.headers), n.params && (i = n.params instanceof g ? n.params : new g({ fromObject: n.params })), r = new _(e, t, void 0 !== n.body ? n.body : null, { headers: s, context: n.context, params: i, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const s = (0, i.of)(r).pipe((0, a.b)(e => this.handler.handle(e))); if (e instanceof _ || "events" === n.observe) return s; const o = s.pipe((0, c.h)(e => e instanceof T)); switch (n.observe || "body") { case "body": switch (r.responseType) { case "arraybuffer": return o.pipe((0, l.U)(e => { if (null !== e.body && !(e.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return e.body })); case "blob": return o.pipe((0, l.U)(e => { if (null !== e.body && !(e.body instanceof Blob)) throw new Error("Response is not a Blob."); return e.body })); case "text": return o.pipe((0, l.U)(e => { if (null !== e.body && "string" != typeof e.body) throw new Error("Response is not a string."); return e.body })); case "json": default: return o.pipe((0, l.U)(e => e.body)) }case "response": return o; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(e, t = {}) { return this.request("DELETE", e, t) } get(e, t = {}) { return this.request("GET", e, t) } head(e, t = {}) { return this.request("HEAD", e, t) } jsonp(e, t) { return this.request("JSONP", e, { params: (new g).append(t, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(e, t = {}) { return this.request("OPTIONS", e, t) } patch(e, t, n = {}) { return this.request("PATCH", e, k(n, t)) } post(e, t, n = {}) { return this.request("POST", e, k(n, t)) } put(e, t, n = {}) { return this.request("PUT", e, k(n, t)) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(u)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); class x { constructor(e, t) { this.next = e, this.interceptor = t } handle(e) { return this.interceptor.intercept(e, this.next) } } const D = new s.OlP("HTTP_INTERCEPTORS"); let O = (() => { class e { intercept(e, t) { return t.handle(e) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); const R = /^\)\]\}',?\n/; let N = (() => { class e { constructor(e) { this.xhrFactory = e } handle(e) { if ("JSONP" === e.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new o.y(t => { const n = this.xhrFactory.build(); if (n.open(e.method, e.urlWithParams), e.withCredentials && (n.withCredentials = !0), e.headers.forEach((e, t) => n.setRequestHeader(e, t.join(","))), e.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !e.headers.has("Content-Type")) { const t = e.detectContentTypeHeader(); null !== t && n.setRequestHeader("Content-Type", t) } if (e.responseType) { const t = e.responseType.toLowerCase(); n.responseType = "json" !== t ? t : "text" } const r = e.serializeBody(); let s = null; const i = () => { if (null !== s) return s; const t = 1223 === n.status ? 204 : n.status, r = n.statusText || "OK", i = new d(n.getAllResponseHeaders()), o = function (e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(n) || e.url; return s = new S({ headers: i, status: t, statusText: r, url: o }), s }, o = () => { let { headers: r, status: s, statusText: o, url: a } = i(), c = null; 204 !== s && (c = void 0 === n.response ? n.responseText : n.response), 0 === s && (s = c ? 200 : 0); let l = s >= 200 && s < 300; if ("json" === e.responseType && "string" == typeof c) { const e = c; c = c.replace(R, ""); try { c = "" !== c ? JSON.parse(c) : null } catch (u) { c = e, l && (l = !1, c = { error: u, text: c }) } } l ? (t.next(new T({ body: c, headers: r, status: s, statusText: o, url: a || void 0 })), t.complete()) : t.error(new I({ error: c, headers: r, status: s, statusText: o, url: a || void 0 })) }, a = e => { const { url: r } = i(), s = new I({ error: e, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: r || void 0 }); t.error(s) }; let c = !1; const l = r => { c || (t.next(i()), c = !0); let s = { type: E.DownloadProgress, loaded: r.loaded }; r.lengthComputable && (s.total = r.total), "text" === e.responseType && n.responseText && (s.partialText = n.responseText), t.next(s) }, u = e => { let n = { type: E.UploadProgress, loaded: e.loaded }; e.lengthComputable && (n.total = e.total), t.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), n.addEventListener("timeout", a), n.addEventListener("abort", a), e.reportProgress && (n.addEventListener("progress", l), null !== r && n.upload && n.upload.addEventListener("progress", u)), n.send(r), t.next({ type: E.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("abort", a), n.removeEventListener("load", o), n.removeEventListener("timeout", a), e.reportProgress && (n.removeEventListener("progress", l), null !== r && n.upload && n.upload.removeEventListener("progress", u)), n.readyState !== n.DONE && n.abort() } }) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(r.JF)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); const P = new s.OlP("XSRF_COOKIE_NAME"), F = new s.OlP("XSRF_HEADER_NAME"); class L { } let M = (() => { class e { constructor(e, t, n) { this.doc = e, this.platform = t, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const e = this.doc.cookie || ""; return e !== this.lastCookieString && (this.parseCount++, this.lastToken = (0, r.Mx)(e, this.cookieName), this.lastCookieString = e), this.lastToken } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(r.K0), s.LFG(s.Lbi), s.LFG(P)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), $ = (() => { class e { constructor(e, t) { this.tokenService = e, this.headerName = t } intercept(e, t) { const n = e.url.toLowerCase(); if ("GET" === e.method || "HEAD" === e.method || n.startsWith("http://") || n.startsWith("https://")) return t.handle(e); const r = this.tokenService.getToken(); return null === r || e.headers.has(this.headerName) || (e = e.clone({ headers: e.headers.set(this.headerName, r) })), t.handle(e) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(L), s.LFG(F)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), B = (() => { class e { constructor(e, t) { this.backend = e, this.injector = t, this.chain = null } handle(e) { if (null === this.chain) { const e = this.injector.get(D, []); this.chain = e.reduceRight((e, t) => new x(e, t), this.backend) } return this.chain.handle(e) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(h), s.LFG(s.zs3)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), V = (() => { class e { static disable() { return { ngModule: e, providers: [{ provide: $, useClass: O }] } } static withOptions(t = {}) { return { ngModule: e, providers: [t.cookieName ? { provide: P, useValue: t.cookieName } : [], t.headerName ? { provide: F, useValue: t.headerName } : []] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({ providers: [$, { provide: D, useExisting: $, multi: !0 }, { provide: L, useClass: M }, { provide: P, useValue: "XSRF-TOKEN" }, { provide: F, useValue: "X-XSRF-TOKEN" }] }), e })(), U = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({ providers: [A, { provide: u, useClass: B }, N, { provide: h, useExisting: N }], imports: [[V.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), e })() }, 8720: (e, t, n) => { "use strict"; n.d(t, { deG: () => ln, tb: () => Rc, AFp: () => kc, ip1: () => Tc, CZH: () => Ic, hGG: () => Tl, z2F: () => ml, ahi: () => an, sBO: () => Ca, Sil: () => qc, _Vd: () => Wo, aQ5: () => hn, EJc: () => Fc, SBq: () => Zo, qLn: () => Ir, vpe: () => sc, L6J: () => Sc, gxx: () => hi, tBr: () => Rn, XFs: () => O, OlP: () => cn, zs3: () => Ii, ZZ4: () => ga, aQg: () => va, soG: () => Pc, YKP: () => Na, v3s: () => yl, h0i: () => Ra, PXZ: () => ul, R0b: () => Gc, FiY: () => Nn, r_U: () => Cc, Lbi: () => Oc, g9A: () => Dc, Qsj: () => ea, FYo: () => Jo, JOm: () => xr, Tiy: () => na, q3G: () => br, tp0: () => Pn, EAV: () => bl, Rgc: () => Aa, dDg: () => Jc, DyG: () => fn, q4F: () => sa, GfV: () => ra, i9L: () => dn, s_b: () => Fa, ifc: () => M, eFA: () => hl, G48: () => cl, Gpc: () => m, X6Q: () => al, _c5: () => Cl, VLi: () => nl, c2e: () => Nc, zSh: () => fi, wAp: () => No, vHH: () => v, EiD: () => vr, mCW: () => tr, qzn: () => zn, JVY: () => Gn, pB0: () => Xn, eBb: () => Yn, L6k: () => Wn, LAX: () => Kn, cg1: () => Do, Tjo: () => El, kL8: () => Oo, yhl: () => Hn, dqk: () => j, sIi: () => Li, CqO: () => to, QGY: () => Ji, F4k: () => eo, RDi: () => Ie, AaK: () => d, z3N: () => qn, qOj: () => Ai, TTD: () => be, _Bn: () => zo, xp6: () => gs, uIk: () => Ui, ekj: () => yo, Suo: () => vc, Xpm: () => J, lG2: () => oe, Yz7: () => E, cJS: () => C, oAB: () => re, Yjl: () => ae, Y36: () => zi, _UZ: () => Xi, GkF: () => Zi, qZA: () => Ki, TgZ: () => Yi, EpF: () => Qi, n5z: () => Qt, Ikx: () => Io, LFG: () => xn, $8M: () => en, $Z: () => Hi, NdJ: () => no, CRH: () => wc, oxw: () => io, ALo: () => Qa, lcZ: () => Ja, xi3: () => ec, Hsn: () => co, F$t: () => ao, Q6J: () => Gi, s9C: () => lo, MGl: () => uo, hYB: () => ho, FAE: () => fo, DdM: () => Xa, iGM: () => gc, CHM: () => ze, LSH: () => _r, kYT: () => se, Udp: () => go, YNc: () => qi, _uU: () => Co, Oqu: () => So, hij: () => To, Gf: () => yc }); var r = n(9765), s = n(5319), i = n(8891), o = n(6682), a = n(4458), c = n(1307); function l() { return new r.xQ } function u(e) { for (let t in e) if (e[t] === u) return t; throw Error("Could not find renamed property on target object.") } function h(e, t) { for (const n in t) t.hasOwnProperty(n) && !e.hasOwnProperty(n) && (e[n] = t[n]) } function d(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(d).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function f(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const p = u({ __forward_ref__: u }); function m(e) { return e.__forward_ref__ = m, e.toString = function () { return d(this()) }, e } function g(e) { return y(e) ? e() : e } function y(e) { return "function" == typeof e && e.hasOwnProperty(p) && e.__forward_ref__ === m } class v extends Error { constructor(e, t) { super(function (e, t) { return `${e ? `NG0${e}: ` : ""}${t}` }(e, t)), this.code = e } } function w(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function b(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : w(e) } function _(e, t) { const n = t ? ` in ${t}` : ""; throw new v("201", `No provider for ${b(e)} found${n}`) } function E(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function C(e) { return { providers: e.providers || [], imports: e.imports || [] } } function S(e) { return T(e, k) || T(e, x) } function T(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function I(e) { return e && (e.hasOwnProperty(A) || e.hasOwnProperty(D)) ? e[A] : null } const k = u({ "\u0275prov": u }), A = u({ "\u0275inj": u }), x = u({ ngInjectableDef: u }), D = u({ ngInjectorDef: u }); var O = (() => ((O = O || {})[O.Default = 0] = "Default", O[O.Host = 1] = "Host", O[O.Self = 2] = "Self", O[O.SkipSelf = 4] = "SkipSelf", O[O.Optional = 8] = "Optional", O))(); let R; function N(e) { const t = R; return R = e, t } function P(e, t, n) { const r = S(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & O.Optional ? null : void 0 !== t ? t : void _(d(e), "Injector") } function F(e) { return { toString: e }.toString() } var L = (() => ((L = L || {})[L.OnPush = 0] = "OnPush", L[L.Default = 1] = "Default", L))(), M = (() => ((M = M || {})[M.Emulated = 0] = "Emulated", M[M.None = 2] = "None", M[M.ShadowDom = 3] = "ShadowDom", M))(); const $ = "undefined" != typeof globalThis && globalThis, B = "undefined" != typeof window && window, V = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, U = "undefined" != typeof global && global, j = $ || U || B || V, q = {}, z = [], H = u({ "\u0275cmp": u }), G = u({ "\u0275dir": u }), W = u({ "\u0275pipe": u }), Y = u({ "\u0275mod": u }), K = u({ "\u0275loc": u }), X = u({ "\u0275fac": u }), Z = u({ __NG_ELEMENT_ID__: u }); let Q = 0; function J(e) { return F(() => { const t = {}, n = { type: e.type, providersResolver: null, decls: e.decls, vars: e.vars, factory: null, template: e.template || null, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: t, inputs: null, outputs: null, exportAs: e.exportAs || null, onPush: e.changeDetection === L.OnPush, directiveDefs: null, pipeDefs: null, selectors: e.selectors || z, viewQuery: e.viewQuery || null, features: e.features || null, data: e.data || {}, encapsulation: e.encapsulation || M.Emulated, id: "c", styles: e.styles || z, _: null, setInput: null, schemas: e.schemas || null, tView: null }, r = e.directives, s = e.features, i = e.pipes; return n.id += Q++, n.inputs = ie(e.inputs, t), n.outputs = ie(e.outputs), s && s.forEach(e => e(n)), n.directiveDefs = r ? () => ("function" == typeof r ? r() : r).map(ee) : null, n.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(te) : null, n }) } function ee(e) { return ce(e) || function (e) { return e[G] || null }(e) } function te(e) { return function (e) { return e[W] || null }(e) } const ne = {}; function re(e) { return F(() => { const t = { type: e.type, bootstrap: e.bootstrap || z, declarations: e.declarations || z, imports: e.imports || z, exports: e.exports || z, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null }; return null != e.id && (ne[e.id] = e.type), t }) } function se(e, t) { return F(() => { const n = le(e, !0); n.declarations = t.declarations || z, n.imports = t.imports || z, n.exports = t.exports || z }) } function ie(e, t) { if (null == e) return q; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let s = e[r], i = s; Array.isArray(s) && (i = s[1], s = s[0]), n[s] = r, t && (t[s] = i) } return n } const oe = J; function ae(e) { return { type: e.type, name: e.name, factory: null, pure: !1 !== e.pure, onDestroy: e.type.prototype.ngOnDestroy || null } } function ce(e) { return e[H] || null } function le(e, t) { const n = e[Y] || null; if (!n && !0 === t) throw new Error(`Type ${d(e)} does not have '\u0275mod' property.`); return n } const ue = 20, he = 10; function de(e) { return Array.isArray(e) && "object" == typeof e[1] } function fe(e) { return Array.isArray(e) && !0 === e[1] } function pe(e) { return 0 != (8 & e.flags) } function me(e) { return 2 == (2 & e.flags) } function ge(e) { return 1 == (1 & e.flags) } function ye(e) { return null !== e.template } function ve(e, t) { return e.hasOwnProperty(X) ? e[X] : null } class we { constructor(e, t, n) { this.previousValue = e, this.currentValue = t, this.firstChange = n } isFirstChange() { return this.firstChange } } function be() { return _e } function _e(e) { return e.type.prototype.ngOnChanges && (e.setInput = Ce), Ee } function Ee() { const e = Se(this), t = null == e ? void 0 : e.current; if (t) { const n = e.previous; if (n === q) e.previous = t; else for (let e in t) n[e] = t[e]; e.current = null, this.ngOnChanges(t) } } function Ce(e, t, n, r) { const s = Se(e) || function (e, t) { return e.__ngSimpleChanges__ = t }(e, { previous: q, current: null }), i = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[n], c = o[a]; i[a] = new we(c && c.currentValue, t, o === q), e[r] = t } function Se(e) { return e.__ngSimpleChanges__ || null } let Te; function Ie(e) { Te = e } function ke(e) { return !!e.listen } be.ngInherit = !0; const Ae = { createRenderer: (e, t) => void 0 !== Te ? Te : "undefined" != typeof document ? document : void 0 }; function xe(e) { for (; Array.isArray(e);)e = e[0]; return e } function De(e, t) { return xe(t[e]) } function Oe(e, t) { return xe(t[e.index]) } function Re(e, t) { return e.data[t] } function Ne(e, t) { return e[t] } function Pe(e, t) { const n = t[e]; return de(n) ? n : n[0] } function Fe(e) { return 4 == (4 & e[2]) } function Le(e) { return 128 == (128 & e[2]) } function Me(e, t) { return null == t ? null : e[t] } function $e(e) { e[18] = 0 } function Be(e, t) { e[5] += t; let n = e, r = e[3]; for (; null !== r && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);)r[5] += t, n = r, r = r[3] } const Ve = { lFrame: ut(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function Ue() { return Ve.bindingsEnabled } function je() { return Ve.lFrame.lView } function qe() { return Ve.lFrame.tView } function ze(e) { return Ve.lFrame.contextLView = e, e[8] } function He() { let e = Ge(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function Ge() { return Ve.lFrame.currentTNode } function We(e, t) { const n = Ve.lFrame; n.currentTNode = e, n.isParent = t } function Ye() { return Ve.lFrame.isParent } function Ke() { Ve.lFrame.isParent = !1 } function Xe() { return Ve.isInCheckNoChangesMode } function Ze(e) { Ve.isInCheckNoChangesMode = e } function Qe() { const e = Ve.lFrame; let t = e.bindingRootIndex; return -1 === t && (t = e.bindingRootIndex = e.tView.bindingStartIndex), t } function Je() { return Ve.lFrame.bindingIndex } function et() { return Ve.lFrame.bindingIndex++ } function tt(e) { const t = Ve.lFrame, n = t.bindingIndex; return t.bindingIndex = t.bindingIndex + e, n } function nt(e, t) { const n = Ve.lFrame; n.bindingIndex = n.bindingRootIndex = e, rt(t) } function rt(e) { Ve.lFrame.currentDirectiveIndex = e } function st() { return Ve.lFrame.currentQueryIndex } function it(e) { Ve.lFrame.currentQueryIndex = e } function ot(e) { const t = e[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null } function at(e, t, n) { if (n & O.SkipSelf) { let r = t, s = e; for (; r = r.parent, !(null !== r || n & O.Host || (r = ot(s), null === r) || (s = s[15], 10 & r.type));); if (null === r) return !1; t = r, e = s } const r = Ve.lFrame = lt(); return r.currentTNode = t, r.lView = e, !0 } function ct(e) { const t = lt(), n = e[1]; Ve.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function lt() { const e = Ve.lFrame, t = null === e ? null : e.child; return null === t ? ut(e) : t } function ut(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function ht() { const e = Ve.lFrame; return Ve.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const dt = ht; function ft() { const e = ht(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function pt() { return Ve.lFrame.selectedIndex } function mt(e) { Ve.lFrame.selectedIndex = e } function gt() { const e = Ve.lFrame; return Re(e.tView, e.selectedIndex) } function yt(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const t = e.data[n].type.prototype, { ngAfterContentInit: r, ngAfterContentChecked: s, ngAfterViewInit: i, ngAfterViewChecked: o, ngOnDestroy: a } = t; r && (e.contentHooks || (e.contentHooks = [])).push(-n, r), s && ((e.contentHooks || (e.contentHooks = [])).push(n, s), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, s)), i && (e.viewHooks || (e.viewHooks = [])).push(-n, i), o && ((e.viewHooks || (e.viewHooks = [])).push(n, o), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, o)), null != a && (e.destroyHooks || (e.destroyHooks = [])).push(n, a) } } function vt(e, t, n) { _t(e, t, 3, n) } function wt(e, t, n, r) { (3 & e[2]) === n && _t(e, t, n, r) } function bt(e, t) { let n = e[2]; (3 & n) === t && (n &= 2047, n += 1, e[2] = n) } function _t(e, t, n, r) { const s = null != r ? r : -1, i = t.length - 1; let o = 0; for (let a = void 0 !== r ? 65535 & e[18] : 0; a < i; a++)if ("number" == typeof t[a + 1]) { if (o = t[a], null != r && o >= r) break } else t[a] < 0 && (e[18] += 65536), (o < s || -1 == s) && (Et(e, n, t, a), e[18] = (4294901760 & e[18]) + a + 2), a++ } function Et(e, t, n, r) { const s = n[r] < 0, i = n[r + 1], o = e[s ? -n[r] : n[r]]; if (s) { if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) { e[2] += 2048; try { i.call(o) } finally { } } } else try { i.call(o) } finally { } } const Ct = -1; class St { constructor(e, t, n) { this.factory = e, this.resolving = !1, this.canSeeViewProviders = t, this.injectImpl = n } } function Tt(e, t, n) { const r = ke(e); let s = 0; for (; s < n.length;) { const i = n[s]; if ("number" == typeof i) { if (0 !== i) break; s++; const o = n[s++], a = n[s++], c = n[s++]; r ? e.setAttribute(t, a, c, o) : t.setAttributeNS(o, a, c) } else { const o = i, a = n[++s]; kt(o) ? r && e.setProperty(t, o, a) : r ? e.setAttribute(t, o, a) : t.setAttribute(o, a), s++ } } return s } function It(e) { return 3 === e || 4 === e || 6 === e } function kt(e) { return 64 === e.charCodeAt(0) } function At(e, t) { if (null === t || 0 === t.length); else if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const s = t[r]; "number" == typeof s ? n = s : 0 === n || xt(e, n, s, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function xt(e, t, n, r, s) { let i = 0, o = e.length; if (-1 === t) o = -1; else for (; i < e.length;) { const n = e[i++]; if ("number" == typeof n) { if (n === t) { o = -1; break } if (n > t) { o = i - 1; break } } } for (; i < e.length;) { const t = e[i]; if ("number" == typeof t) break; if (t === n) { if (null === r) return void (null !== s && (e[i + 1] = s)); if (r === e[i + 1]) return void (e[i + 2] = s) } i++, null !== r && i++, null !== s && i++ } -1 !== o && (e.splice(o, 0, t), i = o + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== s && e.splice(i++, 0, s) } function Dt(e) { return e !== Ct } function Ot(e) { return 32767 & e } function Rt(e, t) { let n = e >> 16, r = t; for (; n > 0;)r = r[15], n--; return r } let Nt = !0; function Pt(e) { const t = Nt; return Nt = e, t } let Ft = 0; function Lt(e, t) { const n = $t(e, t); if (-1 !== n) return n; const r = t[1]; r.firstCreatePass && (e.injectorIndex = t.length, Mt(r.data, e), Mt(t, null), Mt(r.blueprint, null)); const s = Bt(e, t), i = e.injectorIndex; if (Dt(s)) { const e = Ot(s), n = Rt(s, t), r = n[1].data; for (let s = 0; s < 8; s++)t[i + s] = n[e + s] | r[e + s] } return t[i + 8] = s, i } function Mt(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function $t(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Bt(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, s = t; for (; null !== s;) { const e = s[1], t = e.type; if (r = 2 === t ? e.declTNode : 1 === t ? s[6] : null, null === r) return Ct; if (n++, s = s[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return Ct } function Vt(e, t, n) { !function (e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Z) && (r = n[Z]), null == r && (r = n[Z] = Ft++); const s = 255 & r; t.data[e + (s >> 5)] |= 1 << s }(e, t, n) } function Ut(e, t, n) { if (n & O.Optional) return e; _(t, "NodeInjector") } function jt(e, t, n, r) { if (n & O.Optional && void 0 === r && (r = null), 0 == (n & (O.Self | O.Host))) { const s = e[9], i = N(void 0); try { return s ? s.get(t, r, n & O.Optional) : P(t, r, n & O.Optional) } finally { N(i) } } return Ut(r, t, n) } function qt(e, t, n, r = O.Default, s) { if (null !== e) { const i = function (e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(Z) ? e[Z] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : Ht : t }(n); if ("function" == typeof i) { if (!at(t, e, r)) return r & O.Host ? Ut(s, n, r) : jt(t, n, r, s); try { const e = i(r); if (null != e || r & O.Optional) return e; _(n) } finally { dt() } } else if ("number" == typeof i) { let s = null, o = $t(e, t), a = Ct, c = r & O.Host ? t[16][6] : null; for ((-1 === o || r & O.SkipSelf) && (a = -1 === o ? Bt(e, t) : t[o + 8], a !== Ct && Xt(r, !1) ? (s = t[1], o = Ot(a), t = Rt(a, t)) : o = -1); -1 !== o;) { const e = t[1]; if (Kt(i, o, e.data)) { const e = Gt(o, t, n, s, r, c); if (e !== zt) return e } a = t[o + 8], a !== Ct && Xt(r, t[1].data[o + 8] === c) && Kt(i, o, t) ? (s = e, o = Ot(a), t = Rt(a, t)) : o = -1 } } } return jt(t, n, r, s) } const zt = {}; function Ht() { return new Zt(He(), je()) } function Gt(e, t, n, r, s, i) { const o = t[1], a = o.data[e + 8], c = Wt(a, o, n, null == r ? me(a) && Nt : r != o && 0 != (3 & a.type), s & O.Host && i === a); return null !== c ? Yt(t, o, c, a) : zt } function Wt(e, t, n, r, s) { const i = e.providerIndexes, o = t.data, a = 1048575 & i, c = e.directiveStart, l = i >> 20, u = s ? a + l : e.directiveEnd; for (let h = r ? a : a + l; h < u; h++) { const e = o[h]; if (h < c && n === e || h >= c && e.type === n) return h } if (s) { const e = o[c]; if (e && ye(e) && e.type === n) return c } return null } function Yt(e, t, n, r) { let s = e[n]; const i = t.data; if (s instanceof St) { const o = s; o.resolving && function (e, t) { throw new v("200", `Circular dependency in DI detected for ${e}`) }(b(i[n])); const a = Pt(o.canSeeViewProviders); o.resolving = !0; const c = o.injectImpl ? N(o.injectImpl) : null; at(e, r, O.Default); try { s = e[n] = o.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function (e, t, n) { const { ngOnChanges: r, ngOnInit: s, ngDoCheck: i } = t.type.prototype; if (r) { const r = _e(t); (n.preOrderHooks || (n.preOrderHooks = [])).push(e, r), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, r) } s && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, s), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== c && N(c), Pt(a), o.resolving = !1, dt() } } return s } function Kt(e, t, n) { return !!(n[t + (e >> 5)] & 1 << e) } function Xt(e, t) { return !(e & O.Self || e & O.Host && t) } class Zt { constructor(e, t) { this._tNode = e, this._lView = t } get(e, t) { return qt(this._tNode, this._lView, e, void 0, t) } } function Qt(e) { return F(() => { const t = e.prototype.constructor, n = t[X] || Jt(t), r = Object.prototype; let s = Object.getPrototypeOf(e.prototype).constructor; for (; s && s !== r;) { const e = s[X] || Jt(s); if (e && e !== n) return e; s = Object.getPrototypeOf(s) } return e => new e }) } function Jt(e) { return y(e) ? () => { const t = Jt(g(e)); return t && t() } : ve(e) } function en(e) { return function (e, t) { if ("class" === t) return e.classes; if ("style" === t) return e.styles; const n = e.attrs; if (n) { const e = n.length; let r = 0; for (; r < e;) { const s = n[r]; if (It(s)) break; if (0 === s) r += 2; else if ("number" == typeof s) for (r++; r < e && "string" == typeof n[r];)r++; else { if (s === t) return n[r + 1]; r += 2 } } } return null }(He(), e) } const tn = "__parameters__", nn = "__prop__metadata__"; function rn(e) { return function (...t) { if (e) { const n = e(...t); for (const e in n) this[e] = n[e] } } } function sn(e, t, n) { return F(() => { const r = rn(t); function s(...e) { if (this instanceof s) return r.apply(this, e), this; const t = new s(...e); return n.annotation = t, n; function n(e, n, r) { const s = e.hasOwnProperty(tn) ? e[tn] : Object.defineProperty(e, tn, { value: [] })[tn]; for (; s.length <= r;)s.push(null); return (s[r] = s[r] || []).push(t), e } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = e, s.annotationCls = s, s }) } function on(e, t, n, r) { return F(() => { const s = rn(t); function i(...e) { if (this instanceof i) return s.apply(this, e), this; const t = new i(...e); return function (n, s) { const i = n.constructor, o = i.hasOwnProperty(nn) ? i[nn] : Object.defineProperty(i, nn, { value: {} })[nn]; o[s] = o.hasOwnProperty(s) && o[s] || [], o[s].unshift(t), r && r(n, s, ...e) } } return n && (i.prototype = Object.create(n.prototype)), i.prototype.ngMetadataName = e, i.annotationCls = i, i }) } const an = function () { return sn("Attribute", e => ({ attributeName: e, __NG_ELEMENT_ID__: () => en(e) })) }(); class cn { constructor(e, t) { this._desc = e, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof t ? this.__NG_ELEMENT_ID__ = t : void 0 !== t && (this.\u0275prov = E({ token: this, providedIn: t.providedIn || "root", factory: t.factory })) } toString() { return `InjectionToken ${this._desc}` } } const ln = new cn("AnalyzeForEntryComponents"); class un { } const hn = on("ContentChild", (e, t = {}) => Object.assign({ selector: e, first: !0, isViewQuery: !1, descendants: !0 }, t), un), dn = on("ViewChild", (e, t) => Object.assign({ selector: e, first: !0, isViewQuery: !0, descendants: !0 }, t), un), fn = Function; function pn(e, t) { void 0 === t && (t = e); for (let n = 0; n < e.length; n++) { let r = e[n]; Array.isArray(r) ? (t === e && (t = e.slice(0, n)), pn(r, t)) : t !== e && t.push(r) } return t } function mn(e, t) { e.forEach(e => Array.isArray(e) ? mn(e, t) : t(e)) } function gn(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function yn(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } function vn(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n } function wn(e, t, n) { let r = _n(e, t); return r >= 0 ? e[1 | r] = n : (r = ~r, function (e, t, n, r) { let s = e.length; if (s == t) e.push(n, r); else if (1 === s) e.push(r, e[0]), e[0] = n; else { for (s--, e.push(e[s - 1], e[s]); s > t;)e[s] = e[s - 2], s--; e[t] = n, e[t + 1] = r } }(e, r, t, n)), r } function bn(e, t) { const n = _n(e, t); if (n >= 0) return e[1 | n] } function _n(e, t) { return function (e, t, n) { let r = 0, s = e.length >> 1; for (; s !== r;) { const n = r + (s - r >> 1), i = e[n << 1]; if (t === i) return n << 1; i > t ? s = n : r = n + 1 } return ~(s << 1) }(e, t) } const En = {}, Cn = /\n/gm, Sn = "__source", Tn = u({ provide: String, useValue: u }); let In; function kn(e) { const t = In; return In = e, t } function An(e, t = O.Default) { if (void 0 === In) throw new Error("inject() must be called from an injection context"); return null === In ? P(e, void 0, t) : In.get(e, t & O.Optional ? null : void 0, t) } function xn(e, t = O.Default) { return (R || An)(g(e), t) } function Dn(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = g(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new Error("Arguments array must have arguments."); let e, n = O.Default; for (let t = 0; t < r.length; t++) { const s = r[t], i = s.__NG_DI_FLAG__; "number" == typeof i ? -1 === i ? e = s.token : n |= i : e = s } t.push(xn(e, n)) } else t.push(xn(r)) } return t } function On(e, t) { return e.__NG_DI_FLAG__ = t, e.prototype.__NG_DI_FLAG__ = t, e } const Rn = On(sn("Inject", e => ({ token: e })), -1), Nn = On(sn("Optional"), 8), Pn = On(sn("SkipSelf"), 4); let Fn; function Ln(e) { var t; return (null === (t = function () { if (void 0 === Fn && (Fn = null, j.trustedTypes)) try { Fn = j.trustedTypes.createPolicy("angular", { createHTML: e => e, createScript: e => e, createScriptURL: e => e }) } catch (t) { } return Fn }()) || void 0 === t ? void 0 : t.createHTML(e)) || e } class Mn { constructor(e) { this.changingThisBreaksApplicationSecurity = e } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class $n extends Mn { getTypeName() { return "HTML" } } class Bn extends Mn { getTypeName() { return "Style" } } class Vn extends Mn { getTypeName() { return "Script" } } class Un extends Mn { getTypeName() { return "URL" } } class jn extends Mn { getTypeName() { return "ResourceURL" } } function qn(e) { return e instanceof Mn ? e.changingThisBreaksApplicationSecurity : e } function zn(e, t) { const n = Hn(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === t } function Hn(e) { return e instanceof Mn && e.getTypeName() || null } function Gn(e) { return new $n(e) } function Wn(e) { return new Bn(e) } function Yn(e) { return new Vn(e) } function Kn(e) { return new Un(e) } function Xn(e) { return new jn(e) } class Zn { constructor(e) { this.inertDocumentHelper = e } getInertBodyElement(e) { e = "<body><remove></remove>" + e; try { const t = (new window.DOMParser).parseFromString(Ln(e), "text/html").body; return null === t ? this.inertDocumentHelper.getInertBodyElement(e) : (t.removeChild(t.firstChild), t) } catch (t) { return null } } } class Qn { constructor(e) { if (this.defaultDoc = e, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const e = this.inertDocument.createElement("html"); this.inertDocument.appendChild(e); const t = this.inertDocument.createElement("body"); e.appendChild(t) } } getInertBodyElement(e) { const t = this.inertDocument.createElement("template"); if ("content" in t) return t.innerHTML = Ln(e), t; const n = this.inertDocument.createElement("body"); return n.innerHTML = Ln(e), this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n } stripCustomNsAttrs(e) { const t = e.attributes; for (let r = t.length - 1; 0 < r; r--) { const n = t.item(r).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || e.removeAttribute(n) } let n = e.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Jn = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, er = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function tr(e) { return (e = String(e)).match(Jn) || e.match(er) ? e : "unsafe:" + e } function nr(e) { const t = {}; for (const n of e.split(",")) t[n] = !0; return t } function rr(...e) { const t = {}; for (const n of e) for (const e in n) n.hasOwnProperty(e) && (t[e] = !0); return t } const sr = nr("area,br,col,hr,img,wbr"), ir = nr("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), or = nr("rp,rt"), ar = rr(or, ir), cr = rr(sr, rr(ir, nr("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), rr(or, nr("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), ar), lr = nr("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), ur = nr("srcset"), hr = rr(lr, ur, nr("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), nr("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), dr = nr("script,style,template"); class fr { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(e) { let t = e.firstChild, n = !0; for (; t;)if (t.nodeType === Node.ELEMENT_NODE ? n = this.startElement(t) : t.nodeType === Node.TEXT_NODE ? this.chars(t.nodeValue) : this.sanitizedSomething = !0, n && t.firstChild) t = t.firstChild; else for (; t;) { t.nodeType === Node.ELEMENT_NODE && this.endElement(t); let e = this.checkClobberedElement(t, t.nextSibling); if (e) { t = e; break } t = this.checkClobberedElement(t, t.parentNode) } return this.buf.join("") } startElement(e) { const t = e.nodeName.toLowerCase(); if (!cr.hasOwnProperty(t)) return this.sanitizedSomething = !0, !dr.hasOwnProperty(t); this.buf.push("<"), this.buf.push(t); const n = e.attributes; for (let s = 0; s < n.length; s++) { const e = n.item(s), t = e.name, i = t.toLowerCase(); if (!hr.hasOwnProperty(i)) { this.sanitizedSomething = !0; continue } let o = e.value; lr[i] && (o = tr(o)), ur[i] && (r = o, o = (r = String(r)).split(",").map(e => tr(e.trim())).join(", ")), this.buf.push(" ", t, '="', gr(o), '"') } var r; return this.buf.push(">"), !0 } endElement(e) { const t = e.nodeName.toLowerCase(); cr.hasOwnProperty(t) && !sr.hasOwnProperty(t) && (this.buf.push("</"), this.buf.push(t), this.buf.push(">")) } chars(e) { this.buf.push(gr(e)) } checkClobberedElement(e, t) { if (t && (e.compareDocumentPosition(t) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${e.outerHTML}`); return t } } const pr = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, mr = /([^\#-~ |!])/g; function gr(e) { return e.replace(/&/g, "&amp;").replace(pr, function (e) { return "&#" + (1024 * (e.charCodeAt(0) - 55296) + (e.charCodeAt(1) - 56320) + 65536) + ";" }).replace(mr, function (e) { return "&#" + e.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let yr; function vr(e, t) { let n = null; try { yr = yr || function (e) { const t = new Qn(e); return function () { try { return !!(new window.DOMParser).parseFromString(Ln(""), "text/html") } catch (e) { return !1 } }() ? new Zn(t) : t }(e); let r = t ? String(t) : ""; n = yr.getInertBodyElement(r); let s = 5, i = r; do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable"); s--, r = i, i = n.innerHTML, n = yr.getInertBodyElement(r) } while (r !== i); return Ln((new fr).sanitizeChildren(wr(n) || n)) } finally { if (n) { const e = wr(n) || n; for (; e.firstChild;)e.removeChild(e.firstChild) } } } function wr(e) { return "content" in e && function (e) { return e.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === e.nodeName }(e) ? e.content : null } var br = (() => ((br = br || {})[br.NONE = 0] = "NONE", br[br.HTML = 1] = "HTML", br[br.STYLE = 2] = "STYLE", br[br.SCRIPT = 3] = "SCRIPT", br[br.URL = 4] = "URL", br[br.RESOURCE_URL = 5] = "RESOURCE_URL", br))(); function _r(e) { const t = function () { const e = je(); return e && e[12] }(); return t ? t.sanitize(br.URL, e) || "" : zn(e, "URL") ? qn(e) : tr(w(e)) } function Er(e, t) { e.__ngContext__ = t } function Cr(e) { const t = function (e) { return e.__ngContext__ || null }(e); return t ? Array.isArray(t) ? t : t.lView : null } function Sr(e) { return e.ngOriginalError } function Tr(e, ...t) { e.error(...t) } class Ir { constructor() { this._console = console } handleError(e) { const t = this._findOriginalError(e), n = this._findContext(e), r = function (e) { return e && e.ngErrorLogger || Tr }(e); r(this._console, "ERROR", e), t && r(this._console, "ORIGINAL ERROR", t), n && r(this._console, "ERROR CONTEXT", n) } _findContext(e) { return e ? function (e) { return e.ngDebugContext }(e) || this._findContext(Sr(e)) : null } _findOriginalError(e) { let t = e && Sr(e); for (; t && Sr(t);)t = Sr(t); return t || null } } const kr = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(j))(); function Ar(e) { return e instanceof Function ? e() : e } var xr = (() => ((xr = xr || {})[xr.Important = 1] = "Important", xr[xr.DashCase = 2] = "DashCase", xr))(); function Dr(e, t) { return (void 0)(e, t) } function Or(e) { const t = e[3]; return fe(t) ? t[3] : t } function Rr(e) { return Pr(e[13]) } function Nr(e) { return Pr(e[4]) } function Pr(e) { for (; null !== e && !fe(e);)e = e[4]; return e } function Fr(e, t, n, r, s) { if (null != r) { let i, o = !1; fe(r) ? i = r : de(r) && (o = !0, r = r[0]); const a = xe(r); 0 === e && null !== n ? null == s ? qr(t, n, a) : jr(t, n, a, s || null, !0) : 1 === e && null !== n ? jr(t, n, a, s || null, !0) : 2 === e ? function (e, t, n) { const r = Hr(e, t); r && function (e, t, n, r) { ke(e) ? e.removeChild(t, n, r) : t.removeChild(n) }(e, r, t, n) }(t, a, o) : 3 === e && t.destroyNode(a), null != i && function (e, t, n, r, s) { const i = n[7]; i !== xe(n) && Fr(t, e, r, i, s); for (let o = he; o < n.length; o++) { const s = n[o]; Jr(s[1], s, e, t, r, i) } }(t, e, i, n, s) } } function Lr(e, t, n) { return ke(e) ? e.createElement(t, n) : null === n ? e.createElement(t) : e.createElementNS(n, t) } function Mr(e, t) { const n = e[9], r = n.indexOf(t), s = t[3]; 1024 & t[2] && (t[2] &= -1025, Be(s, -1)), n.splice(r, 1) } function $r(e, t) { if (e.length <= he) return; const n = he + t, r = e[n]; if (r) { const i = r[17]; null !== i && i !== e && Mr(i, r), t > 0 && (e[n - 1][4] = r[4]); const o = yn(e, he + t); Jr(r[1], s = r, s[11], 2, null, null), s[0] = null, s[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), r[3] = null, r[4] = null, r[2] &= -129 } var s; return r } function Br(e, t) { if (!(256 & t[2])) { const n = t[11]; ke(n) && n.destroyNode && Jr(e, t, n, 3, null, null), function (e) { let t = e[13]; if (!t) return Vr(e[1], e); for (; t;) { let n = null; if (de(t)) n = t[13]; else { const e = t[10]; e && (n = e) } if (!n) { for (; t && !t[4] && t !== e;)de(t) && Vr(t[1], t), t = t[3]; null === t && (t = e), de(t) && Vr(t[1], t), n = t && t[4] } t = n } }(t) } } function Vr(e, t) { if (!(256 & t[2])) { t[2] &= -129, t[2] |= 256, function (e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const e = t[n[r]]; if (!(e instanceof St)) { const t = n[r + 1]; if (Array.isArray(t)) for (let n = 0; n < t.length; n += 2) { const r = e[t[n]], s = t[n + 1]; try { s.call(r) } finally { } } else try { t.call(e) } finally { } } } }(e, t), function (e, t) { const n = e.cleanup, r = t[7]; let s = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const e = n[i + 1], o = "function" == typeof e ? e(t) : xe(t[e]), a = r[s = n[i + 2]], c = n[i + 3]; "boolean" == typeof c ? o.removeEventListener(n[i], a, c) : c >= 0 ? r[s = c]() : r[s = -c].unsubscribe(), i += 2 } else { const e = r[s = n[i + 1]]; n[i].call(e) } if (null !== r) { for (let e = s + 1; e < r.length; e++)(0, r[e])(); t[7] = null } }(e, t), 1 === t[1].type && ke(t[11]) && t[11].destroy(); const n = t[17]; if (null !== n && fe(t[3])) { n !== t[3] && Mr(n, t); const r = t[19]; null !== r && r.detachView(e) } } } function Ur(e, t, n) { return function (e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const t = e.data[r.directiveStart].encapsulation; if (t === M.None || t === M.Emulated) return null } return Oe(r, n) }(e, t.parent, n) } function jr(e, t, n, r, s) { ke(e) ? e.insertBefore(t, n, r, s) : t.insertBefore(n, r, s) } function qr(e, t, n) { ke(e) ? e.appendChild(t, n) : t.appendChild(n) } function zr(e, t, n, r, s) { null !== r ? jr(e, t, n, r, s) : qr(e, t, n) } function Hr(e, t) { return ke(e) ? e.parentNode(t) : t.parentNode } function Gr(e, t, n) { return Wr(e, t, n) } let Wr = function (e, t, n) { return 40 & e.type ? Oe(e, n) : null }; function Yr(e, t, n, r) { const s = Ur(e, r, t), i = t[11], o = Gr(r.parent || t[6], r, t); if (null != s) if (Array.isArray(n)) for (let a = 0; a < n.length; a++)zr(i, s, n[a], o, !1); else zr(i, s, n, o, !1) } function Kr(e, t) { if (null !== t) { const n = t.type; if (3 & n) return Oe(t, e); if (4 & n) return Zr(-1, e[t.index]); if (8 & n) { const n = t.child; if (null !== n) return Kr(e, n); { const n = e[t.index]; return fe(n) ? Zr(-1, n) : xe(n) } } if (32 & n) return Dr(t, e)() || xe(e[t.index]); { const n = Xr(e, t); return null !== n ? Array.isArray(n) ? n[0] : Kr(Or(e[16]), n) : Kr(e, t.next) } } return null } function Xr(e, t) { return null !== t ? e[16][6].projection[t.projection] : null } function Zr(e, t) { const n = he + e + 1; if (n < t.length) { const e = t[n], r = e[1].firstChild; if (null !== r) return Kr(e, r) } return t[7] } function Qr(e, t, n, r, s, i, o) { for (; null != n;) { const a = r[n.index], c = n.type; if (o && 0 === t && (a && Er(xe(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & c) Qr(e, t, n.child, r, s, i, !1), Fr(t, e, s, a, i); else if (32 & c) { const o = Dr(n, r); let c; for (; c = o();)Fr(t, e, s, c, i); Fr(t, e, s, a, i) } else 16 & c ? es(e, t, r, n, s, i) : Fr(t, e, s, a, i); n = o ? n.projectionNext : n.next } } function Jr(e, t, n, r, s, i) { Qr(n, r, e.firstChild, t, s, i, !1) } function es(e, t, n, r, s, i) { const o = n[16], a = o[6].projection[r.projection]; if (Array.isArray(a)) for (let c = 0; c < a.length; c++)Fr(t, e, s, a[c], i); else Qr(e, t, a, o[3], s, i, !0) } function ts(e, t, n) { ke(e) ? e.setAttribute(t, "style", n) : t.style.cssText = n } function ns(e, t, n) { ke(e) ? "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) : t.className = n } function rs(e, t, n) { let r = e.length; for (; ;) { const s = e.indexOf(t, n); if (-1 === s) return s; if (0 === s || e.charCodeAt(s - 1) <= 32) { const n = t.length; if (s + n === r || e.charCodeAt(s + n) <= 32) return s } n = s + 1 } } const ss = "ng-template"; function is(e, t, n) { let r = 0; for (; r < e.length;) { let s = e[r++]; if (n && "class" === s) { if (s = e[r], -1 !== rs(s.toLowerCase(), t, 0)) return !0 } else if (1 === s) { for (; r < e.length && "string" == typeof (s = e[r++]);)if (s.toLowerCase() === t) return !0; return !1 } } return !1 } function os(e) { return 4 === e.type && e.value !== ss } function as(e, t, n) { return t === (4 !== e.type || n ? e.value : ss) } function cs(e, t, n) { let r = 4; const s = e.attrs || [], i = function (e) { for (let t = 0; t < e.length; t++)if (It(e[t])) return t; return e.length }(s); let o = !1; for (let a = 0; a < t.length; a++) { const c = t[a]; if ("number" != typeof c) { if (!o) if (4 & r) { if (r = 2 | 1 & r, "" !== c && !as(e, c, n) || "" === c && 1 === t.length) { if (ls(r)) return !1; o = !0 } } else { const l = 8 & r ? c : t[++a]; if (8 & r && null !== e.attrs) { if (!is(e.attrs, l, n)) { if (ls(r)) return !1; o = !0 } continue } const u = us(8 & r ? "class" : c, s, os(e), n); if (-1 === u) { if (ls(r)) return !1; o = !0; continue } if ("" !== l) { let e; e = u > i ? "" : s[u + 1].toLowerCase(); const t = 8 & r ? e : null; if (t && -1 !== rs(t, l, 0) || 2 & r && l !== e) { if (ls(r)) return !1; o = !0 } } } } else { if (!o && !ls(r) && !ls(c)) return !1; if (o && ls(c)) continue; o = !1, r = c | 1 & r } } return ls(r) || o } function ls(e) { return 0 == (1 & e) } function us(e, t, n, r) { if (null === t) return -1; let s = 0; if (r || !n) { let n = !1; for (; s < t.length;) { const r = t[s]; if (r === e) return s; if (3 === r || 6 === r) n = !0; else { if (1 === r || 2 === r) { let e = t[++s]; for (; "string" == typeof e;)e = t[++s]; continue } if (4 === r) break; if (0 === r) { s += 4; continue } } s += n ? 1 : 2 } return -1 } return function (e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function hs(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (cs(e, t[r], n)) return !0; return !1 } function ds(e, t) { e: for (let n = 0; n < t.length; n++) { const r = t[n]; if (e.length === r.length) { for (let t = 0; t < e.length; t++)if (e[t] !== r[t]) continue e; return !0 } } return !1 } function fs(e, t) { return e ? ":not(" + t.trim() + ")" : t } function ps(e) { let t = e[0], n = 1, r = 2, s = "", i = !1; for (; n < e.length;) { let o = e[n]; if ("string" == typeof o) if (2 & r) { const t = e[++n]; s += "[" + o + (t.length > 0 ? '="' + t + '"' : "") + "]" } else 8 & r ? s += "." + o : 4 & r && (s += " " + o); else "" === s || ls(o) || (t += fs(i, s), s = ""), r = o, i = i || !ls(r); n++ } return "" !== s && (t += fs(i, s)), t } const ms = {}; function gs(e) { ys(qe(), je(), pt() + e, Xe()) } function ys(e, t, n, r) { if (!r) if (3 == (3 & t[2])) { const r = e.preOrderCheckHooks; null !== r && vt(t, r, n) } else { const r = e.preOrderHooks; null !== r && wt(t, r, 0, n) } mt(n) } function vs(e, t) { return e << 17 | t << 2 } function ws(e) { return e >> 17 & 32767 } function bs(e) { return 2 | e } function _s(e) { return (131068 & e) >> 2 } function Es(e, t) { return -131069 & e | t << 2 } function Cs(e) { return 1 | e } function Ss(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const s = n[r], i = n[r + 1]; if (-1 !== i) { const n = e.data[i]; it(s), n.contentQueries(2, t[i], i) } } } function Ts(e, t, n, r, s, i, o, a, c, l) { const u = t.blueprint.slice(); return u[0] = s, u[2] = 140 | r, $e(u), u[3] = u[15] = e, u[8] = n, u[10] = o || e && e[10], u[11] = a || e && e[11], u[12] = c || e && e[12] || null, u[9] = l || e && e[9] || null, u[6] = i, u[16] = 2 == t.type ? e[16] : u, u } function Is(e, t, n, r, s) { let i = e.data[t]; if (null === i) i = function (e, t, n, r, s) { const i = Ge(), o = Ye(), a = e.data[t] = function (e, t, n, r, s, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: s, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? i : i && i.parent, n, t, r, s); return null === e.firstChild && (e.firstChild = a), null !== i && (o ? null == i.child && null !== a.parent && (i.child = a) : null === i.next && (i.next = a)), a }(e, t, n, r, s), Ve.lFrame.inI18n && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = s; const e = function () { const e = Ve.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === e ? -1 : e.injectorIndex } return We(i, !0), i } function ks(e, t, n, r) { if (0 === n) return -1; const s = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return s } function As(e, t, n) { ct(t); try { const r = e.viewQuery; null !== r && si(1, r, n); const s = e.template; null !== s && Os(e, t, s, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Ss(e, t), e.staticViewQueries && si(2, e.viewQuery, n); const i = e.components; null !== i && function (e, t) { for (let n = 0; n < t.length; n++)Js(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0), r } finally { t[2] &= -5, ft() } } function xs(e, t, n, r) { const s = t[2]; if (256 == (256 & s)) return; ct(t); const i = Xe(); try { $e(t), Ve.lFrame.bindingIndex = e.bindingStartIndex, null !== n && Os(e, t, n, 2, r); const o = 3 == (3 & s); if (!i) if (o) { const n = e.preOrderCheckHooks; null !== n && vt(t, n, null) } else { const n = e.preOrderHooks; null !== n && wt(t, n, 0, null), bt(t, 0) } if (function (e) { for (let t = Rr(e); null !== t; t = Nr(t)) { if (!t[2]) continue; const e = t[9]; for (let t = 0; t < e.length; t++) { const n = e[t], r = n[3]; 0 == (1024 & n[2]) && Be(r, 1), n[2] |= 1024 } } }(t), function (e) { for (let t = Rr(e); null !== t; t = Nr(t))for (let e = he; e < t.length; e++) { const n = t[e], r = n[1]; Le(n) && xs(r, n, r.template, n[8]) } }(t), null !== e.contentQueries && Ss(e, t), !i) if (o) { const n = e.contentCheckHooks; null !== n && vt(t, n) } else { const n = e.contentHooks; null !== n && wt(t, n, 1), bt(t, 1) } !function (e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let e = 0; e < n.length; e++) { const r = n[e]; if (r < 0) mt(~r); else { const s = r, i = n[++e], o = n[++e]; nt(i, s), o(2, t[s]) } } } finally { mt(-1) } }(e, t); const a = e.components; null !== a && function (e, t) { for (let n = 0; n < t.length; n++)Zs(e, t[n]) }(t, a); const c = e.viewQuery; if (null !== c && si(2, c, r), !i) if (o) { const n = e.viewCheckHooks; null !== n && vt(t, n) } else { const n = e.viewHooks; null !== n && wt(t, n, 2), bt(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), i || (t[2] &= -73), 1024 & t[2] && (t[2] &= -1025, Be(t[3], -1)) } finally { ft() } } function Ds(e, t, n, r) { const s = t[10], i = !Xe(), o = Fe(t); try { i && !o && s.begin && s.begin(), o && As(e, t, r), xs(e, t, n, r) } finally { i && !o && s.end && s.end() } } function Os(e, t, n, r, s) { const i = pt(), o = 2 & r; try { mt(-1), o && t.length > ue && ys(e, t, ue, Xe()), n(r, s) } finally { mt(i) } } function Rs(e, t, n) { if (pe(t)) { const r = t.directiveEnd; for (let s = t.directiveStart; s < r; s++) { const t = e.data[s]; t.contentQueries && t.contentQueries(1, n[s], s) } } } function Ns(e, t, n) { Ue() && (function (e, t, n, r) { const s = n.directiveStart, i = n.directiveEnd; e.firstCreatePass || Lt(n, t), Er(r, t); const o = n.initialInputs; for (let a = s; a < i; a++) { const r = e.data[a], i = ye(r); i && Ws(t, n, r); const c = Yt(t, e, a, n); Er(c, t), null !== o && Ys(0, a - s, c, r, 0, o), i && (Pe(n.index, t)[8] = c) } }(e, t, n, Oe(n, t)), 128 == (128 & n.flags) && function (e, t, n) { const r = n.directiveStart, s = n.directiveEnd, i = n.index, o = Ve.lFrame.currentDirectiveIndex; try { mt(i); for (let n = r; n < s; n++) { const r = e.data[n], s = t[n]; rt(n), null === r.hostBindings && 0 === r.hostVars && null === r.hostAttrs || js(r, s) } } finally { mt(-1), rt(o) } }(e, t, n)) } function Ps(e, t, n = Oe) { const r = t.localNames; if (null !== r) { let s = t.index + 1; for (let i = 0; i < r.length; i += 2) { const o = r[i + 1], a = -1 === o ? n(t, e) : e[o]; e[s++] = a } } } function Fs(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = Ls(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function Ls(e, t, n, r, s, i, o, a, c, l) { const u = ue + r, h = u + s, d = function (e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : ms); return n }(u, h), f = "function" == typeof l ? l() : l; return d[1] = { type: e, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: t, data: d.slice().fill(null, u), bindingStartIndex: u, expandoStartIndex: h, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: c, consts: f, incompleteFirstPass: !1 } } function Ms(e, t, n, r) { const s = oi(t); null === n ? s.push(r) : (s.push(n), e.firstCreatePass && ai(e).push(r, s.length - 1)) } function $s(e, t, n) { for (let r in e) if (e.hasOwnProperty(r)) { const s = e[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(t, s) : n[r] = [t, s] } return n } function Bs(e, t, n, r, s, i, o, a) { const c = Oe(t, n); let l, u = t.inputs; var h; !a && null != u && (l = u[r]) ? (li(e, n, l, r, s), me(t) && function (e, t) { const n = Pe(t, e); 16 & n[2] || (n[2] |= 64) }(n, t.index)) : 3 & t.type && (r = "class" === (h = r) ? "className" : "for" === h ? "htmlFor" : "formaction" === h ? "formAction" : "innerHtml" === h ? "innerHTML" : "readonly" === h ? "readOnly" : "tabindex" === h ? "tabIndex" : h, s = null != o ? o(s, t.value || "", r) : s, ke(i) ? i.setProperty(c, r, s) : kt(r) || (c.setProperty ? c.setProperty(r, s) : c[r] = s)) } function Vs(e, t, n, r) { let s = !1; if (Ue()) { const i = function (e, t, n) { const r = e.directiveRegistry; let s = null; if (r) for (let i = 0; i < r.length; i++) { const o = r[i]; hs(n, o.selectors, !1) && (s || (s = []), Vt(Lt(n, t), e, o.type), ye(o) ? (qs(e, n), s.unshift(o)) : s.push(o)) } return s }(e, t, n), o = null === r ? null : { "": -1 }; if (null !== i) { s = !0, Hs(n, e.data.length, i.length); for (let e = 0; e < i.length; e++) { const t = i[e]; t.providersResolver && t.providersResolver(t) } let r = !1, a = !1, c = ks(e, t, i.length, null); for (let s = 0; s < i.length; s++) { const l = i[s]; n.mergedAttrs = At(n.mergedAttrs, l.hostAttrs), Gs(e, n, t, c, l), zs(c, l, o), null !== l.contentQueries && (n.flags |= 8), null === l.hostBindings && null === l.hostAttrs && 0 === l.hostVars || (n.flags |= 128); const u = l.type.prototype; !r && (u.ngOnChanges || u.ngOnInit || u.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), r = !0), a || !u.ngOnChanges && !u.ngDoCheck || ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), a = !0), c++ } !function (e, t) { const n = t.directiveEnd, r = e.data, s = t.attrs, i = []; let o = null, a = null; for (let c = t.directiveStart; c < n; c++) { const e = r[c], n = e.inputs, l = null === s || os(t) ? null : Ks(n, s); i.push(l), o = $s(n, c, o), a = $s(e.outputs, c, a) } null !== o && (o.hasOwnProperty("class") && (t.flags |= 16), o.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = i, t.inputs = o, t.outputs = a }(e, n) } o && function (e, t, n) { if (t) { const r = e.localNames = []; for (let e = 0; e < t.length; e += 2) { const s = n[t[e + 1]]; if (null == s) throw new v("301", `Export of name '${t[e + 1]}' not found!`); r.push(t[e], s) } } }(n, r, o) } return n.mergedAttrs = At(n.mergedAttrs, n.attrs), s } function Us(e, t, n, r, s, i) { const o = i.hostBindings; if (o) { let n = e.hostBindingOpCodes; null === n && (n = e.hostBindingOpCodes = []); const i = ~t.index; (function (e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(n) != i && n.push(i), n.push(r, s, o) } } function js(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function qs(e, t) { t.flags |= 2, (e.components || (e.components = [])).push(t.index) } function zs(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; ye(t) && (n[""] = e) } } function Hs(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function Gs(e, t, n, r, s) { e.data[r] = s; const i = s.factory || (s.factory = ve(s.type)), o = new St(i, ye(s), null); e.blueprint[r] = o, n[r] = o, Us(e, t, 0, r, ks(e, n, s.hostVars, ms), s) } function Ws(e, t, n) { const r = Oe(t, e), s = Fs(n), i = e[10], o = ei(e, Ts(e, s, null, n.onPush ? 64 : 16, r, t, i, i.createRenderer(r, n), null, null)); e[t.index] = o } function Ys(e, t, n, r, s, i) { const o = i[t]; if (null !== o) { const e = r.setInput; for (let t = 0; t < o.length;) { const s = o[t++], i = o[t++], a = o[t++]; null !== e ? r.setInput(n, a, s, i) : n[i] = a } } } function Ks(e, t) { let n = null, r = 0; for (; r < t.length;) { const s = t[r]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; e.hasOwnProperty(s) && (null === n && (n = []), n.push(s, e[s], t[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function Xs(e, t, n, r) { return new Array(e, !0, !1, t, null, 0, r, n, null, null) } function Zs(e, t) { const n = Pe(t, e); if (Le(n)) { const e = n[1]; 80 & n[2] ? xs(e, n, e.template, n[8]) : n[5] > 0 && Qs(n) } } function Qs(e) { for (let n = Rr(e); null !== n; n = Nr(n))for (let e = he; e < n.length; e++) { const t = n[e]; if (1024 & t[2]) { const e = t[1]; xs(e, t, e.template, t[8]) } else t[5] > 0 && Qs(t) } const t = e[1].components; if (null !== t) for (let n = 0; n < t.length; n++) { const r = Pe(t[n], e); Le(r) && r[5] > 0 && Qs(r) } } function Js(e, t) { const n = Pe(t, e), r = n[1]; !function (e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) }(r, n), As(r, n, n[8]) } function ei(e, t) { return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t } function ti(e) { for (; e;) { e[2] |= 64; const t = Or(e); if (0 != (512 & e[2]) && !t) return e; e = t } return null } function ni(e, t, n) { const r = t[10]; r.begin && r.begin(); try { xs(e, t, e.template, n) } catch (s) { throw ci(t, s), s } finally { r.end && r.end() } } function ri(e) { !function (e) { for (let t = 0; t < e.components.length; t++) { const n = e.components[t], r = Cr(n), s = r[1]; Ds(s, r, s.template, n) } }(e[8]) } function si(e, t, n) { it(0), t(e, n) } const ii = (() => Promise.resolve(null))(); function oi(e) { return e[7] || (e[7] = []) } function ai(e) { return e.cleanup || (e.cleanup = []) } function ci(e, t) { const n = e[9], r = n ? n.get(Ir, null) : null; r && r.handleError(t) } function li(e, t, n, r, s) { for (let i = 0; i < n.length;) { const o = n[i++], a = n[i++], c = t[o], l = e.data[o]; null !== l.setInput ? l.setInput(c, s, r, a) : c[a] = s } } function ui(e, t, n) { let r = n ? e.styles : null, s = n ? e.classes : null, i = 0; if (null !== t) for (let o = 0; o < t.length; o++) { const e = t[o]; "number" == typeof e ? i = e : 1 == i ? s = f(s, e) : 2 == i && (r = f(r, e + ": " + t[++o] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = s : e.classesWithoutHost = s } const hi = new cn("INJECTOR", -1); class di { get(e, t = En) { if (t === En) { const t = new Error(`NullInjectorError: No provider for ${d(e)}!`); throw t.name = "NullInjectorError", t } return t } } const fi = new cn("Set Injector scope."), pi = {}, mi = {}; let gi; function yi() { return void 0 === gi && (gi = new di), gi } function vi(e, t = null, n = null, r) { return new wi(e, n, t || yi(), r) } class wi { constructor(e, t, n, r = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; t && mn(t, n => this.processProvider(n, e, t)), mn([e], e => this.processInjectorType(e, [], s)), this.records.set(hi, Ei(void 0, this)); const i = this.records.get(fi); this.scope = null != i ? i.value : null, this.source = r || ("object" == typeof e ? null : d(e)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(e => e.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(e, t = En, n = O.Default) { this.assertNotDestroyed(); const r = kn(this), s = N(void 0); try { if (!(n & O.SkipSelf)) { let t = this.records.get(e); if (void 0 === t) { const n = ("function" == typeof (i = e) || "object" == typeof i && i instanceof cn) && S(e); t = n && this.injectableDefInScope(n) ? Ei(bi(e), pi) : null, this.records.set(e, t) } if (null != t) return this.hydrate(e, t) } return (n & O.Self ? yi() : this.parent).get(e, t = n & O.Optional && t === En ? null : t) } catch (o) { if ("NullInjectorError" === o.name) { if ((o.ngTempTokenPath = o.ngTempTokenPath || []).unshift(d(e)), r) throw o; return function (e, t, n, r) { const s = e.ngTempTokenPath; throw t[Sn] && s.unshift(t[Sn]), e.message = function (e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.substr(2) : e; let s = d(t); if (Array.isArray(t)) s = t.map(d).join(" -> "); else if ("object" == typeof t) { let e = []; for (let n in t) if (t.hasOwnProperty(n)) { let r = t[n]; e.push(n + ":" + ("string" == typeof r ? JSON.stringify(r) : d(r))) } s = `{${e.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${s}]: ${e.replace(Cn, "\n  ")}` }("\n" + e.message, s, n, r), e.ngTokenPath = s, e.ngTempTokenPath = null, e }(o, e, "R3InjectorError", this.source) } throw o } finally { N(s), kn(r) } var i } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(e => this.get(e)) } toString() { const e = []; return this.records.forEach((t, n) => e.push(d(n))), `R3Injector[${e.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(e, t, n) { if (!(e = g(e))) return !1; let r = I(e); const s = null == r && e.ngModule || void 0, i = void 0 === s ? e : s, o = -1 !== n.indexOf(i); if (void 0 !== s && (r = I(s)), null == r) return !1; if (null != r.imports && !o) { let e; n.push(i); try { mn(r.imports, r => { this.processInjectorType(r, t, n) && (void 0 === e && (e = []), e.push(r)) }) } finally { } if (void 0 !== e) for (let t = 0; t < e.length; t++) { const { ngModule: n, providers: r } = e[t]; mn(r, e => this.processProvider(e, n, r || z)) } } this.injectorDefTypes.add(i); const a = ve(i) || (() => new i); this.records.set(i, Ei(a, pi)); const c = r.providers; if (null != c && !o) { const t = e; mn(c, e => this.processProvider(e, t, c)) } return void 0 !== s && void 0 !== e.providers } processProvider(e, t, n) { let r = Si(e = g(e)) ? e : g(e && e.provide); const s = function (e, t, n) { return Ci(e) ? Ei(void 0, e.useValue) : Ei(_i(e), pi) }(e); if (Si(e) || !0 !== e.multi) this.records.get(r); else { let t = this.records.get(r); t || (t = Ei(void 0, pi, !0), t.factory = () => Dn(t.multi), this.records.set(r, t)), r = e, t.multi.push(e) } this.records.set(r, s) } hydrate(e, t) { var n; return t.value === pi && (t.value = mi, t.value = t.factory()), "object" == typeof t.value && t.value && null !== (n = t.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(t.value), t.value } injectableDefInScope(e) { if (!e.providedIn) return !1; const t = g(e.providedIn); return "string" == typeof t ? "any" === t || t === this.scope : this.injectorDefTypes.has(t) } } function bi(e) { const t = S(e), n = null !== t ? t.factory : ve(e); if (null !== n) return n; if (e instanceof cn) throw new Error(`Token ${d(e)} is missing a \u0275prov definition.`); if (e instanceof Function) return function (e) { const t = e.length; if (t > 0) { const n = vn(t, "?"); throw new Error(`Can't resolve all parameters for ${d(e)}: (${n.join(", ")}).`) } const n = function (e) { const t = e && (e[k] || e[x]); if (t) { const n = function (e) { if (e.hasOwnProperty("name")) return e.name; const t = ("" + e).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(e); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t } return null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new Error("unreachable") } function _i(e, t, n) { let r; if (Si(e)) { const t = g(e); return ve(t) || bi(t) } if (Ci(e)) r = () => g(e.useValue); else if ((s = e) && s.useFactory) r = () => e.useFactory(...Dn(e.deps || [])); else if (function (e) { return !(!e || !e.useExisting) }(e)) r = () => xn(g(e.useExisting)); else { const t = g(e && (e.useClass || e.provide)); if (!function (e) { return !!e.deps }(e)) return ve(t) || bi(t); r = () => new t(...Dn(e.deps)) } var s; return r } function Ei(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function Ci(e) { return null !== e && "object" == typeof e && Tn in e } function Si(e) { return "function" == typeof e } const Ti = function (e, t, n) { return function (e, t = null, n = null, r) { const s = vi(e, t, n, r); return s._resolveInjectorDefTypes(), s }({ name: n }, t, e, n) }; class Ii { static create(e, t) { return Array.isArray(e) ? Ti(e, t, "") : Ti(e.providers, e.parent, e.name || "") } } function ki(e, t) { yt(Cr(e)[1], He()) } function Ai(e) { let t = Object.getPrototypeOf(e.type.prototype).constructor, n = !0; const r = [e]; for (; t;) { let s; if (ye(e)) s = t.\u0275cmp || t.\u0275dir; else { if (t.\u0275cmp) throw new Error("Directives cannot inherit Components"); s = t.\u0275dir } if (s) { if (n) { r.push(s); const t = e; t.inputs = xi(e.inputs), t.declaredInputs = xi(e.declaredInputs), t.outputs = xi(e.outputs); const n = s.hostBindings; n && Ri(e, n); const i = s.viewQuery, o = s.contentQueries; if (i && Di(e, i), o && Oi(e, o), h(e.inputs, s.inputs), h(e.declaredInputs, s.declaredInputs), h(e.outputs, s.outputs), ye(s) && s.data.animation) { const t = e.data; t.animation = (t.animation || []).concat(s.data.animation) } } const t = s.features; if (t) for (let r = 0; r < t.length; r++) { const s = t[r]; s && s.ngInherit && s(e), s === Ai && (n = !1) } } t = Object.getPrototypeOf(t) } !function (e) { let t = 0, n = null; for (let r = e.length - 1; r >= 0; r--) { const s = e[r]; s.hostVars = t += s.hostVars, s.hostAttrs = At(s.hostAttrs, n = At(n, s.hostAttrs)) } }(r) } function xi(e) { return e === q ? {} : e === z ? [] : e } function Di(e, t) { const n = e.viewQuery; e.viewQuery = n ? (e, r) => { t(e, r), n(e, r) } : t } function Oi(e, t) { const n = e.contentQueries; e.contentQueries = n ? (e, r, s) => { t(e, r, s), n(e, r, s) } : t } function Ri(e, t) { const n = e.hostBindings; e.hostBindings = n ? (e, r) => { t(e, r), n(e, r) } : t } Ii.THROW_IF_NOT_FOUND = En, Ii.NULL = new di, Ii.\u0275prov = E({ token: Ii, providedIn: "any", factory: () => xn(hi) }), Ii.__NG_ELEMENT_ID__ = -1; let Ni = null; function Pi() { if (!Ni) { const e = j.Symbol; if (e && e.iterator) Ni = e.iterator; else { const e = Object.getOwnPropertyNames(Map.prototype); for (let t = 0; t < e.length; ++t) { const n = e[t]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (Ni = n) } } } return Ni } class Fi { constructor(e) { this.wrapped = e } static wrap(e) { return new Fi(e) } static unwrap(e) { return Fi.isWrapped(e) ? e.wrapped : e } static isWrapped(e) { return e instanceof Fi } } function Li(e) { return !!Mi(e) && (Array.isArray(e) || !(e instanceof Map) && Pi() in e) } function Mi(e) { return null !== e && ("function" == typeof e || "object" == typeof e) } function $i(e, t, n) { return e[t] = n } function Bi(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Vi(e, t, n, r) { const s = Bi(e, t, n); return Bi(e, t + 1, r) || s } function Ui(e, t, n, r) { const s = je(); return Bi(s, et(), t) && (qe(), function (e, t, n, r, s, i) { const o = Oe(e, t); !function (e, t, n, r, s, i, o) { if (null == i) ke(e) ? e.removeAttribute(t, s, n) : t.removeAttribute(s); else { const a = null == o ? w(i) : o(i, r || "", s); ke(e) ? e.setAttribute(t, s, a, n) : n ? t.setAttributeNS(n, s, a) : t.setAttribute(s, a) } }(t[11], o, i, e.value, n, r, s) }(gt(), s, e, t, n, r)), Ui } function ji(e, t, n, r) { return Bi(e, et(), n) ? t + w(n) + r : ms } function qi(e, t, n, r, s, i, o, a) { const c = je(), l = qe(), u = e + ue, h = l.firstCreatePass ? function (e, t, n, r, s, i, o, a, c) { const l = t.consts, u = Is(t, e, 4, o || null, Me(l, a)); Vs(t, n, u, Me(l, c)), yt(t, u); const h = u.tViews = Ls(2, u, r, s, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, l); return null !== t.queries && (t.queries.template(t, u), h.queries = t.queries.embeddedTView(u)), u }(u, l, c, t, n, r, s, i, o) : l.data[u]; We(h, !1); const d = c[11].createComment(""); Yr(l, c, d, h), Er(d, c), ei(c, c[u] = Xs(d, c, d, h)), ge(h) && Ns(l, c, h), null != o && Ps(c, h, a) } function zi(e, t = O.Default) { const n = je(); return null === n ? xn(e, t) : qt(He(), n, g(e), t) } function Hi() { throw new Error("invalid") } function Gi(e, t, n) { const r = je(); return Bi(r, et(), t) && Bs(qe(), gt(), r, e, t, r[11], n, !1), Gi } function Wi(e, t, n, r, s) { const i = s ? "class" : "style"; li(e, n, t.inputs[i], i, r) } function Yi(e, t, n, r) { const s = je(), i = qe(), o = ue + e, a = s[11], c = s[o] = Lr(a, t, Ve.lFrame.currentNamespace), l = i.firstCreatePass ? function (e, t, n, r, s, i, o) { const a = t.consts, c = Is(t, e, 2, s, Me(a, i)); return Vs(t, n, c, Me(a, o)), null !== c.attrs && ui(c, c.attrs, !1), null !== c.mergedAttrs && ui(c, c.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, c), c }(o, i, s, 0, t, n, r) : i.data[o]; We(l, !0); const u = l.mergedAttrs; null !== u && Tt(a, c, u); const h = l.classes; null !== h && ns(a, c, h); const d = l.styles; null !== d && ts(a, c, d), 64 != (64 & l.flags) && Yr(i, s, c, l), 0 === Ve.lFrame.elementDepthCount && Er(c, s), Ve.lFrame.elementDepthCount++, ge(l) && (Ns(i, s, l), Rs(i, l, s)), null !== r && Ps(s, l) } function Ki() { let e = He(); Ye() ? Ke() : (e = e.parent, We(e, !1)); const t = e; Ve.lFrame.elementDepthCount--; const n = qe(); n.firstCreatePass && (yt(n, e), pe(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function (e) { return 0 != (16 & e.flags) }(t) && Wi(n, t, je(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function (e) { return 0 != (32 & e.flags) }(t) && Wi(n, t, je(), t.stylesWithoutHost, !1) } function Xi(e, t, n, r) { Yi(e, t, n, r), Ki() } function Zi(e, t, n) { (function (e, t, n) { const r = je(), s = qe(), i = e + ue, o = s.firstCreatePass ? function (e, t, n, r, s) { const i = t.consts, o = Me(i, r), a = Is(t, e, 8, "ng-container", o); return null !== o && ui(a, o, !0), Vs(t, n, a, Me(i, s)), null !== t.queries && t.queries.elementStart(t, a), a }(i, s, r, t, n) : s.data[i]; We(o, !0); const a = r[i] = r[11].createComment(""); Yr(s, r, a, o), Er(a, r), ge(o) && (Ns(s, r, o), Rs(s, o, r)), null != n && Ps(r, o) })(e, t, n), function () { let e = He(); const t = qe(); Ye() ? Ke() : (e = e.parent, We(e, !1)), t.firstCreatePass && (yt(t, e), pe(e) && t.queries.elementEnd(e)) }() } function Qi() { return je() } function Ji(e) { return !!e && "function" == typeof e.then } function eo(e) { return !!e && "function" == typeof e.subscribe } const to = eo; function no(e, t, n, r) { const s = je(), i = qe(), o = He(); return function (e, t, n, r, s, i, o, a) { const c = ge(r), l = e.firstCreatePass && ai(e), u = oi(t); let h = !0; if (3 & r.type || a) { const d = Oe(r, t), f = a ? a(d) : d, p = u.length, m = a ? e => a(xe(e[r.index])) : r.index; if (ke(n)) { let o = null; if (!a && c && (o = function (e, t, n, r) { const s = e.cleanup; if (null != s) for (let i = 0; i < s.length - 1; i += 2) { const e = s[i]; if (e === n && s[i + 1] === r) { const e = t[7], n = s[i + 2]; return e.length > n ? e[n] : null } "string" == typeof e && (i += 2) } return null }(e, t, s, r.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = i, o.__ngLastListenerFn__ = i, h = !1; else { i = so(r, t, 0, i, !1); const e = n.listen(f, s, i); u.push(i, e), l && l.push(s, m, p, p + 1) } } else i = so(r, t, 0, i, !0), f.addEventListener(s, i, o), u.push(i), l && l.push(s, m, p, o) } else i = so(r, t, 0, i, !1); const d = r.outputs; let f; if (h && null !== d && (f = d[s])) { const e = f.length; if (e) for (let n = 0; n < e; n += 2) { const e = t[f[n]][f[n + 1]].subscribe(i), o = u.length; u.push(i, e), l && l.push(s, r.index, o, -(o + 1)) } } }(i, s, s[11], o, e, t, !!n, r), no } function ro(e, t, n, r) { try { return !1 !== n(r) } catch (s) { return ci(e, s), !1 } } function so(e, t, n, r, s) { return function n(i) { if (i === Function) return r; const o = 2 & e.flags ? Pe(e.index, t) : t; 0 == (32 & t[2]) && ti(o); let a = ro(t, 0, r, i), c = n.__ngNextListenerFn__; for (; c;)a = ro(t, 0, c, i) && a, c = c.__ngNextListenerFn__; return s && !1 === a && (i.preventDefault(), i.returnValue = !1), a } } function io(e = 1) { return function (e) { return (Ve.lFrame.contextLView = function (e, t) { for (; e > 0;)t = t[15], e--; return t }(e, Ve.lFrame.contextLView))[8] }(e) } function oo(e, t) { let n = null; const r = function (e) { const t = e.attrs; if (null != t) { const e = t.indexOf(5); if (0 == (1 & e)) return t[e + 1] } return null }(e); for (let s = 0; s < t.length; s++) { const i = t[s]; if ("*" !== i) { if (null === r ? hs(e, i, !0) : ds(r, i)) return s } else n = s } return n } function ao(e) { const t = je()[16][6]; if (!t.projection) { const n = t.projection = vn(e ? e.length : 1, null), r = n.slice(); let s = t.child; for (; null !== s;) { const t = e ? oo(s, e) : 0; null !== t && (r[t] ? r[t].projectionNext = s : n[t] = s, r[t] = s), s = s.next } } } function co(e, t = 0, n) { const r = je(), s = qe(), i = Is(s, ue + e, 16, null, n || null); null === i.projection && (i.projection = t), Ke(), 64 != (64 & i.flags) && function (e, t, n) { es(t[11], 0, t, n, Ur(e, n, t), Gr(n.parent || t[6], n, t)) }(s, r, i) } function lo(e, t, n) { return uo(e, "", t, "", n), lo } function uo(e, t, n, r, s) { const i = je(), o = ji(i, t, n, r); return o !== ms && Bs(qe(), gt(), i, e, o, i[11], s, !1), uo } function ho(e, t, n, r, s, i, o) { const a = je(), c = function (e, t, n, r, s, i) { const o = Vi(e, Je(), n, s); return tt(2), o ? t + w(n) + r + w(s) + i : ms }(a, t, n, r, s, i); return c !== ms && Bs(qe(), gt(), a, e, c, a[11], o, !1), ho } function fo(e, t, n, r, s, i, o, a, c, l, u) { const h = je(), d = function (e, t, n, r, s, i, o, a, c, l) { const u = function (e, t, n, r, s, i) { const o = Vi(e, t, n, r); return Vi(e, t + 2, s, i) || o }(e, Je(), n, s, o, c); return tt(4), u ? t + w(n) + r + w(s) + i + w(o) + a + w(c) + l : ms }(h, t, n, r, s, i, o, a, c, l); return d !== ms && Bs(qe(), gt(), h, e, d, h[11], u, !1), fo } function po(e, t, n, r, s) { const i = e[n + 1], o = null === t; let a = r ? ws(i) : _s(i), c = !1; for (; 0 !== a && (!1 === c || o);) { const n = e[a + 1]; mo(e[a], t) && (c = !0, e[a + 1] = r ? Cs(n) : bs(n)), a = r ? ws(n) : _s(n) } c && (e[n + 1] = r ? bs(i) : Cs(i)) } function mo(e, t) { return null === e || null == t || (Array.isArray(e) ? e[1] : e) === t || !(!Array.isArray(e) || "string" != typeof t) && _n(e, t) >= 0 } function go(e, t, n) { return vo(e, t, n, !1), go } function yo(e, t) { return vo(e, t, null, !0), yo } function vo(e, t, n, r) { const s = je(), i = qe(), o = tt(2); i.firstUpdatePass && function (e, t, n, r) { const s = e.data; if (null === s[n + 1]) { const i = s[pt()], o = function (e, t) { return t >= e.expandoStartIndex }(e, n); (function (e, t) { return 0 != (e.flags & (t ? 16 : 32)) })(i, r) && null === t && !o && (t = !1), t = function (e, t, n, r) { const s = function (e) { const t = Ve.lFrame.currentDirectiveIndex; return -1 === t ? null : e[t] }(e); let i = r ? t.residualClasses : t.residualStyles; if (null === s) 0 === (r ? t.classBindings : t.styleBindings) && (n = bo(n = wo(null, e, t, n, r), t.attrs, r), i = null); else { const o = t.directiveStylingLast; if (-1 === o || e[o] !== s) if (n = wo(s, e, t, n, r), null === i) { let n = function (e, t, n) { const r = n ? t.classBindings : t.styleBindings; if (0 !== _s(r)) return e[ws(r)] }(e, t, r); void 0 !== n && Array.isArray(n) && (n = wo(null, e, t, n[1], r), n = bo(n, t.attrs, r), function (e, t, n, r) { e[ws(n ? t.classBindings : t.styleBindings)] = r }(e, t, r, n)) } else i = function (e, t, n) { let r; const s = t.directiveEnd; for (let i = 1 + t.directiveStylingLast; i < s; i++)r = bo(r, e[i].hostAttrs, n); return bo(r, t.attrs, n) }(e, t, r) } return void 0 !== i && (r ? t.residualClasses = i : t.residualStyles = i), n }(s, i, t, r), function (e, t, n, r, s, i) { let o = i ? t.classBindings : t.styleBindings, a = ws(o), c = _s(o); e[r] = n; let l, u = !1; if (Array.isArray(n)) { const e = n; l = e[1], (null === l || _n(e, l) > 0) && (u = !0) } else l = n; if (s) if (0 !== c) { const t = ws(e[a + 1]); e[r + 1] = vs(t, a), 0 !== t && (e[t + 1] = Es(e[t + 1], r)), e[a + 1] = 131071 & e[a + 1] | r << 17 } else e[r + 1] = vs(a, 0), 0 !== a && (e[a + 1] = Es(e[a + 1], r)), a = r; else e[r + 1] = vs(c, 0), 0 === a ? a = r : e[c + 1] = Es(e[c + 1], r), c = r; u && (e[r + 1] = bs(e[r + 1])), po(e, l, r, !0), po(e, l, r, !1), function (e, t, n, r, s) { const i = s ? e.residualClasses : e.residualStyles; null != i && "string" == typeof t && _n(i, t) >= 0 && (n[r + 1] = Cs(n[r + 1])) }(t, l, e, r, i), o = vs(a, c), i ? t.classBindings = o : t.styleBindings = o }(s, i, t, n, o, r) } }(i, e, o, r), t !== ms && Bi(s, o, t) && function (e, t, n, r, s, i, o, a) { if (!(3 & t.type)) return; const c = e.data, l = c[a + 1]; Eo(1 == (1 & l) ? _o(c, t, n, s, _s(l), o) : void 0) || (Eo(i) || function (e) { return 2 == (2 & e) }(l) && (i = _o(c, null, n, s, a, o)), function (e, t, n, r, s) { const i = ke(e); if (t) s ? i ? e.addClass(n, r) : n.classList.add(r) : i ? e.removeClass(n, r) : n.classList.remove(r); else { let t = -1 === r.indexOf("-") ? void 0 : xr.DashCase; if (null == s) i ? e.removeStyle(n, r, t) : n.style.removeProperty(r); else { const o = "string" == typeof s && s.endsWith("!important"); o && (s = s.slice(0, -10), t |= xr.Important), i ? e.setStyle(n, r, s, t) : n.style.setProperty(r, s, o ? "important" : "") } } }(r, o, De(pt(), n), s, i)) }(i, i.data[pt()], s, s[11], e, s[o + 1] = function (e, t) { return null == e || ("string" == typeof t ? e += t : "object" == typeof e && (e = d(qn(e)))), e }(t, n), r, o) } function wo(e, t, n, r, s) { let i = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (i = t[a], r = bo(r, i.hostAttrs, s), i !== e);)a++; return null !== e && (n.directiveStylingLast = a), r } function bo(e, t, n) { const r = n ? 1 : 2; let s = -1; if (null !== t) for (let i = 0; i < t.length; i++) { const o = t[i]; "number" == typeof o ? s = o : s === r && (Array.isArray(e) || (e = void 0 === e ? [] : ["", e]), wn(e, o, !!n || t[++i])) } return void 0 === e ? null : e } function _o(e, t, n, r, s, i) { const o = null === t; let a; for (; s > 0;) { const t = e[s], i = Array.isArray(t), c = i ? t[1] : t, l = null === c; let u = n[s + 1]; u === ms && (u = l ? z : void 0); let h = l ? bn(u, r) : c === r ? u : void 0; if (i && !Eo(h) && (h = bn(t, r)), Eo(h) && (a = h, o)) return a; const d = e[s + 1]; s = o ? ws(d) : _s(d) } if (null !== t) { let e = i ? t.residualClasses : t.residualStyles; null != e && (a = bn(e, r)) } return a } function Eo(e) { return void 0 !== e } function Co(e, t = "") { const n = je(), r = qe(), s = e + ue, i = r.firstCreatePass ? Is(r, s, 1, t, null) : r.data[s], o = n[s] = function (e, t) { return ke(e) ? e.createText(t) : e.createTextNode(t) }(n[11], t); Yr(r, n, o, i), We(i, !1) } function So(e) { return To("", e, ""), So } function To(e, t, n) { const r = je(), s = ji(r, e, t, n); return s !== ms && function (e, t, n) { const r = De(t, e); !function (e, t, n) { ke(e) ? e.setValue(t, n) : t.textContent = n }(e[11], r, n) }(r, pt(), s), To } function Io(e, t, n) { const r = je(); return Bi(r, et(), t) && Bs(qe(), gt(), r, e, t, r[11], n, !0), Io } const ko = void 0; var Ao = ["en", [["a", "p"], ["AM", "PM"], ko], [["AM", "PM"], ko, ko], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], ko, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], ko, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", ko, "{1} 'at' {0}", ko], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (e) { let t = Math.floor(Math.abs(e)), n = e.toString().replace(/^[^.]*\.?/, "").length; return 1 === t && 0 === n ? 1 : 5 }]; let xo = {}; function Do(e) { const t = function (e) { return e.toLowerCase().replace(/_/g, "-") }(e); let n = Ro(t); if (n) return n; const r = t.split("-")[0]; if (n = Ro(r), n) return n; if ("en" === r) return Ao; throw new Error(`Missing locale data for the locale "${e}".`) } function Oo(e) { return Do(e)[No.PluralCase] } function Ro(e) { return e in xo || (xo[e] = j.ng && j.ng.common && j.ng.common.locales && j.ng.common.locales[e]), xo[e] } var No = (() => ((No = No || {})[No.LocaleId = 0] = "LocaleId", No[No.DayPeriodsFormat = 1] = "DayPeriodsFormat", No[No.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", No[No.DaysFormat = 3] = "DaysFormat", No[No.DaysStandalone = 4] = "DaysStandalone", No[No.MonthsFormat = 5] = "MonthsFormat", No[No.MonthsStandalone = 6] = "MonthsStandalone", No[No.Eras = 7] = "Eras", No[No.FirstDayOfWeek = 8] = "FirstDayOfWeek", No[No.WeekendRange = 9] = "WeekendRange", No[No.DateFormat = 10] = "DateFormat", No[No.TimeFormat = 11] = "TimeFormat", No[No.DateTimeFormat = 12] = "DateTimeFormat", No[No.NumberSymbols = 13] = "NumberSymbols", No[No.NumberFormats = 14] = "NumberFormats", No[No.CurrencyCode = 15] = "CurrencyCode", No[No.CurrencySymbol = 16] = "CurrencySymbol", No[No.CurrencyName = 17] = "CurrencyName", No[No.Currencies = 18] = "Currencies", No[No.Directionality = 19] = "Directionality", No[No.PluralCase = 20] = "PluralCase", No[No.ExtraData = 21] = "ExtraData", No))(); const Po = "en-US"; let Fo = Po; function Lo(e) { var t, n; n = "Expected localeId to be defined", null == (t = e) && function (e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e} [Expected=> null != ${t} <=Actual]`) }(n, t), "string" == typeof e && (Fo = e.toLowerCase().replace(/_/g, "-")) } function Mo(e, t, n, r, s) { if (e = g(e), Array.isArray(e)) for (let i = 0; i < e.length; i++)Mo(e[i], t, n, r, s); else { const i = qe(), o = je(); let a = Si(e) ? e : g(e.provide), c = _i(e); const l = He(), u = 1048575 & l.providerIndexes, h = l.directiveStart, d = l.providerIndexes >> 20; if (Si(e) || !e.multi) { const r = new St(c, s, zi), f = Vo(a, t, s ? u : u + d, h); -1 === f ? (Vt(Lt(l, o), i, a), $o(i, e, t.length), t.push(a), l.directiveStart++, l.directiveEnd++, s && (l.providerIndexes += 1048576), n.push(r), o.push(r)) : (n[f] = r, o[f] = r) } else { const f = Vo(a, t, u + d, h), p = Vo(a, t, u, u + d), m = f >= 0 && n[f], g = p >= 0 && n[p]; if (s && !g || !s && !m) { Vt(Lt(l, o), i, a); const u = function (e, t, n, r, s) { const i = new St(e, n, zi); return i.multi = [], i.index = t, i.componentProviders = 0, Bo(i, s, r && !n), i }(s ? jo : Uo, n.length, s, r, c); !s && g && (n[p].providerFactory = u), $o(i, e, t.length, 0), t.push(a), l.directiveStart++, l.directiveEnd++, s && (l.providerIndexes += 1048576), n.push(u), o.push(u) } else $o(i, e, f > -1 ? f : p, Bo(n[s ? p : f], c, !s && r)); !s && r && g && n[p].componentProviders++ } } } function $o(e, t, n, r) { const s = Si(t); if (s || t.useClass) { const i = (t.useClass || t).prototype.ngOnDestroy; if (i) { const o = e.destroyHooks || (e.destroyHooks = []); if (!s && t.multi) { const e = o.indexOf(n); -1 === e ? o.push(n, [r, i]) : o[e + 1].push(r, i) } else o.push(n, i) } } } function Bo(e, t, n) { return n && e.componentProviders++, e.multi.push(t) - 1 } function Vo(e, t, n, r) { for (let s = n; s < r; s++)if (t[s] === e) return s; return -1 } function Uo(e, t, n, r) { return qo(this.multi, []) } function jo(e, t, n, r) { const s = this.multi; let i; if (this.providerFactory) { const e = this.providerFactory.componentProviders, t = Yt(n, n[1], this.providerFactory.index, r); i = t.slice(0, e), qo(s, i); for (let n = e; n < t.length; n++)i.push(t[n]) } else i = [], qo(s, i); return i } function qo(e, t) { for (let n = 0; n < e.length; n++)t.push((0, e[n])()); return t } function zo(e, t = []) { return n => { n.providersResolver = (n, r) => function (e, t, n) { const r = qe(); if (r.firstCreatePass) { const s = ye(e); Mo(n, r.data, r.blueprint, s, !0), Mo(t, r.data, r.blueprint, s, !1) } }(n, r ? r(e) : e, t) } } class Ho { } class Go { resolveComponentFactory(e) { throw function (e) { const t = Error(`No component factory found for ${d(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(e) } } class Wo { } function Yo(...e) { } function Ko(e, t) { return new Zo(Oe(e, t)) } Wo.NULL = new Go; const Xo = function () { return Ko(He(), je()) }; let Zo = (() => { class e { constructor(e) { this.nativeElement = e } } return e.__NG_ELEMENT_ID__ = Xo, e })(); function Qo(e) { return e instanceof Zo ? e.nativeElement : e } class Jo { } let ea = (() => { class e { } return e.__NG_ELEMENT_ID__ = () => ta(), e })(); const ta = function () { const e = je(), t = Pe(He().index, e); return function (e) { return e[11] }(de(t) ? t : e) }; let na = (() => { class e { } return e.\u0275prov = E({ token: e, providedIn: "root", factory: () => null }), e })(); class ra { constructor(e) { this.full = e, this.major = e.split(".")[0], this.minor = e.split(".")[1], this.patch = e.split(".").slice(2).join(".") } } const sa = new ra("12.1.5"); class ia { constructor() { } supports(e) { return Li(e) } create(e) { return new aa(e) } } const oa = (e, t) => t; class aa { constructor(e) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = e || oa } forEachItem(e) { let t; for (t = this._itHead; null !== t; t = t._next)e(t) } forEachOperation(e) { let t = this._itHead, n = this._removalsHead, r = 0, s = null; for (; t || n;) { const i = !n || t && t.currentIndex < ha(n, r, s) ? t : n, o = ha(i, r, s), a = i.currentIndex; if (i === n) r--, n = n._nextRemoved; else if (t = t._next, null == i.previousIndex) r++; else { s || (s = []); const e = o - r, t = a - r; if (e != t) { for (let n = 0; n < e; n++) { const r = n < s.length ? s[n] : s[n] = 0, i = r + n; t <= i && i < e && (s[n] = r + 1) } s[i.previousIndex] = t - e } } o !== a && e(i, o, a) } } forEachPreviousItem(e) { let t; for (t = this._previousItHead; null !== t; t = t._nextPrevious)e(t) } forEachAddedItem(e) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)e(t) } forEachMovedItem(e) { let t; for (t = this._movesHead; null !== t; t = t._nextMoved)e(t) } forEachRemovedItem(e) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)e(t) } forEachIdentityChange(e) { let t; for (t = this._identityChangesHead; null !== t; t = t._nextIdentityChange)e(t) } diff(e) { if (null == e && (e = []), !Li(e)) throw new Error(`Error trying to diff '${d(e)}'. Only arrays and iterables are allowed`); return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let t, n, r, s = this._itHead, i = !1; if (Array.isArray(e)) { this.length = e.length; for (let t = 0; t < this.length; t++)n = e[t], r = this._trackByFn(t, n), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, n, r, t)), Object.is(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, r, t), i = !0), s = s._next } else t = 0, function (e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[Pi()](); let r; for (; !(r = n.next()).done;)t(r.value) } }(e, e => { r = this._trackByFn(t, e), null !== s && Object.is(s.trackById, r) ? (i && (s = this._verifyReinsertion(s, e, r, t)), Object.is(s.item, e) || this._addIdentityChange(s, e)) : (s = this._mismatch(s, e, r, t), i = !0), s = s._next, t++ }), this.length = t; return this._truncate(s), this.collection = e, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let e; for (e = this._previousItHead = this._itHead; null !== e; e = e._next)e._nextPrevious = e._next; for (e = this._additionsHead; null !== e; e = e._nextAdded)e.previousIndex = e.currentIndex; for (this._additionsHead = this._additionsTail = null, e = this._movesHead; null !== e; e = e._nextMoved)e.previousIndex = e.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(e, t, n, r) { let s; return null === e ? s = this._itTail : (s = e._prev, this._remove(e)), null !== (e = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(e.item, t) || this._addIdentityChange(e, t), this._reinsertAfter(e, s, r)) : null !== (e = null === this._linkedRecords ? null : this._linkedRecords.get(n, r)) ? (Object.is(e.item, t) || this._addIdentityChange(e, t), this._moveAfter(e, s, r)) : e = this._addAfter(new ca(t, n), s, r), e } _verifyReinsertion(e, t, n, r) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? e = this._reinsertAfter(s, e._prev, r) : e.currentIndex != r && (e.currentIndex = r, this._addToMoves(e, r)), e } _truncate(e) { for (; null !== e;) { const t = e._next; this._addToRemovals(this._unlink(e)), e = t } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(e, t, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(e); const r = e._prevRemoved, s = e._nextRemoved; return null === r ? this._removalsHead = s : r._nextRemoved = s, null === s ? this._removalsTail = r : s._prevRemoved = r, this._insertAfter(e, t, n), this._addToMoves(e, n), e } _moveAfter(e, t, n) { return this._unlink(e), this._insertAfter(e, t, n), this._addToMoves(e, n), e } _addAfter(e, t, n) { return this._insertAfter(e, t, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = e : this._additionsTail._nextAdded = e, e } _insertAfter(e, t, n) { const r = null === t ? this._itHead : t._next; return e._next = r, e._prev = t, null === r ? this._itTail = e : r._prev = e, null === t ? this._itHead = e : t._next = e, null === this._linkedRecords && (this._linkedRecords = new ua), this._linkedRecords.put(e), e.currentIndex = n, e } _remove(e) { return this._addToRemovals(this._unlink(e)) } _unlink(e) { null !== this._linkedRecords && this._linkedRecords.remove(e); const t = e._prev, n = e._next; return null === t ? this._itHead = n : t._next = n, null === n ? this._itTail = t : n._prev = t, e } _addToMoves(e, t) { return e.previousIndex === t || (this._movesTail = null === this._movesTail ? this._movesHead = e : this._movesTail._nextMoved = e), e } _addToRemovals(e) { return null === this._unlinkedRecords && (this._unlinkedRecords = new ua), this._unlinkedRecords.put(e), e.currentIndex = null, e._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = e, e._prevRemoved = null) : (e._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = e), e } _addIdentityChange(e, t) { return e.item = t, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = e : this._identityChangesTail._nextIdentityChange = e, e } } class ca { constructor(e, t) { this.item = e, this.trackById = t, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class la { constructor() { this._head = null, this._tail = null } add(e) { null === this._head ? (this._head = this._tail = e, e._nextDup = null, e._prevDup = null) : (this._tail._nextDup = e, e._prevDup = this._tail, e._nextDup = null, this._tail = e) } get(e, t) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === t || t <= n.currentIndex) && Object.is(n.trackById, e)) return n; return null } remove(e) { const t = e._prevDup, n = e._nextDup; return null === t ? this._head = n : t._nextDup = n, null === n ? this._tail = t : n._prevDup = t, null === this._head } } class ua { constructor() { this.map = new Map } put(e) { const t = e.trackById; let n = this.map.get(t); n || (n = new la, this.map.set(t, n)), n.add(e) } get(e, t) { const n = this.map.get(e); return n ? n.get(e, t) : null } remove(e) { const t = e.trackById; return this.map.get(t).remove(e) && this.map.delete(t), e } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function ha(e, t, n) { const r = e.previousIndex; if (null === r) return r; let s = 0; return n && r < n.length && (s = n[r]), r + t + s } class da { constructor() { } supports(e) { return e instanceof Map || Mi(e) } create() { return new fa } } class fa { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(e) { let t; for (t = this._mapHead; null !== t; t = t._next)e(t) } forEachPreviousItem(e) { let t; for (t = this._previousMapHead; null !== t; t = t._nextPrevious)e(t) } forEachChangedItem(e) { let t; for (t = this._changesHead; null !== t; t = t._nextChanged)e(t) } forEachAddedItem(e) { let t; for (t = this._additionsHead; null !== t; t = t._nextAdded)e(t) } forEachRemovedItem(e) { let t; for (t = this._removalsHead; null !== t; t = t._nextRemoved)e(t) } diff(e) { if (e) { if (!(e instanceof Map || Mi(e))) throw new Error(`Error trying to diff '${d(e)}'. Only maps and objects are allowed`) } else e = new Map; return this.check(e) ? this : null } onDestroy() { } check(e) { this._reset(); let t = this._mapHead; if (this._appendAfter = null, this._forEach(e, (e, n) => { if (t && t.key === n) this._maybeAddToChanges(t, e), this._appendAfter = t, t = t._next; else { const r = this._getOrCreateRecordForKey(n, e); t = this._insertBeforeOrAppend(t, r) } }), t) { t._prev && (t._prev._next = null), this._removalsHead = t; for (let e = t; null !== e; e = e._nextRemoved)e === this._mapHead && (this._mapHead = null), this._records.delete(e.key), e._nextRemoved = e._next, e.previousValue = e.currentValue, e.currentValue = null, e._prev = null, e._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(e, t) { if (e) { const n = e._prev; return t._next = e, t._prev = n, e._prev = t, n && (n._next = t), e === this._mapHead && (this._mapHead = t), this._appendAfter = e, e } return this._appendAfter ? (this._appendAfter._next = t, t._prev = this._appendAfter) : this._mapHead = t, this._appendAfter = t, null } _getOrCreateRecordForKey(e, t) { if (this._records.has(e)) { const n = this._records.get(e); this._maybeAddToChanges(n, t); const r = n._prev, s = n._next; return r && (r._next = s), s && (s._prev = r), n._next = null, n._prev = null, n } const n = new pa(e); return this._records.set(e, n), n.currentValue = t, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let e; for (this._previousMapHead = this._mapHead, e = this._previousMapHead; null !== e; e = e._next)e._nextPrevious = e._next; for (e = this._changesHead; null !== e; e = e._nextChanged)e.previousValue = e.currentValue; for (e = this._additionsHead; null != e; e = e._nextAdded)e.previousValue = e.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(e, t) { Object.is(t, e.currentValue) || (e.previousValue = e.currentValue, e.currentValue = t, this._addToChanges(e)) } _addToAdditions(e) { null === this._additionsHead ? this._additionsHead = this._additionsTail = e : (this._additionsTail._nextAdded = e, this._additionsTail = e) } _addToChanges(e) { null === this._changesHead ? this._changesHead = this._changesTail = e : (this._changesTail._nextChanged = e, this._changesTail = e) } _forEach(e, t) { e instanceof Map ? e.forEach(t) : Object.keys(e).forEach(n => t(e[n], n)) } } class pa { constructor(e) { this.key = e, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function ma() { return new ga([new ia]) } let ga = (() => { class e { constructor(e) { this.factories = e } static create(t, n) { if (null != n) { const e = n.factories.slice(); t = t.concat(e) } return new e(t) } static extend(t) { return { provide: e, useFactory: n => e.create(t, n || ma()), deps: [[e, new Pn, new Nn]] } } find(e) { const t = this.factories.find(t => t.supports(e)); if (null != t) return t; throw new Error(`Cannot find a differ supporting object '${e}' of type '${n = e, n.name || typeof n}'`); var n } } return e.\u0275prov = E({ token: e, providedIn: "root", factory: ma }), e })(); function ya() { return new va([new da]) } let va = (() => { class e { constructor(e) { this.factories = e } static create(t, n) { if (n) { const e = n.factories.slice(); t = t.concat(e) } return new e(t) } static extend(t) { return { provide: e, useFactory: n => e.create(t, n || ya()), deps: [[e, new Pn, new Nn]] } } find(e) { const t = this.factories.find(t => t.supports(e)); if (t) return t; throw new Error(`Cannot find a differ supporting object '${e}'`) } } return e.\u0275prov = E({ token: e, providedIn: "root", factory: ya }), e })(); function wa(e, t, n, r, s = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(xe(i)), fe(i)) for (let e = he; e < i.length; e++) { const t = i[e], n = t[1].firstChild; null !== n && wa(t[1], t, n, r) } const o = n.type; if (8 & o) wa(e, t, n.child, r); else if (32 & o) { const e = Dr(n, t); let s; for (; s = e();)r.push(s) } else if (16 & o) { const e = Xr(t, n); if (Array.isArray(e)) r.push(...e); else { const n = Or(t[16]); wa(n[1], n, e, r, !0) } } n = s ? n.projectionNext : n.next } return r } class ba { constructor(e, t) { this._lView = e, this._cdRefInjectingView = t, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const e = this._lView, t = e[1]; return wa(t, e, t.firstChild, []) } get context() { return this._lView[8] } set context(e) { this._lView[8] = e } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const e = this._lView[3]; if (fe(e)) { const t = e[8], n = t ? t.indexOf(this) : -1; n > -1 && ($r(e, n), yn(t, n)) } this._attachedToViewContainer = !1 } Br(this._lView[1], this._lView) } onDestroy(e) { Ms(this._lView[1], this._lView, null, e) } markForCheck() { ti(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { ni(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (e, t, n) { Ze(!0); try { ni(e, t, n) } finally { Ze(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var e; this._appRef = null, Jr(this._lView[1], e = this._lView, e[11], 2, null, null) } attachToAppRef(e) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = e } } class _a extends ba { constructor(e) { super(e), this._view = e } detectChanges() { ri(this._view) } checkNoChanges() { !function (e) { Ze(!0); try { ri(e) } finally { Ze(!1) } }(this._view) } get context() { return null } } const Ea = function (e) { return function (e, t, n) { if (me(e) && !n) { const n = Pe(e.index, t); return new ba(n, n) } return 47 & e.type ? new ba(t[16], t) : null }(He(), je(), 16 == (16 & e)) }; let Ca = (() => { class e { } return e.__NG_ELEMENT_ID__ = Ea, e })(); const Sa = [new da], Ta = new ga([new ia]), Ia = new va(Sa), ka = function () { return Oa(He(), je()) }; let Aa = (() => { class e { } return e.__NG_ELEMENT_ID__ = ka, e })(); const xa = Aa, Da = class extends xa { constructor(e, t, n) { super(), this._declarationLView = e, this._declarationTContainer = t, this.elementRef = n } createEmbeddedView(e) { const t = this._declarationTContainer.tViews, n = Ts(this._declarationLView, t, e, 16, null, t.declTNode, null, null, null, null); n[17] = this._declarationLView[this._declarationTContainer.index]; const r = this._declarationLView[19]; return null !== r && (n[19] = r.createEmbeddedView(t)), As(t, n, e), new ba(n) } }; function Oa(e, t) { return 4 & e.type ? new Da(t, e, Ko(e, t)) : null } class Ra { } class Na { } const Pa = function () { return Va(He(), je()) }; let Fa = (() => { class e { } return e.__NG_ELEMENT_ID__ = Pa, e })(); const La = Fa, Ma = class extends La { constructor(e, t, n) { super(), this._lContainer = e, this._hostTNode = t, this._hostLView = n } get element() { return Ko(this._hostTNode, this._hostLView) } get injector() { return new Zt(this._hostTNode, this._hostLView) } get parentInjector() { const e = Bt(this._hostTNode, this._hostLView); if (Dt(e)) { const t = Rt(e, this._hostLView), n = Ot(e); return new Zt(t[1].data[n + 8], t) } return new Zt(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(e) { const t = $a(this._lContainer); return null !== t && t[e] || null } get length() { return this._lContainer.length - he } createEmbeddedView(e, t, n) { const r = e.createEmbeddedView(t || {}); return this.insert(r, n), r } createComponent(e, t, n, r, s) { const i = n || this.parentInjector; if (!s && null == e.ngModule && i) { const e = i.get(Ra, null); e && (s = e) } const o = e.create(i, r, void 0, s); return this.insert(o.hostView, t), o } insert(e, t) { const n = e._lView, r = n[1]; if (fe(n[3])) { const t = this.indexOf(e); if (-1 !== t) this.detach(t); else { const t = n[3], r = new Ma(t, t[6], t[3]); r.detach(r.indexOf(e)) } } const s = this._adjustIndex(t), i = this._lContainer; !function (e, t, n, r) { const s = he + r, i = n.length; r > 0 && (n[s - 1][4] = t), r < i - he ? (t[4] = n[s], gn(n, he + r, t)) : (n.push(t), t[4] = null), t[3] = n; const o = t[17]; null !== o && n !== o && function (e, t) { const n = e[9]; t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t) }(o, t); const a = t[19]; null !== a && a.insertView(e), t[2] |= 128 }(r, n, i, s); const o = Zr(s, i), a = n[11], c = Hr(a, i[7]); return null !== c && function (e, t, n, r, s, i) { r[0] = s, r[6] = t, Jr(e, r, n, 1, s, i) }(r, i[6], a, n, c, o), e.attachToViewContainerRef(), gn(Ba(i), s, e), e } move(e, t) { return this.insert(e, t) } indexOf(e) { const t = $a(this._lContainer); return null !== t ? t.indexOf(e) : -1 } remove(e) { const t = this._adjustIndex(e, -1), n = $r(this._lContainer, t); n && (yn(Ba(this._lContainer), t), Br(n[1], n)) } detach(e) { const t = this._adjustIndex(e, -1), n = $r(this._lContainer, t); return n && null != yn(Ba(this._lContainer), t) ? new ba(n) : null } _adjustIndex(e, t = 0) { return null == e ? this.length + t : e } }; function $a(e) { return e[8] } function Ba(e) { return e[8] || (e[8] = []) } function Va(e, t) { let n; const r = t[e.index]; if (fe(r)) n = r; else { let s; if (8 & e.type) s = xe(r); else { const n = t[11]; s = n.createComment(""); const r = Oe(e, t); jr(n, Hr(n, r), s, function (e, t) { return ke(e) ? e.nextSibling(t) : t.nextSibling }(n, r), !1) } t[e.index] = n = Xs(r, t, s, e), ei(t, n) } return new Ma(n, e, t) } const Ua = {}; class ja extends Wo { constructor(e) { super(), this.ngModule = e } resolveComponentFactory(e) { const t = ce(e); return new Ha(t, this.ngModule) } } function qa(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } const za = new cn("SCHEDULER_TOKEN", { providedIn: "root", factory: () => kr }); class Ha extends Ho { constructor(e, t) { super(), this.componentDef = e, this.ngModule = t, this.componentType = e.type, this.selector = e.selectors.map(ps).join(","), this.ngContentSelectors = e.ngContentSelectors ? e.ngContentSelectors : [], this.isBoundToModule = !!t } get inputs() { return qa(this.componentDef.inputs) } get outputs() { return qa(this.componentDef.outputs) } create(e, t, n, r) { const s = (r = r || this.ngModule) ? function (e, t) { return { get: (n, r, s) => { const i = e.get(n, Ua, s); return i !== Ua || r === Ua ? i : t.get(n, r, s) } } }(e, r.injector) : e, i = s.get(Jo, Ae), o = s.get(na, null), a = i.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", l = n ? function (e, t, n) { if (ke(e)) return e.selectRootElement(t, n === M.ShadowDom); let r = "string" == typeof t ? e.querySelector(t) : t; return r.textContent = "", r }(a, n, this.componentDef.encapsulation) : Lr(i.createRenderer(null, this.componentDef), c, function (e) { const t = e.toLowerCase(); return "svg" === t ? "http://www.w3.org/2000/svg" : "math" === t ? "http://www.w3.org/1998/MathML/" : null }(c)), u = this.componentDef.onPush ? 576 : 528, h = { components: [], scheduler: kr, clean: ii, playerHandler: null, flags: 0 }, d = Ls(0, null, null, 1, 0, null, null, null, null, null), f = Ts(null, d, h, u, null, null, i, a, o, s); let p, m; ct(f); try { const e = function (e, t, n, r, s, i) { const o = n[1]; n[20] = e; const a = Is(o, 20, 2, "#host", null), c = a.mergedAttrs = t.hostAttrs; null !== c && (ui(a, c, !0), null !== e && (Tt(s, e, c), null !== a.classes && ns(s, e, a.classes), null !== a.styles && ts(s, e, a.styles))); const l = r.createRenderer(e, t), u = Ts(n, Fs(t), null, t.onPush ? 64 : 16, n[20], a, r, l, null, null); return o.firstCreatePass && (Vt(Lt(a, n), o, t.type), qs(o, a), Hs(a, n.length, 1)), ei(n, u), n[20] = u }(l, this.componentDef, f, i, a); if (l) if (n) Tt(a, l, ["ng-version", sa.full]); else { const { attrs: e, classes: t } = function (e) { const t = [], n = []; let r = 1, s = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === s ? "" !== i && t.push(i, e[++r]) : 8 === s && n.push(i); else { if (!ls(s)) break; s = i } r++ } return { attrs: t, classes: n } }(this.componentDef.selectors[0]); e && Tt(a, l, e), t && t.length > 0 && ns(a, l, t.join(" ")) } if (m = Re(d, ue), void 0 !== t) { const e = m.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const r = t[n]; e.push(null != r ? Array.from(r) : null) } } p = function (e, t, n, r, s) { const i = n[1], o = function (e, t, n) { const r = He(); e.firstCreatePass && (n.providersResolver && n.providersResolver(n), Gs(e, r, t, ks(e, t, 1, null), n)); const s = Yt(t, e, r.directiveStart, r); Er(s, t); const i = Oe(r, t); return i && Er(i, t), s }(i, n, t); if (r.components.push(o), e[8] = o, s && s.forEach(e => e(o, t)), t.contentQueries) { const e = He(); t.contentQueries(1, o, e.directiveStart) } const a = He(); return !i.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (mt(a.index), Us(n[1], a, 0, a.directiveStart, a.directiveEnd, t), js(t, o)), o }(e, this.componentDef, f, h, [ki]), As(d, f, null) } finally { ft() } return new Ga(this.componentType, p, Ko(m, f), f, m) } } class Ga extends class { }{ constructor(e, t, n, r, s) { super(), this.location = n, this._rootLView = r, this._tNode = s, this.instance = t, this.hostView = this.changeDetectorRef = new _a(r), this.componentType = e } get injector() { return new Zt(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(e) { this.hostView.onDestroy(e) } } const Wa = new Map; class Ya extends Ra { constructor(e, t) { super(), this._parent = t, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new ja(this); const n = le(e), r = e[K] || null; r && Lo(r), this._bootstrapComponents = Ar(n.bootstrap), this._r3Injector = vi(e, t, [{ provide: Ra, useValue: this }, { provide: Wo, useValue: this.componentFactoryResolver }], d(e)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(e) } get(e, t = Ii.THROW_IF_NOT_FOUND, n = O.Default) { return e === Ii || e === Ra || e === hi ? this : this._r3Injector.get(e, t, n) } destroy() { const e = this._r3Injector; !e.destroyed && e.destroy(), this.destroyCbs.forEach(e => e()), this.destroyCbs = null } onDestroy(e) { this.destroyCbs.push(e) } } class Ka extends Na { constructor(e) { super(), this.moduleType = e, null !== le(e) && function (e) { const t = new Set; !function e(n) { const r = le(n, !0), s = r.id; null !== s && (function (e, t, n) { if (t && t !== n) throw new Error(`Duplicate module registered for ${e} - ${d(t)} vs ${d(t.name)}`) }(s, Wa.get(s), n), Wa.set(s, n)); const i = Ar(r.imports); for (const o of i) t.has(o) || (t.add(o), e(o)) }(e) }(e) } create(e) { return new Ya(this.moduleType, e) } } function Xa(e, t, n) { const r = Qe() + e, s = je(); return s[r] === ms ? $i(s, r, n ? t.call(n) : t()) : function (e, t) { return e[t] }(s, r) } function Za(e, t) { const n = e[t]; return n === ms ? void 0 : n } function Qa(e, t) { const n = qe(); let r; const s = e + ue; n.firstCreatePass ? (r = function (e, t) { if (t) for (let n = t.length - 1; n >= 0; n--) { const r = t[n]; if (e === r.name) return r } throw new v("302", `The pipe '${e}' could not be found!`) }(t, n.pipeRegistry), n.data[s] = r, r.onDestroy && (n.destroyHooks || (n.destroyHooks = [])).push(s, r.onDestroy)) : r = n.data[s]; const i = r.factory || (r.factory = ve(r.type)), o = N(zi); try { const e = Pt(!1), t = i(); return Pt(e), function (e, t, n, r) { n >= e.data.length && (e.data[n] = null, e.blueprint[n] = null), t[n] = r }(n, je(), s, t), t } finally { N(o) } } function Ja(e, t, n) { const r = e + ue, s = je(), i = Ne(s, r); return nc(s, tc(s, r) ? function (e, t, n, r, s, i) { const o = t + n; return Bi(e, o, s) ? $i(e, o + 1, i ? r.call(i, s) : r(s)) : Za(e, o + 1) }(s, Qe(), t, i.transform, n, i) : i.transform(n)) } function ec(e, t, n, r) { const s = e + ue, i = je(), o = Ne(i, s); return nc(i, tc(i, s) ? function (e, t, n, r, s, i, o) { const a = t + n; return Vi(e, a, s, i) ? $i(e, a + 2, o ? r.call(o, s, i) : r(s, i)) : Za(e, a + 2) }(i, Qe(), t, o.transform, n, r, o) : o.transform(n, r)) } function tc(e, t) { return e[1].data[t].pure } function nc(e, t) { return Fi.isWrapped(t) && (t = Fi.unwrap(t), e[Je()] = ms), t } function rc(e) { return t => { setTimeout(e, void 0, t) } } const sc = class extends r.xQ { constructor(e = !1) { super(), this.__isAsync = e } emit(e) { super.next(e) } subscribe(e, t, n) { var r, i, o; let a = e, c = t || (() => null), l = n; if (e && "object" == typeof e) { const t = e; a = null === (r = t.next) || void 0 === r ? void 0 : r.bind(t), c = null === (i = t.error) || void 0 === i ? void 0 : i.bind(t), l = null === (o = t.complete) || void 0 === o ? void 0 : o.bind(t) } this.__isAsync && (c = rc(c), a && (a = rc(a)), l && (l = rc(l))); const u = super.subscribe({ next: a, error: c, complete: l }); return e instanceof s.w && e.add(u), u } }; function ic() { return this._results[Pi()]() } class oc { constructor(e = !1) { this._emitDistinctChangesOnly = e, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const t = Pi(), n = oc.prototype; n[t] || (n[t] = ic) } get changes() { return this._changes || (this._changes = new sc) } get(e) { return this._results[e] } map(e) { return this._results.map(e) } filter(e) { return this._results.filter(e) } find(e) { return this._results.find(e) } reduce(e, t) { return this._results.reduce(e, t) } forEach(e) { this._results.forEach(e) } some(e) { return this._results.some(e) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(e, t) { const n = this; n.dirty = !1; const r = pn(e); (this._changesDetected = !function (e, t, n) { if (e.length !== t.length) return !1; for (let r = 0; r < e.length; r++) { let s = e[r], i = t[r]; if (n && (s = n(s), i = n(i)), i !== s) return !1 } return !0 }(n._results, r, t)) && (n._results = r, n.length = r.length, n.last = r[this.length - 1], n.first = r[0]) } notifyOnChanges() { !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } Symbol; class ac { constructor(e) { this.queryList = e, this.matches = null } clone() { return new ac(this.queryList) } setDirty() { this.queryList.setDirty() } } class cc { constructor(e = []) { this.queries = e } createEmbeddedView(e) { const t = e.queries; if (null !== t) { const n = null !== e.contentQueries ? e.contentQueries[0] : t.length, r = []; for (let e = 0; e < n; e++) { const n = t.getByIndex(e); r.push(this.queries[n.indexInDeclarationView].clone()) } return new cc(r) } return null } insertView(e) { this.dirtyQueriesWithMatches(e) } detachView(e) { this.dirtyQueriesWithMatches(e) } dirtyQueriesWithMatches(e) { for (let t = 0; t < this.queries.length; t++)null !== Ec(e, t).matches && this.queries[t].setDirty() } } class lc { constructor(e, t, n = null) { this.predicate = e, this.flags = t, this.read = n } } class uc { constructor(e = []) { this.queries = e } elementStart(e, t) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(e, t) } elementEnd(e) { for (let t = 0; t < this.queries.length; t++)this.queries[t].elementEnd(e) } embeddedTView(e) { let t = null; for (let n = 0; n < this.length; n++) { const r = null !== t ? t.length : 0, s = this.getByIndex(n).embeddedTView(e, r); s && (s.indexInDeclarationView = n, null !== t ? t.push(s) : t = [s]) } return null !== t ? new uc(t) : null } template(e, t) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(e, t) } getByIndex(e) { return this.queries[e] } get length() { return this.queries.length } track(e) { this.queries.push(e) } } class hc { constructor(e, t = -1) { this.metadata = e, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = t } elementStart(e, t) { this.isApplyingToNode(t) && this.matchTNode(e, t) } elementEnd(e) { this._declarationNodeIndex === e.index && (this._appliesToNextNode = !1) } template(e, t) { this.elementStart(e, t) } embeddedTView(e, t) { return this.isApplyingToNode(e) ? (this.crossesNgTemplate = !0, this.addMatch(-e.index, t), new hc(this.metadata)) : null } isApplyingToNode(e) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const t = this._declarationNodeIndex; let n = e.parent; for (; null !== n && 8 & n.type && n.index !== t;)n = n.parent; return t === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(e, t) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let r = 0; r < n.length; r++) { const s = n[r]; this.matchTNodeWithReadOption(e, t, dc(t, s)), this.matchTNodeWithReadOption(e, t, Wt(t, e, s, !1, !1)) } else n === Aa ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1) : this.matchTNodeWithReadOption(e, t, Wt(t, e, n, !1, !1)) } matchTNodeWithReadOption(e, t, n) { if (null !== n) { const r = this.metadata.read; if (null !== r) if (r === Zo || r === Fa || r === Aa && 4 & t.type) this.addMatch(t.index, -2); else { const n = Wt(t, e, r, !1, !1); null !== n && this.addMatch(t.index, n) } else this.addMatch(t.index, n) } } addMatch(e, t) { null === this.matches ? this.matches = [e, t] : this.matches.push(e, t) } } function dc(e, t) { const n = e.localNames; if (null !== n) for (let r = 0; r < n.length; r += 2)if (n[r] === t) return n[r + 1]; return null } function fc(e, t, n, r) { return -1 === n ? function (e, t) { return 11 & e.type ? Ko(e, t) : 4 & e.type ? Oa(e, t) : null }(t, e) : -2 === n ? function (e, t, n) { return n === Zo ? Ko(t, e) : n === Aa ? Oa(t, e) : n === Fa ? Va(t, e) : void 0 }(e, t, r) : Yt(e, e[1], n, t) } function pc(e, t, n, r) { const s = t[19].queries[r]; if (null === s.matches) { const r = e.data, i = n.matches, o = []; for (let e = 0; e < i.length; e += 2) { const s = i[e]; o.push(s < 0 ? null : fc(t, r[s], i[e + 1], n.metadata.read)) } s.matches = o } return s.matches } function mc(e, t, n, r) { const s = e.queries.getByIndex(n), i = s.matches; if (null !== i) { const o = pc(e, t, s, n); for (let e = 0; e < i.length; e += 2) { const n = i[e]; if (n > 0) r.push(o[e / 2]); else { const s = i[e + 1], o = t[-n]; for (let e = he; e < o.length; e++) { const t = o[e]; t[17] === t[3] && mc(t[1], t, s, r) } if (null !== o[9]) { const e = o[9]; for (let t = 0; t < e.length; t++) { const n = e[t]; mc(n[1], n, s, r) } } } } } return r } function gc(e) { const t = je(), n = qe(), r = st(); it(r + 1); const s = Ec(n, r); if (e.dirty && Fe(t) === (2 == (2 & s.metadata.flags))) { if (null === s.matches) e.reset([]); else { const i = s.crossesNgTemplate ? mc(n, t, r, []) : pc(n, t, s, r); e.reset(i, Qo), e.notifyOnChanges() } return !0 } return !1 } function yc(e, t, n) { const r = qe(); r.firstCreatePass && (_c(r, new lc(e, t, n), -1), 2 == (2 & t) && (r.staticViewQueries = !0)), bc(r, je(), t) } function vc(e, t, n, r) { const s = qe(); if (s.firstCreatePass) { const i = He(); _c(s, new lc(t, n, r), i.index), function (e, t) { const n = e.contentQueries || (e.contentQueries = []); t !== (n.length ? n[n.length - 1] : -1) && n.push(e.queries.length - 1, t) }(s, e), 2 == (2 & n) && (s.staticContentQueries = !0) } bc(s, je(), n) } function wc() { return e = je(), t = st(), e[19].queries[t].queryList; var e, t } function bc(e, t, n) { const r = new oc(4 == (4 & n)); Ms(e, t, r, r.destroy), null === t[19] && (t[19] = new cc), t[19].queries.push(new ac(r)) } function _c(e, t, n) { null === e.queries && (e.queries = new uc), e.queries.track(new hc(t, n)) } function Ec(e, t) { return e.queries.getByIndex(t) } const Cc = on("Output", e => ({ bindingPropertyName: e })), Sc = on("HostListener", (e, t) => ({ eventName: e, args: t })), Tc = new cn("Application Initializer"); let Ic = (() => { class e { constructor(e) { this.appInits = e, this.resolve = Yo, this.reject = Yo, this.initialized = !1, this.done = !1, this.donePromise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } runInitializers() { if (this.initialized) return; const e = [], t = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const t = this.appInits[n](); if (Ji(t)) e.push(t); else if (to(t)) { const n = new Promise((e, n) => { t.subscribe({ complete: e, error: n }) }); e.push(n) } } Promise.all(e).then(() => { t() }).catch(e => { this.reject(e) }), 0 === e.length && t(), this.initialized = !0 } } return e.\u0275fac = function (t) { return new (t || e)(xn(Tc, 8)) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); const kc = new cn("AppId"), Ac = { provide: kc, useFactory: function () { return `${xc()}${xc()}${xc()}` }, deps: [] }; function xc() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const Dc = new cn("Platform Initializer"), Oc = new cn("Platform ID"), Rc = new cn("appBootstrapListener"); let Nc = (() => { class e { log(e) { console.log(e) } warn(e) { console.warn(e) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); const Pc = new cn("LocaleId"), Fc = new cn("DefaultCurrencyCode"); class Lc { constructor(e, t) { this.ngModuleFactory = e, this.componentFactories = t } } const Mc = function (e) { return new Ka(e) }, $c = Mc, Bc = function (e) { return Promise.resolve(Mc(e)) }, Vc = function (e) { const t = Mc(e), n = Ar(le(e).declarations).reduce((e, t) => { const n = ce(t); return n && e.push(new Ha(n)), e }, []); return new Lc(t, n) }, Uc = Vc, jc = function (e) { return Promise.resolve(Vc(e)) }; let qc = (() => { class e { constructor() { this.compileModuleSync = $c, this.compileModuleAsync = Bc, this.compileModuleAndAllComponentsSync = Uc, this.compileModuleAndAllComponentsAsync = jc } clearCache() { } clearCacheFor(e) { } getModuleId(e) { } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); const zc = (() => Promise.resolve(0))(); function Hc(e) { "undefined" == typeof Zone ? zc.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class Gc { constructor({ enableLongStackTrace: e = !1, shouldCoalesceEventChangeDetection: t = !1, shouldCoalesceRunChangeDetection: n = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new sc(!1), this.onMicrotaskEmpty = new sc(!1), this.onStable = new sc(!1), this.onError = new sc(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const r = this; r._nesting = 0, r._outer = r._inner = Zone.current, Zone.TaskTrackingZoneSpec && (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec)), e && Zone.longStackTraceZoneSpec && (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)), r.shouldCoalesceEventChangeDetection = !n && t, r.shouldCoalesceRunChangeDetection = n, r.lastRequestAnimationFrameId = -1, r.nativeRequestAnimationFrame = function () { let e = j.requestAnimationFrame, t = j.cancelAnimationFrame; if ("undefined" != typeof Zone && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function (e) { const t = () => { !function (e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(j, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, Kc(e), e.isCheckStableRunning = !0, Yc(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), Kc(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, s, i, o, a) => { try { return Xc(e), n.invokeTask(s, i, o, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), Zc(e) } }, onInvoke: (n, r, s, i, o, a, c) => { try { return Xc(e), n.invoke(s, i, o, a, c) } finally { e.shouldCoalesceRunChangeDetection && t(), Zc(e) } }, onHasTask: (t, n, r, s) => { t.hasTask(r, s), n === r && ("microTask" == s.change ? (e._hasPendingMicrotasks = s.microTask, Kc(e), Yc(e)) : "macroTask" == s.change && (e.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (t, n, r, s) => (t.handleError(r, s), e.runOutsideAngular(() => e.onError.emit(s)), !1) }) }(r) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Gc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (Gc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(e, t, n) { return this._inner.run(e, t, n) } runTask(e, t, n, r) { const s = this._inner, i = s.scheduleEventTask("NgZoneEvent: " + r, e, Wc, Yo, Yo); try { return s.runTask(i, t, n) } finally { s.cancelTask(i) } } runGuarded(e, t, n) { return this._inner.runGuarded(e, t, n) } runOutsideAngular(e) { return this._outer.run(e) } } const Wc = {}; function Yc(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Kc(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function Xc(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function Zc(e) { e._nesting--, Yc(e) } class Qc { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new sc, this.onMicrotaskEmpty = new sc, this.onStable = new sc, this.onError = new sc } run(e, t, n) { return e.apply(t, n) } runGuarded(e, t, n) { return e.apply(t, n) } runOutsideAngular(e) { return e() } runTask(e, t, n, r) { return e.apply(t, n) } } let Jc = (() => { class e { constructor(e) { this._ngZone = e, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), e.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Gc.assertNotInAngularZone(), Hc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Hc(() => { for (; 0 !== this._callbacks.length;) { let e = this._callbacks.pop(); clearTimeout(e.timeoutId), e.doneCb(this._didWork) } this._didWork = !1 }); else { let e = this.getPendingTasks(); this._callbacks = this._callbacks.filter(t => !t.updateCb || !t.updateCb(e) || (clearTimeout(t.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(e => ({ source: e.source, creationLocation: e.creationLocation, data: e.data })) : [] } addCallback(e, t, n) { let r = -1; t && t > 0 && (r = setTimeout(() => { this._callbacks = this._callbacks.filter(e => e.timeoutId !== r), e(this._didWork, this.getPendingTasks()) }, t)), this._callbacks.push({ doneCb: e, timeoutId: r, updateCb: n }) } whenStable(e, t, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(e, t, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(e, t, n) { return [] } } return e.\u0275fac = function (t) { return new (t || e)(xn(Gc)) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(), el = (() => { class e { constructor() { this._applications = new Map, sl.addToWindow(this) } registerApplication(e, t) { this._applications.set(e, t) } unregisterApplication(e) { this._applications.delete(e) } unregisterAllApplications() { this._applications.clear() } getTestability(e) { return this._applications.get(e) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(e, t = !0) { return sl.findTestabilityInTree(this, e, t) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); class tl { addToWindow(e) { } findTestabilityInTree(e, t, n) { return null } } function nl(e) { sl = e } let rl, sl = new tl, il = !0, ol = !1; function al() { return ol = !0, il } function cl() { if (ol) throw new Error("Cannot enable prod mode after platform setup."); il = !1 } const ll = new cn("AllowMultipleToken"); class ul { constructor(e, t) { this.name = e, this.token = t } } function hl(e, t, n = []) { const r = `Platform: ${t}`, s = new cn(r); return (t = []) => { let i = dl(); if (!i || i.injector.get(ll, !1)) if (e) e(n.concat(t).concat({ provide: s, useValue: !0 })); else { const e = n.concat(t).concat({ provide: s, useValue: !0 }, { provide: fi, useValue: "platform" }); !function (e) { if (rl && !rl.destroyed && !rl.injector.get(ll, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); rl = e.get(fl); const t = e.get(Dc, null); t && t.forEach(e => e()) }(Ii.create({ providers: e, name: r })) } return function (e) { const t = dl(); if (!t) throw new Error("No platform exists!"); if (!t.injector.get(e, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return t }(s) } } function dl() { return rl && !rl.destroyed ? rl : null } let fl = (() => { class e { constructor(e) { this._injector = e, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(e, t) { const n = function (e, t) { let n; return n = "noop" === e ? new Qc : ("zone.js" === e ? void 0 : e) || new Gc({ enableLongStackTrace: al(), shouldCoalesceEventChangeDetection: !!(null == t ? void 0 : t.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == t ? void 0 : t.ngZoneRunCoalescing) }), n }(t ? t.ngZone : void 0, { ngZoneEventCoalescing: t && t.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: t && t.ngZoneRunCoalescing || !1 }), r = [{ provide: Gc, useValue: n }]; return n.run(() => { const t = Ii.create({ providers: r, parent: this.injector, name: e.moduleType.name }), s = e.create(t), i = s.injector.get(Ir, null); if (!i) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return n.runOutsideAngular(() => { const e = n.onError.subscribe({ next: e => { i.handleError(e) } }); s.onDestroy(() => { gl(this._modules, s), e.unsubscribe() }) }), function (e, t, n) { try { const r = n(); return Ji(r) ? r.catch(n => { throw t.runOutsideAngular(() => e.handleError(n)), n }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(i, n, () => { const e = s.injector.get(Ic); return e.runInitializers(), e.donePromise.then(() => (Lo(s.injector.get(Pc, Po) || Po), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(e, t = []) { const n = pl({}, t); return function (e, t, n) { const r = new Ka(n); return Promise.resolve(r) }(0, 0, e).then(e => this.bootstrapModuleFactory(e, n)) } _moduleDoBootstrap(e) { const t = e.injector.get(ml); if (e._bootstrapComponents.length > 0) e._bootstrapComponents.forEach(e => t.bootstrap(e)); else { if (!e.instance.ngDoBootstrap) throw new Error(`The module ${d(e.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); e.instance.ngDoBootstrap(t) } this._modules.push(e) } onDestroy(e) { this._destroyListeners.push(e) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(e => e.destroy()), this._destroyListeners.forEach(e => e()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (t) { return new (t || e)(xn(Ii)) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); function pl(e, t) { return Array.isArray(t) ? t.reduce(pl, e) : Object.assign(Object.assign({}, e), t) } let ml = (() => { class e { constructor(e, t, n, r, s) { this._zone = e, this._injector = t, this._exceptionHandler = n, this._componentFactoryResolver = r, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const u = new i.y(e => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { e.next(this._stable), e.complete() }) }), h = new i.y(e => { let t; this._zone.runOutsideAngular(() => { t = this._zone.onStable.subscribe(() => { Gc.assertNotInAngularZone(), Hc(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, e.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { Gc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { e.next(!1) })) }); return () => { t.unsubscribe(), n.unsubscribe() } }); this.isStable = (0, o.T)(u, h.pipe(e => (0, c.x)()((0, a.O)(l)(e)))) } bootstrap(e, t) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = e instanceof Ho ? e : this._componentFactoryResolver.resolveComponentFactory(e), this.componentTypes.push(n.componentType); const r = n.isBoundToModule ? void 0 : this._injector.get(Ra), s = n.create(Ii.NULL, [], t || n.selector, r), i = s.location.nativeElement, o = s.injector.get(Jc, null), a = o && s.injector.get(el); return o && a && a.registerApplication(i, o), s.onDestroy(() => { this.detachView(s.hostView), gl(this.components, s), a && a.unregisterApplication(i) }), this._loadComponent(s), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let e of this._views) e.detectChanges() } catch (e) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(e)) } finally { this._runningTick = !1 } } attachView(e) { const t = e; this._views.push(t), t.attachToAppRef(this) } detachView(e) { const t = e; gl(this._views, t), t.detachFromAppRef() } _loadComponent(e) { this.attachView(e.hostView), this.tick(), this.components.push(e), this._injector.get(Rc, []).concat(this._bootstrapListeners).forEach(t => t(e)) } ngOnDestroy() { this._views.slice().forEach(e => e.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return e.\u0275fac = function (t) { return new (t || e)(xn(Gc), xn(Ii), xn(Ir), xn(Wo), xn(Ic)) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); function gl(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } class yl { } class vl { } const wl = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let bl = (() => { class e { constructor(e, t) { this._compiler = e, this._config = t || wl } load(e) { return this.loadAndCompile(e) } loadAndCompile(e) { let [t, r] = e.split("#"); return void 0 === r && (r = "default"), n(8255)(t).then(e => e[r]).then(e => _l(e, t, r)).then(e => this._compiler.compileModuleAsync(e)) } loadFactory(e) { let [t, r] = e.split("#"), s = "NgFactory"; return void 0 === r && (r = "default", s = ""), n(8255)(this._config.factoryPathPrefix + t + this._config.factoryPathSuffix).then(e => e[r + s]).then(e => _l(e, t, r)) } } return e.\u0275fac = function (t) { return new (t || e)(xn(qc), xn(vl, 8)) }, e.\u0275prov = E({ token: e, factory: e.\u0275fac }), e })(); function _l(e, t, n) { if (!e) throw new Error(`Cannot find '${n}' in '${t}'`); return e } const El = function (e) { return null }, Cl = hl(null, "core", [{ provide: Oc, useValue: "unknown" }, { provide: fl, deps: [Ii] }, { provide: el, deps: [] }, { provide: Nc, deps: [] }]), Sl = [{ provide: ml, useClass: ml, deps: [Gc, Ii, Ir, Wo, Ic] }, { provide: za, deps: [Gc], useFactory: function (e) { let t = []; return e.onStable.subscribe(() => { for (; t.length;)t.pop()() }), function (e) { t.push(e) } } }, { provide: Ic, useClass: Ic, deps: [[new Nn, Tc]] }, { provide: qc, useClass: qc, deps: [] }, Ac, { provide: ga, useFactory: function () { return Ta }, deps: [] }, { provide: va, useFactory: function () { return Ia }, deps: [] }, { provide: Pc, useFactory: function (e) { return Lo(e = e || "undefined" != typeof $localize && $localize.locale || Po), e }, deps: [[new Rn(Pc), new Nn, new Pn]] }, { provide: Fc, useValue: "USD" }]; let Tl = (() => { class e { constructor(e) { } } return e.\u0275fac = function (t) { return new (t || e)(xn(ml)) }, e.\u0275mod = re({ type: e }), e.\u0275inj = C({ providers: Sl }), e })() }, 5355: (e, t, n) => { "use strict"; n.d(t, { nm: () => k }); var r = n(4459); n(8720), n(2329); var s = n(279), i = n(8604), o = n(3854), a = n(9306); const c = new Map, l = { activated: !1, tokenObservers: [] }, u = { initialized: !1, enabled: !1 }; function h(e) { return c.get(e) || l } function d(e, t) { c.set(e, t) } function f() { return u } class p { constructor(e, t, n, r, s) { if (this.operation = e, this.retryPolicy = t, this.getWaitDuration = n, this.lowerBound = r, this.upperBound = s, this.pending = null, this.nextErrorWaitInterval = r, r > s) throw new Error("Proactive refresh lower bound greater than upper bound!") } start() { this.nextErrorWaitInterval = this.lowerBound, this.process(!0).catch(() => { }) } stop() { this.pending && (this.pending.reject("cancelled"), this.pending = null) } isRunning() { return !!this.pending } async process(e) { this.stop(); try { this.pending = new o.BH, await (t = this.getNextRun(e), new Promise(e => { setTimeout(e, t) })), this.pending.resolve(), await this.pending.promise, this.pending = new o.BH, await this.operation(), this.pending.resolve(), await this.pending.promise, this.process(!0).catch(() => { }) } catch (n) { this.retryPolicy(n) ? this.process(!1).catch(() => { }) : this.stop() } var t } getNextRun(e) { if (e) return this.nextErrorWaitInterval = this.lowerBound, this.getWaitDuration(); { const e = this.nextErrorWaitInterval; return this.nextErrorWaitInterval *= 2, this.nextErrorWaitInterval > this.upperBound && (this.nextErrorWaitInterval = this.upperBound), e } } } const m = new o.LL("appCheck", "AppCheck", { "already-initialized": "You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.", "use-before-activation": "App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.", "fetch-network-error": "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", "fetch-parse-error": "Fetch client could not parse response. Original error: {$originalErrorMessage}.", "fetch-status-error": "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "recaptcha-error": "ReCAPTCHA error.", throttled: "Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}" }), g = "firebase-app-check-store"; let y = null; const v = new a.Yd("@firebase/app-check"); function w(e, t) { return (0, o.hl)() ? function (e, t) { return async function (e, t) { const n = (await (y || (y = new Promise((e, t) => { try { const n = indexedDB.open("firebase-app-check-database", 1); n.onsuccess = t => { e(t.target.result) }, n.onerror = e => { var n; t(m.create("storage-open", { originalErrorMessage: null === (n = e.target.error) || void 0 === n ? void 0 : n.message })) }, n.onupgradeneeded = e => { const t = e.target.result; switch (e.oldVersion) { case 0: t.createObjectStore(g, { keyPath: "compositeKey" }) } } } catch (n) { t(m.create("storage-open", { originalErrorMessage: n.message })) } }), y))).transaction(g, "readwrite"), r = n.objectStore(g).put({ compositeKey: e, value: t }); return new Promise((e, t) => { r.onsuccess = t => { e() }, n.onerror = e => { var n; t(m.create("storage-set", { originalErrorMessage: null === (n = e.target.error) || void 0 === n ? void 0 : n.message })) } }) }(function (e) { return `${e.options.appId}-${e.name}` }(e), t) }(e, t).catch(e => { v.warn(`Failed to write token to IndexedDB. Error: ${e}`) }) : Promise.resolve() } const b = { error: "UNKNOWN_ERROR" }; async function _(e, t = !1) { const n = e.app; !function (e) { if (!h(e).activated) throw m.create("use-before-activation", { appName: e.name }) }(n); const r = h(n); let s, i = r.token; if (!i) { const e = await r.cachedTokenPromise; e && S(e) && (i = e) } if (!t && i && S(i)) return { token: i.token }; let a, c = !1; if (f().enabled) { r.exchangeTokenPromise || (r.exchangeTokenPromise = async function ({ url: e, body: t }, n) { const r = { "Content-Type": "application/json" }, s = n.getImmediate({ optional: !0 }); if (s) { const e = await s.getHeartbeatsHeader(); e && (r["X-Firebase-Client"] = e) } const i = { method: "POST", body: JSON.stringify(t), headers: r }; let o, a; try { o = await fetch(e, i) } catch (h) { throw m.create("fetch-network-error", { originalErrorMessage: h.message }) } if (200 !== o.status) throw m.create("fetch-status-error", { httpStatus: o.status }); try { a = await o.json() } catch (h) { throw m.create("fetch-parse-error", { originalErrorMessage: h.message }) } const c = a.ttl.match(/^([\d.]+)(s)$/); if (!c || !c[2] || isNaN(Number(c[1]))) throw m.create("fetch-parse-error", { originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration format: ${a.ttl}` }); const l = 1e3 * Number(c[1]), u = Date.now(); return { token: a.attestationToken, expireTimeMillis: u + l, issuedAtTimeMillis: u } }(function (e, t) { const { projectId: n, appId: r, apiKey: s } = e.options; return { url: `https://content-firebaseappcheck.googleapis.com/v1beta/projects/${n}/apps/${r}:exchangeDebugToken?key=${s}`, body: { debug_token: t } } }(n, await async function () { const e = f(); if (e.enabled && e.token) return e.token.promise; throw Error("\n            Can't get debug token in production mode.\n        ") }()), e.heartbeatServiceProvider).then(e => (r.exchangeTokenPromise = void 0, e)), c = !0); const t = await r.exchangeTokenPromise; return await w(n, t), d(n, Object.assign(Object.assign({}, r), { token: t })), { token: t.token } } try { r.exchangeTokenPromise || (r.exchangeTokenPromise = r.provider.getToken().then(e => (r.exchangeTokenPromise = void 0, e)), c = !0), i = await r.exchangeTokenPromise } catch (l) { "appCheck/throttled" === l.code ? v.warn(l.message) : v.error(l), s = l } return i ? (a = { token: i.token }, d(n, Object.assign(Object.assign({}, r), { token: i })), await w(n, i)) : a = function (e) { return { token: (t = b, o.US.encodeString(JSON.stringify(t), !1)), error: e }; var t }(s), c && function (e, t) { const n = h(e).tokenObservers; for (const r of n) try { "EXTERNAL" === r.type && null != t.error ? r.error(t.error) : r.next(t) } catch (l) { } }(n, a), a } function E(e, t) { const n = h(e), r = n.tokenObservers.filter(e => e.next !== t); 0 === r.length && n.tokenRefresher && n.tokenRefresher.isRunning() && n.tokenRefresher.stop(), d(e, Object.assign(Object.assign({}, n), { tokenObservers: r })) } function C(e) { const { app: t } = e, n = h(t); let r = n.tokenRefresher; r || (r = function (e) { const { app: t } = e; return new p(async () => { let n; if (n = h(t).token ? await _(e, !0) : await _(e), n.error) throw n.error }, () => !0, () => { const e = h(t); if (e.token) { let t = e.token.issuedAtTimeMillis + .5 * (e.token.expireTimeMillis - e.token.issuedAtTimeMillis) + 3e5; return t = Math.min(t, e.token.expireTimeMillis - 3e5), Math.max(0, t - Date.now()) } return 0 }, 3e4, 96e4) }(e), d(t, Object.assign(Object.assign({}, n), { tokenRefresher: r }))), !r.isRunning() && n.isTokenAutoRefreshEnabled && r.start() } function S(e) { return e.expireTimeMillis - Date.now() > 0 } class T { constructor(e, t) { this.app = e, this.heartbeatServiceProvider = t } _delete() { const { tokenObservers: e } = h(this.app); for (const t of e) E(this.app, t.next); return Promise.resolve() } } const I = "app-check-internal"; (0, s._registerComponent)(new i.wA("app-check", e => { return t = e.getProvider("app").getImmediate(), n = e.getProvider("heartbeat"), new T(t, n); var t, n }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, t, n) => { e.getProvider(I).initialize() })), (0, s._registerComponent)(new i.wA(I, e => { return t = e.getProvider("app-check").getImmediate(), { getToken: e => _(t, e), addTokenListener: e => function (e, t, n, r) { const { app: s } = e, i = h(s), o = { next: n, error: void 0, type: "INTERNAL" }; if (d(s, Object.assign(Object.assign({}, i), { tokenObservers: [...i.tokenObservers, o] })), i.token && S(i.token)) { const t = i.token; Promise.resolve().then(() => { n({ token: t.token }), C(e) }).catch(() => { }) } i.cachedTokenPromise.then(() => C(e)) }(t, 0, e), removeTokenListener: e => E(t.app, e) }; var t }, "PUBLIC").setInstantiationMode("EXPLICIT")), (0, s.registerVersion)("@firebase/app-check", "0.5.4"); class k { constructor() { return (0, r.vb)("app-check") } } "undefined" != typeof window && window }, 8006: (e, t, n) => { "use strict"; n.d(t, { zQ: () => F, ww: () => L, rT: () => O, f7: () => N, L6: () => x, _Q: () => D, lh: () => R, Qv: () => A, nw: () => P }); var r = n(8720), s = n(9765), i = n(5917), o = n(8891), a = n(4402), c = n(6682), l = n(7771), u = n(5319), h = n(9746), d = n(7971), f = n(8858); class p extends s.xQ { constructor(e = Number.POSITIVE_INFINITY, t = Number.POSITIVE_INFINITY, n) { super(), this.scheduler = n, this._events = [], this._infiniteTimeWindow = !1, this._bufferSize = e < 1 ? 1 : e, this._windowTime = t < 1 ? 1 : t, t === Number.POSITIVE_INFINITY ? (this._infiniteTimeWindow = !0, this.next = this.nextInfiniteTimeWindow) : this.next = this.nextTimeWindow } nextInfiniteTimeWindow(e) { if (!this.isStopped) { const t = this._events; t.push(e), t.length > this._bufferSize && t.shift() } super.next(e) } nextTimeWindow(e) { this.isStopped || (this._events.push(new m(this._getNow(), e)), this._trimBufferThenGetEvents()), super.next(e) } _subscribe(e) { const t = this._infiniteTimeWindow, n = t ? this._events : this._trimBufferThenGetEvents(), r = this.scheduler, s = n.length; let i; if (this.closed) throw new d.N; if (this.isStopped || this.hasError ? i = u.w.EMPTY : (this.observers.push(e), i = new f.W(this, e)), r && e.add(e = new h.ht(e, r)), t) for (let o = 0; o < s && !e.closed; o++)e.next(n[o]); else for (let o = 0; o < s && !e.closed; o++)e.next(n[o].value); return this.hasError ? e.error(this.thrownError) : this.isStopped && e.complete(), i } _getNow() { return (this.scheduler || l.c).now() } _trimBufferThenGetEvents() { const e = this._getNow(), t = this._bufferSize, n = this._windowTime, r = this._events, s = r.length; let i = 0; for (; i < s && !(e - r[i].time < n);)i++; return s > t && (i = Math.max(i, s - t)), i > 0 && r.splice(0, i), r } } class m { constructor(e, t) { this.time = e, this.value = t } } function g(e, t, n) { let r; return r = e && "object" == typeof e ? e : { bufferSize: e, windowTime: t, refCount: !1, scheduler: n }, e => e.lift(function ({ bufferSize: e = Number.POSITIVE_INFINITY, windowTime: t = Number.POSITIVE_INFINITY, refCount: n, scheduler: r }) { let s, i, o = 0, a = !1, c = !1; return function (l) { let u; o++, !s || a ? (a = !1, s = new p(e, t, r), u = s.subscribe(this), i = l.subscribe({ next(e) { s.next(e) }, error(e) { a = !0, s.error(e) }, complete() { c = !0, i = void 0, s.complete() } }), c && (i = void 0)) : u = s.subscribe(this), this.add(() => { o--, u.unsubscribe(), u = void 0, i && !c && n && 0 === o && (i.unsubscribe(), i = void 0, s = void 0) }) } }(r)) } var y = n(3190); function v(e, t) { return t ? (0, y.w)(() => e, t) : (0, y.w)(() => e) } var w = n(8002), b = n(8049), _ = n(3101), E = n(5435), C = n(4459), S = n(8939), T = n(8583), I = n(5355), k = n(7841); const A = new r.OlP("angularfire2.auth.use-emulator"), x = new r.OlP("angularfire2.auth.settings"), D = new r.OlP("angularfire2.auth.tenant-id"), O = new r.OlP("angularfire2.auth.langugage-code"), R = new r.OlP("angularfire2.auth.use-device-language"), N = new r.OlP("angularfire.auth.persistence"), P = (e, t, n, r, s, i, o, a) => (0, S.cc)(`${e.name}.auth`, "AngularFireAuth", e.name, () => { const c = t.runOutsideAngular(() => e.auth()); if (n && c.useEmulator(...n), r && (c.tenantId = r), c.languageCode = s, i && c.useDeviceLanguage(), o) for (const [e, t] of Object.entries(o)) c.settings[e] = t; return a && c.setPersistence(a), c }, [n, r, s, i, o, a]); let F = (() => { class e { constructor(e, t, r, l, u, d, f, p, m, I, k, A) { const x = new s.xQ, D = (0, i.of)(void 0).pipe((0, h.QV)(u.outsideAngular), (0, y.w)(() => l.runOutsideAngular(() => Promise.resolve().then(n.bind(n, 9743)))), (0, w.U)(() => (0, S.on)(e, l, t)), (0, w.U)(e => P(e, l, d, p, m, I, f, k)), g({ bufferSize: 1, refCount: !1 })); if ((0, T.PM)(r)) this.authState = this.user = this.idToken = this.idTokenResult = this.credential = (0, i.of)(null); else { D.pipe((0, b.P)()).subscribe(); const e = D.pipe((0, y.w)(e => e.getRedirectResult().then(e => e, () => null)), C.iC, g({ bufferSize: 1, refCount: !1 })), t = D.pipe((0, y.w)(e => new o.y(t => ({ unsubscribe: l.runOutsideAngular(() => e.onAuthStateChanged(e => t.next(e), e => t.error(e), () => t.complete())) })))), n = D.pipe((0, y.w)(e => new o.y(t => ({ unsubscribe: l.runOutsideAngular(() => e.onIdTokenChanged(e => t.next(e), e => t.error(e), () => t.complete())) })))); this.authState = e.pipe(v(t), (0, _.R)(u.outsideAngular), (0, h.QV)(u.insideAngular)), this.user = e.pipe(v(n), (0, _.R)(u.outsideAngular), (0, h.QV)(u.insideAngular)), this.idToken = this.user.pipe((0, y.w)(e => e ? (0, a.D)(e.getIdToken()) : (0, i.of)(null))), this.idTokenResult = this.user.pipe((0, y.w)(e => e ? (0, a.D)(e.getIdTokenResult()) : (0, i.of)(null))), this.credential = (0, c.T)(e, x, this.authState.pipe((0, E.h)(e => !e))).pipe((0, w.U)(e => (null == e ? void 0 : e.user) ? e : null), (0, _.R)(u.outsideAngular), (0, h.QV)(u.insideAngular)) } return (0, S.pX)(this, D, l, { spy: { apply: (e, t, n) => { (e.startsWith("signIn") || e.startsWith("createUser")) && n.then(e => x.next(e)) } } }) } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(S.Dh), r.LFG(S.xv, 8), r.LFG(r.Lbi), r.LFG(r.R0b), r.LFG(C.HU), r.LFG(A, 8), r.LFG(x, 8), r.LFG(D, 8), r.LFG(O, 8), r.LFG(R, 8), r.LFG(N, 8), r.LFG(I.nm, 8)) }, e.\u0275prov = r.Yz7({ token: e, factory: e.\u0275fac, providedIn: "any" }), e })(), L = (() => { class e { constructor() { k.Z.registerVersion("angularfire", C.q4.full, "auth-compat") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ providers: [F] }), e })() }, 2278: (e, t, n) => { "use strict"; n.d(t, { ST: () => Yp, yb: () => Kp }); var r = n(8720), s = n(3637), i = n(8891), o = n(4402), a = n(5917), c = n(4459), l = n(7393); function u() { return e => e.lift(new h) } class h { call(e, t) { return t.subscribe(new d(e)) } } class d extends l.L { constructor(e) { super(e), this.hasPrev = !1 } _next(e) { let t; this.hasPrev ? t = [this.prev, e] : this.hasPrev = !0, this.prev = e, t && this.destination.next(t) } } var f, p = n(9761), m = n(8002), g = n(2145), y = n(7519), v = n(5435), w = n(8939), b = n(8583), _ = (n(9743), n(156)), E = n(279), C = n(8604), S = n(9306), T = n(3854), I = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}, k = {}, A = A || {}, x = I || self; function D() { } function O(e) { var t = typeof e; return "array" == (t = "object" != t ? t : e ? Array.isArray(e) ? "array" : t : "null") || "object" == t && "number" == typeof e.length } function R(e) { var t = typeof e; return "object" == t && null != e || "function" == t } var N = "closure_uid_" + (1e9 * Math.random() >>> 0), P = 0; function F(e, t, n) { return e.call.apply(e.bind, arguments) } function L(e, t, n) { if (!e) throw Error(); if (2 < arguments.length) { var r = Array.prototype.slice.call(arguments, 2); return function () { var n = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(n, r), e.apply(t, n) } } return function () { return e.apply(t, arguments) } } function M(e, t, n) { return (M = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? F : L).apply(null, arguments) } function $(e, t) { var n = Array.prototype.slice.call(arguments, 1); return function () { var t = n.slice(); return t.push.apply(t, arguments), e.apply(this, t) } } function B(e, t) { function n() { } n.prototype = t.prototype, e.Z = t.prototype, e.prototype = new n, e.prototype.constructor = e, e.Vb = function (e, n, r) { for (var s = Array(arguments.length - 2), i = 2; i < arguments.length; i++)s[i - 2] = arguments[i]; return t.prototype[n].apply(e, s) } } function V() { this.s = this.s, this.o = this.o } var U = {}; V.prototype.s = !1, V.prototype.na = function () { if (!this.s && (this.s = !0, this.M(), 0)) { var e = function (e) { return Object.prototype.hasOwnProperty.call(e, N) && e[N] || (e[N] = ++P) }(this); delete U[e] } }, V.prototype.M = function () { if (this.o) for (; this.o.length;)this.o.shift()() }; const j = Array.prototype.indexOf ? function (e, t) { return Array.prototype.indexOf.call(e, t, void 0) } : function (e, t) { if ("string" == typeof e) return "string" != typeof t || 1 != t.length ? -1 : e.indexOf(t, 0); for (let n = 0; n < e.length; n++)if (n in e && e[n] === t) return n; return -1 }, q = Array.prototype.forEach ? function (e, t, n) { Array.prototype.forEach.call(e, t, n) } : function (e, t, n) { const r = e.length, s = "string" == typeof e ? e.split("") : e; for (let i = 0; i < r; i++)i in s && t.call(n, s[i], i, e) }; function z(e) { return Array.prototype.concat.apply([], arguments) } function H(e) { const t = e.length; if (0 < t) { const n = Array(t); for (let r = 0; r < t; r++)n[r] = e[r]; return n } return [] } function G(e) { return /^[\s\xa0]*$/.test(e) } var W, Y = String.prototype.trim ? function (e) { return e.trim() } : function (e) { return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(e)[1] }; function K(e, t) { return -1 != e.indexOf(t) } function X(e, t) { return e < t ? -1 : e > t ? 1 : 0 } e: { var Z = x.navigator; if (Z) { var Q = Z.userAgent; if (Q) { W = Q; break e } } W = "" } function J(e, t, n) { for (const r in e) t.call(n, e[r], r, e) } function ee(e) { const t = {}; for (const n in e) t[n] = e[n]; return t } var te = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function ne(e, t) { let n, r; for (let s = 1; s < arguments.length; s++) { for (n in r = arguments[s], r) e[n] = r[n]; for (let t = 0; t < te.length; t++)n = te[t], Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]) } } function re(e) { return re[" "](e), e } re[" "] = D; var se, ie, oe = K(W, "Opera"), ae = K(W, "Trident") || K(W, "MSIE"), ce = K(W, "Edge"), le = ce || ae, ue = K(W, "Gecko") && !(K(W.toLowerCase(), "webkit") && !K(W, "Edge")) && !(K(W, "Trident") || K(W, "MSIE")) && !K(W, "Edge"), he = K(W.toLowerCase(), "webkit") && !K(W, "Edge"); function de() { var e = x.document; return e ? e.documentMode : void 0 } e: { var fe = "", pe = (ie = W, ue ? /rv:([^\);]+)(\)|;)/.exec(ie) : ce ? /Edge\/([\d\.]+)/.exec(ie) : ae ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(ie) : he ? /WebKit\/(\S+)/.exec(ie) : oe ? /(?:Version)[ \/]?(\S+)/.exec(ie) : void 0); if (pe && (fe = pe ? pe[1] : ""), ae) { var me = de(); if (null != me && me > parseFloat(fe)) { se = String(me); break e } } se = fe } var ge = {}; var ye = x.document && ae && (de() || parseInt(se, 10)) || void 0, ve = function () { if (!x.addEventListener || !Object.defineProperty) return !1; var e = !1, t = Object.defineProperty({}, "passive", { get: function () { e = !0 } }); try { x.addEventListener("test", D, t), x.removeEventListener("test", D, t) } catch (n) { } return e }(); function we(e, t) { this.type = e, this.g = this.target = t, this.defaultPrevented = !1 } function be(e, t) { if (we.call(this, e ? e.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, e) { var n = this.type = e.type, r = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null; if (this.target = e.target || e.srcElement, this.g = t, t = e.relatedTarget) { if (ue) { e: { try { re(t.nodeName); var s = !0; break e } catch (i) { } s = !1 } s || (t = null) } } else "mouseover" == n ? t = e.fromElement : "mouseout" == n && (t = e.toElement); this.relatedTarget = t, r ? (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0) : (this.clientX = void 0 !== e.clientX ? e.clientX : e.pageX, this.clientY = void 0 !== e.clientY ? e.clientY : e.pageY, this.screenX = e.screenX || 0, this.screenY = e.screenY || 0), this.button = e.button, this.key = e.key || "", this.ctrlKey = e.ctrlKey, this.altKey = e.altKey, this.shiftKey = e.shiftKey, this.metaKey = e.metaKey, this.pointerId = e.pointerId || 0, this.pointerType = "string" == typeof e.pointerType ? e.pointerType : _e[e.pointerType] || "", this.state = e.state, this.i = e, e.defaultPrevented && be.Z.h.call(this) } } we.prototype.h = function () { this.defaultPrevented = !0 }, B(be, we); var _e = { 2: "touch", 3: "pen", 4: "mouse" }; be.prototype.h = function () { be.Z.h.call(this); var e = this.i; e.preventDefault ? e.preventDefault() : e.returnValue = !1 }; var Ee = "closure_listenable_" + (1e6 * Math.random() | 0), Ce = 0; function Se(e, t, n, r, s) { this.listener = e, this.proxy = null, this.src = t, this.type = n, this.capture = !!r, this.ia = s, this.key = ++Ce, this.ca = this.fa = !1 } function Te(e) { e.ca = !0, e.listener = null, e.proxy = null, e.src = null, e.ia = null } function Ie(e) { this.src = e, this.g = {}, this.h = 0 } function ke(e, t) { var n = t.type; if (n in e.g) { var r, s = e.g[n], i = j(s, t); (r = 0 <= i) && Array.prototype.splice.call(s, i, 1), r && (Te(t), 0 == e.g[n].length && (delete e.g[n], e.h--)) } } function Ae(e, t, n, r) { for (var s = 0; s < e.length; ++s) { var i = e[s]; if (!i.ca && i.listener == t && i.capture == !!n && i.ia == r) return s } return -1 } Ie.prototype.add = function (e, t, n, r, s) { var i = e.toString(); (e = this.g[i]) || (e = this.g[i] = [], this.h++); var o = Ae(e, t, r, s); return -1 < o ? (t = e[o], n || (t.fa = !1)) : ((t = new Se(t, this.src, i, !!r, s)).fa = n, e.push(t)), t }; var xe = "closure_lm_" + (1e6 * Math.random() | 0), De = {}; function Oe(e, t, n, r, s) { if (r && r.once) return Ne(e, t, n, r, s); if (Array.isArray(t)) { for (var i = 0; i < t.length; i++)Oe(e, t[i], n, r, s); return null } return n = Ve(n), e && e[Ee] ? e.N(t, n, R(r) ? !!r.capture : !!r, s) : Re(e, t, n, !1, r, s) } function Re(e, t, n, r, s, i) { if (!t) throw Error("Invalid event type"); var o = R(s) ? !!s.capture : !!s, a = $e(e); if (a || (e[xe] = a = new Ie(e)), (n = a.add(t, n, r, o, i)).proxy) return n; if (r = function () { var e = Me; return function t(n) { return e.call(t.src, t.listener, n) } }(), n.proxy = r, r.src = e, r.listener = n, e.addEventListener) ve || (s = o), void 0 === s && (s = !1), e.addEventListener(t.toString(), r, s); else if (e.attachEvent) e.attachEvent(Le(t.toString()), r); else { if (!e.addListener || !e.removeListener) throw Error("addEventListener and attachEvent are unavailable."); e.addListener(r) } return n } function Ne(e, t, n, r, s) { if (Array.isArray(t)) { for (var i = 0; i < t.length; i++)Ne(e, t[i], n, r, s); return null } return n = Ve(n), e && e[Ee] ? e.O(t, n, R(r) ? !!r.capture : !!r, s) : Re(e, t, n, !0, r, s) } function Pe(e, t, n, r, s) { if (Array.isArray(t)) for (var i = 0; i < t.length; i++)Pe(e, t[i], n, r, s); else r = R(r) ? !!r.capture : !!r, n = Ve(n), e && e[Ee] ? (e = e.i, (t = String(t).toString()) in e.g && -1 < (n = Ae(i = e.g[t], n, r, s)) && (Te(i[n]), Array.prototype.splice.call(i, n, 1), 0 == i.length && (delete e.g[t], e.h--))) : e && (e = $e(e)) && (t = e.g[t.toString()], e = -1, t && (e = Ae(t, n, r, s)), (n = -1 < e ? t[e] : null) && Fe(n)) } function Fe(e) { if ("number" != typeof e && e && !e.ca) { var t = e.src; if (t && t[Ee]) ke(t.i, e); else { var n = e.type, r = e.proxy; t.removeEventListener ? t.removeEventListener(n, r, e.capture) : t.detachEvent ? t.detachEvent(Le(n), r) : t.addListener && t.removeListener && t.removeListener(r), (n = $e(t)) ? (ke(n, e), 0 == n.h && (n.src = null, t[xe] = null)) : Te(e) } } } function Le(e) { return e in De ? De[e] : De[e] = "on" + e } function Me(e, t) { if (e.ca) e = !0; else { t = new be(t, this); var n = e.listener, r = e.ia || e.src; e.fa && Fe(e), e = n.call(r, t) } return e } function $e(e) { return (e = e[xe]) instanceof Ie ? e : null } var Be = "__closure_events_fn_" + (1e9 * Math.random() >>> 0); function Ve(e) { return "function" == typeof e ? e : (e[Be] || (e[Be] = function (t) { return e.handleEvent(t) }), e[Be]) } function Ue() { V.call(this), this.i = new Ie(this), this.P = this, this.I = null } function je(e, t) { var n, r = e.I; if (r) for (n = []; r; r = r.I)n.push(r); if (e = e.P, r = t.type || t, "string" == typeof t) t = new we(t, e); else if (t instanceof we) t.target = t.target || e; else { var s = t; ne(t = new we(r, e), s) } if (s = !0, n) for (var i = n.length - 1; 0 <= i; i--) { var o = t.g = n[i]; s = qe(o, r, !0, t) && s } if (s = qe(o = t.g = e, r, !0, t) && s, s = qe(o, r, !1, t) && s, n) for (i = 0; i < n.length; i++)s = qe(o = t.g = n[i], r, !1, t) && s } function qe(e, t, n, r) { if (!(t = e.i.g[String(t)])) return !0; t = t.concat(); for (var s = !0, i = 0; i < t.length; ++i) { var o = t[i]; if (o && !o.ca && o.capture == n) { var a = o.listener, c = o.ia || o.src; o.fa && ke(e.i, o), s = !1 !== a.call(c, r) && s } } return s && !r.defaultPrevented } B(Ue, V), Ue.prototype[Ee] = !0, Ue.prototype.removeEventListener = function (e, t, n, r) { Pe(this, e, t, n, r) }, Ue.prototype.M = function () { if (Ue.Z.M.call(this), this.i) { var e, t = this.i; for (e in t.g) { for (var n = t.g[e], r = 0; r < n.length; r++)Te(n[r]); delete t.g[e], t.h-- } } this.I = null }, Ue.prototype.N = function (e, t, n, r) { return this.i.add(String(e), t, !1, n, r) }, Ue.prototype.O = function (e, t, n, r) { return this.i.add(String(e), t, !0, n, r) }; var ze = x.JSON.stringify; function He() { var e = Qe; let t = null; return e.g && (t = e.g, e.g = e.g.next, e.g || (e.h = null), t.next = null), t } var Ge, We = new class { constructor(e, t) { this.i = e, this.j = t, this.h = 0, this.g = null } get() { let e; return 0 < this.h ? (this.h--, e = this.g, this.g = e.next, e.next = null) : e = this.i(), e } }(() => new Ye, e => e.reset()); class Ye { constructor() { this.next = this.g = this.h = null } set(e, t) { this.h = e, this.g = t, this.next = null } reset() { this.next = this.g = this.h = null } } function Ke(e) { x.setTimeout(() => { throw e }, 0) } function Xe(e, t) { Ge || function () { var e = x.Promise.resolve(void 0); Ge = function () { e.then(Je) } }(), Ze || (Ge(), Ze = !0), Qe.add(e, t) } var Ze = !1, Qe = new class { constructor() { this.h = this.g = null } add(e, t) { const n = We.get(); n.set(e, t), this.h ? this.h.next = n : this.g = n, this.h = n } }; function Je() { for (var e; e = He();) { try { e.h.call(e.g) } catch (n) { Ke(n) } var t = We; t.j(e), 100 > t.h && (t.h++, e.next = t.g, t.g = e) } Ze = !1 } function et(e, t) { Ue.call(this), this.h = e || 1, this.g = t || x, this.j = M(this.kb, this), this.l = Date.now() } function tt(e) { e.da = !1, e.S && (e.g.clearTimeout(e.S), e.S = null) } function nt(e, t, n) { if ("function" == typeof e) n && (e = M(e, n)); else { if (!e || "function" != typeof e.handleEvent) throw Error("Invalid listener argument"); e = M(e.handleEvent, e) } return 2147483647 < Number(t) ? -1 : x.setTimeout(e, t || 0) } function rt(e) { e.g = nt(() => { e.g = null, e.i && (e.i = !1, rt(e)) }, e.j); const t = e.h; e.h = null, e.m.apply(null, t) } B(et, Ue), (f = et.prototype).da = !1, f.S = null, f.kb = function () { if (this.da) { var e = Date.now() - this.l; 0 < e && e < .8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - e) : (this.S && (this.g.clearTimeout(this.S), this.S = null), je(this, "tick"), this.da && (tt(this), this.start())) } }, f.start = function () { this.da = !0, this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now()) }, f.M = function () { et.Z.M.call(this), tt(this), delete this.g }; class st extends V { constructor(e, t) { super(), this.m = e, this.j = t, this.h = null, this.i = !1, this.g = null } l(e) { this.h = arguments, this.g ? this.i = !0 : rt(this) } M() { super.M(), this.g && (x.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function it(e) { V.call(this), this.h = e, this.g = {} } B(it, V); var ot = []; function at(e, t, n, r) { Array.isArray(n) || (n && (ot[0] = n.toString()), n = ot); for (var s = 0; s < n.length; s++) { var i = Oe(t, n[s], r || e.handleEvent, !1, e.h || e); if (!i) break; e.g[i.key] = i } } function ct(e) { J(e.g, function (e, t) { this.g.hasOwnProperty(t) && Fe(e) }, e), e.g = {} } function lt() { this.g = !0 } function ut(e, t, n, r) { e.info(function () { return "XMLHTTP TEXT (" + t + "): " + function (e, t) { if (!e.g) return t; if (!t) return null; try { var n = JSON.parse(t); if (n) for (e = 0; e < n.length; e++)if (Array.isArray(n[e])) { var r = n[e]; if (!(2 > r.length)) { var s = r[1]; if (Array.isArray(s) && !(1 > s.length)) { var i = s[0]; if ("noop" != i && "stop" != i && "close" != i) for (var o = 1; o < s.length; o++)s[o] = "" } } } return ze(n) } catch (a) { return t } }(e, n) + (r ? " " + r : "") }) } it.prototype.M = function () { it.Z.M.call(this), ct(this) }, it.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }, lt.prototype.Aa = function () { this.g = !1 }, lt.prototype.info = function () { }; var ht = {}, dt = null; function ft() { return dt = dt || new Ue } function pt(e) { we.call(this, ht.Ma, e) } function mt(e) { const t = ft(); je(t, new pt(t, e)) } function gt(e, t) { we.call(this, ht.STAT_EVENT, e), this.stat = t } function yt(e) { const t = ft(); je(t, new gt(t, e)) } function vt(e, t) { we.call(this, ht.Na, e), this.size = t } function wt(e, t) { if ("function" != typeof e) throw Error("Fn must not be null and must be a function"); return x.setTimeout(function () { e() }, t) } ht.Ma = "serverreachability", B(pt, we), ht.STAT_EVENT = "statevent", B(gt, we), ht.Na = "timingevent", B(vt, we); var bt = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 }, _t = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" }; function Et() { } function Ct() { } Et.prototype.h = null; var St, Tt = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" }; function It() { we.call(this, "d") } function kt() { we.call(this, "c") } function At() { } function xt(e, t, n, r) { this.l = e, this.j = t, this.m = n, this.X = r || 1, this.V = new it(this), this.P = Ot, this.W = new et(e = le ? 125 : void 0), this.H = null, this.i = !1, this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null, this.D = [], this.g = null, this.C = 0, this.o = this.u = null, this.N = -1, this.I = !1, this.O = 0, this.L = null, this.aa = this.J = this.$ = this.U = !1, this.h = new Dt } function Dt() { this.i = null, this.g = "", this.h = !1 } B(It, we), B(kt, we), B(At, Et), At.prototype.g = function () { return new XMLHttpRequest }, At.prototype.i = function () { return {} }, St = new At; var Ot = 45e3, Rt = {}, Nt = {}; function Pt(e, t, n) { e.K = 1, e.v = rn(Zt(t)), e.s = n, e.U = !0, Ft(e, null) } function Ft(e, t) { e.F = Date.now(), Bt(e), e.A = Zt(e.v); var n = e.A, r = e.X; Array.isArray(r) || (r = [String(r)]), yn(n.h, "t", r), e.C = 0, n = e.l.H, e.h = new Dt, e.g = yr(e.l, n ? t : null, !e.s), 0 < e.O && (e.L = new st(M(e.Ia, e, e.g), e.O)), at(e.V, e.g, "readystatechange", e.gb), t = e.H ? ee(e.H) : {}, e.s ? (e.u || (e.u = "POST"), t["Content-Type"] = "application/x-www-form-urlencoded", e.g.ea(e.A, e.u, e.s, t)) : (e.u = "GET", e.g.ea(e.A, e.u, null, t)), mt(1), function (e, t, n, r, s, i) { e.info(function () { if (e.g) if (i) for (var o = "", a = i.split("&"), c = 0; c < a.length; c++) { var l = a[c].split("="); if (1 < l.length) { var u = l[0]; l = l[1]; var h = u.split("_"); o = 2 <= h.length && "type" == h[1] ? o + (u + "=") + l + "&" : o + (u + "=redacted&") } } else o = null; else o = i; return "XMLHTTP REQ (" + r + ") [attempt " + s + "]: " + t + "\n" + n + "\n" + o }) }(e.j, e.u, e.A, e.m, e.X, e.s) } function Lt(e) { return !!e.g && "GET" == e.u && 2 != e.K && e.l.Ba } function Mt(e, t, n) { let r, s = !0; for (; !e.I && e.C < n.length;) { if (r = $t(e, n), r == Nt) { 4 == t && (e.o = 4, yt(14), s = !1), ut(e.j, e.m, null, "[Incomplete Response]"); break } if (r == Rt) { e.o = 4, yt(15), ut(e.j, e.m, n, "[Invalid Chunk]"), s = !1; break } ut(e.j, e.m, r, null), zt(e, r) } Lt(e) && r != Nt && r != Rt && (e.h.g = "", e.C = 0), 4 != t || 0 != n.length || e.h.h || (e.o = 1, yt(16), s = !1), e.i = e.i && s, s ? 0 < n.length && !e.aa && (e.aa = !0, (t = e.l).g == e && t.$ && !t.L && (t.h.info("Great, no buffering proxy detected. Bytes received: " + n.length), lr(t), t.L = !0, yt(11))) : (ut(e.j, e.m, n, "[Invalid Chunked Response]"), qt(e), jt(e)) } function $t(e, t) { var n = e.C, r = t.indexOf("\n", n); return -1 == r ? Nt : (n = Number(t.substring(n, r)), isNaN(n) ? Rt : (r += 1) + n > t.length ? Nt : (t = t.substr(r, n), e.C = r + n, t)) } function Bt(e) { e.Y = Date.now() + e.P, Vt(e, e.P) } function Vt(e, t) { if (null != e.B) throw Error("WatchDog timer not null"); e.B = wt(M(e.eb, e), t) } function Ut(e) { e.B && (x.clearTimeout(e.B), e.B = null) } function jt(e) { 0 == e.l.G || e.I || dr(e.l, e) } function qt(e) { Ut(e); var t = e.L; t && "function" == typeof t.na && t.na(), e.L = null, tt(e.W), ct(e.V), e.g && (t = e.g, e.g = null, t.abort(), t.na()) } function zt(e, t) { try { var n = e.l; if (0 != n.G && (n.g == e || Cn(n.i, e))) if (n.I = e.N, !e.J && Cn(n.i, e) && 3 == n.G) { try { var r = n.Ca.g.parse(t) } catch (l) { r = null } if (Array.isArray(r) && 3 == r.length) { var s = r; if (0 == s[0]) { e: if (!n.u) { if (n.g) { if (!(n.g.F + 3e3 < e.F)) break e; hr(n), er(n) } cr(n), yt(18) } } else n.ta = s[1], 0 < n.ta - n.U && 37500 > s[2] && n.N && 0 == n.A && !n.v && (n.v = wt(M(n.ab, n), 6e3)); if (1 >= En(n.i) && n.ka) { try { n.ka() } catch (l) { } n.ka = void 0 } } else pr(n, 11) } else if ((e.J || n.g == e) && hr(n), !G(t)) for (s = n.Ca.g.parse(t), t = 0; t < s.length; t++) { let l = s[t]; if (n.U = l[0], l = l[1], 2 == n.G) if ("c" == l[0]) { n.J = l[1], n.la = l[2]; const t = l[3]; null != t && (n.ma = t, n.h.info("VER=" + n.ma)); const s = l[4]; null != s && (n.za = s, n.h.info("SVER=" + n.za)); const u = l[5]; null != u && "number" == typeof u && 0 < u && (n.K = r = 1.5 * u, n.h.info("backChannelRequestTimeoutMs_=" + r)), r = n; const h = e.g; if (h) { const e = h.g ? h.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (e) { var i = r.i; !i.g && (K(e, "spdy") || K(e, "quic") || K(e, "h2")) && (i.j = i.l, i.g = new Set, i.h && (Sn(i, i.h), i.h = null)) } if (r.D) { const e = h.g ? h.g.getResponseHeader("X-HTTP-Session-Id") : null; e && (r.sa = e, nn(r.F, r.D, e)) } } n.G = 3, n.j && n.j.xa(), n.$ && (n.O = Date.now() - e.F, n.h.info("Handshake RTT: " + n.O + "ms")); var o = e; if ((r = n).oa = gr(r, r.H ? r.la : null, r.W), o.J) { Tn(r.i, o); var a = o, c = r.K; c && a.setTimeout(c), a.B && (Ut(a), Bt(a)), r.g = o } else ar(r); 0 < n.l.length && rr(n) } else "stop" != l[0] && "close" != l[0] || pr(n, 7); else 3 == n.G && ("stop" == l[0] || "close" == l[0] ? "stop" == l[0] ? pr(n, 7) : Jn(n) : "noop" != l[0] && n.j && n.j.wa(l), n.A = 0) } mt(4) } catch (l) { } } function Ht(e, t) { if (e.forEach && "function" == typeof e.forEach) e.forEach(t, void 0); else if (O(e) || "string" == typeof e) q(e, t, void 0); else { if (e.T && "function" == typeof e.T) var n = e.T(); else if (e.R && "function" == typeof e.R) n = void 0; else if (O(e) || "string" == typeof e) { n = []; for (var r = e.length, s = 0; s < r; s++)n.push(s) } else for (s in n = [], r = 0, e) n[r++] = s; s = (r = function (e) { if (e.R && "function" == typeof e.R) return e.R(); if ("string" == typeof e) return e.split(""); if (O(e)) { for (var t = [], n = e.length, r = 0; r < n; r++)t.push(e[r]); return t } for (r in t = [], n = 0, e) t[n++] = e[r]; return t }(e)).length; for (var i = 0; i < s; i++)t.call(void 0, r[i], n && n[i], e) } } function Gt(e, t) { this.h = {}, this.g = [], this.i = 0; var n = arguments.length; if (1 < n) { if (n % 2) throw Error("Uneven number of arguments"); for (var r = 0; r < n; r += 2)this.set(arguments[r], arguments[r + 1]) } else if (e) if (e instanceof Gt) for (n = e.T(), r = 0; r < n.length; r++)this.set(n[r], e.get(n[r])); else for (r in e) this.set(r, e[r]) } function Wt(e) { if (e.i != e.g.length) { for (var t = 0, n = 0; t < e.g.length;) { var r = e.g[t]; Yt(e.h, r) && (e.g[n++] = r), t++ } e.g.length = n } if (e.i != e.g.length) { var s = {}; for (n = t = 0; t < e.g.length;)Yt(s, r = e.g[t]) || (e.g[n++] = r, s[r] = 1), t++; e.g.length = n } } function Yt(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } (f = xt.prototype).setTimeout = function (e) { this.P = e }, f.gb = function (e) { e = e.target; const t = this.L; t && 3 == Yn(e) ? t.l() : this.Ia(e) }, f.Ia = function (e) { try { if (e == this.g) e: { const u = Yn(this.g); var t = this.g.Da(); const h = this.g.ba(); if (!(3 > u) && (3 != u || le || this.g && (this.h.h || this.g.ga() || Kn(this.g)))) { this.I || 4 != u || 7 == t || mt(8 == t || 0 >= h ? 3 : 2), Ut(this); var n = this.g.ba(); this.N = n; t: if (Lt(this)) { var r = Kn(this.g); e = ""; var s = r.length, i = 4 == Yn(this.g); if (!this.h.i) { if ("undefined" == typeof TextDecoder) { qt(this), jt(this); var o = ""; break t } this.h.i = new x.TextDecoder } for (t = 0; t < s; t++)this.h.h = !0, e += this.h.i.decode(r[t], { stream: i && t == s - 1 }); r.splice(0, s), this.h.g += e, this.C = 0, o = this.h.g } else o = this.g.ga(); if (this.i = 200 == n, function (e, t, n, r, s, i, o) { e.info(function () { return "XMLHTTP RESP (" + r + ") [ attempt " + s + "]: " + t + "\n" + n + "\n" + i + " " + o }) }(this.j, this.u, this.A, this.m, this.X, u, n), this.i) { if (this.$ && !this.J) { t: { if (this.g) { var a, c = this.g; if ((a = c.g ? c.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !G(a)) { var l = a; break t } } l = null } if (!(n = l)) { this.i = !1, this.o = 3, yt(12), qt(this), jt(this); break e } ut(this.j, this.m, n, "Initial handshake response via X-HTTP-Initial-Response"), this.J = !0, zt(this, n) } this.U ? (Mt(this, u, o), le && this.i && 3 == u && (at(this.V, this.W, "tick", this.fb), this.W.start())) : (ut(this.j, this.m, o, null), zt(this, o)), 4 == u && qt(this), this.i && !this.I && (4 == u ? dr(this.l, this) : (this.i = !1, Bt(this))) } else 400 == n && 0 < o.indexOf("Unknown SID") ? (this.o = 3, yt(12)) : (this.o = 0, yt(13)), qt(this), jt(this) } } } catch (u) { } }, f.fb = function () { if (this.g) { var e = Yn(this.g), t = this.g.ga(); this.C < t.length && (Ut(this), Mt(this, e, t), this.i && 4 != e && Bt(this)) } }, f.cancel = function () { this.I = !0, qt(this) }, f.eb = function () { this.B = null; const e = Date.now(); 0 <= e - this.Y ? (function (e, t) { e.info(function () { return "TIMEOUT: " + t }) }(this.j, this.A), 2 != this.K && (mt(3), yt(17)), qt(this), this.o = 2, jt(this)) : Vt(this, this.Y - e) }, (f = Gt.prototype).R = function () { Wt(this); for (var e = [], t = 0; t < this.g.length; t++)e.push(this.h[this.g[t]]); return e }, f.T = function () { return Wt(this), this.g.concat() }, f.get = function (e, t) { return Yt(this.h, e) ? this.h[e] : t }, f.set = function (e, t) { Yt(this.h, e) || (this.i++, this.g.push(e)), this.h[e] = t }, f.forEach = function (e, t) { for (var n = this.T(), r = 0; r < n.length; r++) { var s = n[r], i = this.get(s); e.call(t, i, s, this) } }; var Kt = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/; function Xt(e, t) { if (this.i = this.s = this.j = "", this.m = null, this.o = this.l = "", this.g = !1, e instanceof Xt) { this.g = void 0 !== t ? t : e.g, Qt(this, e.j), this.s = e.s, Jt(this, e.i), en(this, e.m), this.l = e.l, t = e.h; var n = new fn; n.i = t.i, t.g && (n.g = new Gt(t.g), n.h = t.h), tn(this, n), this.o = e.o } else e && (n = String(e).match(Kt)) ? (this.g = !!t, Qt(this, n[1] || "", !0), this.s = sn(n[2] || ""), Jt(this, n[3] || "", !0), en(this, n[4]), this.l = sn(n[5] || "", !0), tn(this, n[6] || "", !0), this.o = sn(n[7] || "")) : (this.g = !!t, this.h = new fn(null, this.g)) } function Zt(e) { return new Xt(e) } function Qt(e, t, n) { e.j = n ? sn(t, !0) : t, e.j && (e.j = e.j.replace(/:$/, "")) } function Jt(e, t, n) { e.i = n ? sn(t, !0) : t } function en(e, t) { if (t) { if (t = Number(t), isNaN(t) || 0 > t) throw Error("Bad port number " + t); e.m = t } else e.m = null } function tn(e, t, n) { t instanceof fn ? (e.h = t, function (e, t) { t && !e.j && (pn(e), e.i = null, e.g.forEach(function (e, t) { var n = t.toLowerCase(); t != n && (mn(this, t), yn(this, n, e)) }, e)), e.j = t }(e.h, e.g)) : (n || (t = on(t, hn)), e.h = new fn(t, e.g)) } function nn(e, t, n) { e.h.set(t, n) } function rn(e) { return nn(e, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), e } function sn(e, t) { return e ? t ? decodeURI(e.replace(/%25/g, "%2525")) : decodeURIComponent(e) : "" } function on(e, t, n) { return "string" == typeof e ? (e = encodeURI(e).replace(t, an), n && (e = e.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), e) : null } function an(e) { return "%" + ((e = e.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & e).toString(16) } Xt.prototype.toString = function () { var e = [], t = this.j; t && e.push(on(t, cn, !0), ":"); var n = this.i; return (n || "file" == t) && (e.push("//"), (t = this.s) && e.push(on(t, cn, !0), "@"), e.push(encodeURIComponent(String(n)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (n = this.m) && e.push(":", String(n))), (n = this.l) && (this.i && "/" != n.charAt(0) && e.push("/"), e.push(on(n, "/" == n.charAt(0) ? un : ln, !0))), (n = this.h.toString()) && e.push("?", n), (n = this.o) && e.push("#", on(n, dn)), e.join("") }; var cn = /[#\/\?@]/g, ln = /[#\?:]/g, un = /[#\?]/g, hn = /[#\?@]/g, dn = /#/g; function fn(e, t) { this.h = this.g = null, this.i = e || null, this.j = !!t } function pn(e) { e.g || (e.g = new Gt, e.h = 0, e.i && function (e, t) { if (e) { e = e.split("&"); for (var n = 0; n < e.length; n++) { var r = e[n].indexOf("="), s = null; if (0 <= r) { var i = e[n].substring(0, r); s = e[n].substring(r + 1) } else i = e[n]; t(i, s ? decodeURIComponent(s.replace(/\+/g, " ")) : "") } } }(e.i, function (t, n) { e.add(decodeURIComponent(t.replace(/\+/g, " ")), n) })) } function mn(e, t) { pn(e), t = vn(e, t), Yt(e.g.h, t) && (e.i = null, e.h -= e.g.get(t).length, Yt((e = e.g).h, t) && (delete e.h[t], e.i--, e.g.length > 2 * e.i && Wt(e))) } function gn(e, t) { return pn(e), t = vn(e, t), Yt(e.g.h, t) } function yn(e, t, n) { mn(e, t), 0 < n.length && (e.i = null, e.g.set(vn(e, t), H(n)), e.h += n.length) } function vn(e, t) { return t = String(t), e.j && (t = t.toLowerCase()), t } function wn(e) { this.l = e || bn, e = x.PerformanceNavigationTiming ? 0 < (e = x.performance.getEntriesByType("navigation")).length && ("hq" == e[0].nextHopProtocol || "h2" == e[0].nextHopProtocol) : !!(x.g && x.g.Ea && x.g.Ea() && x.g.Ea().Zb), this.j = e ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = [] } (f = fn.prototype).add = function (e, t) { pn(this), this.i = null, e = vn(this, e); var n = this.g.get(e); return n || this.g.set(e, n = []), n.push(t), this.h += 1, this }, f.forEach = function (e, t) { pn(this), this.g.forEach(function (n, r) { q(n, function (n) { e.call(t, n, r, this) }, this) }, this) }, f.T = function () { pn(this); for (var e = this.g.R(), t = this.g.T(), n = [], r = 0; r < t.length; r++)for (var s = e[r], i = 0; i < s.length; i++)n.push(t[r]); return n }, f.R = function (e) { pn(this); var t = []; if ("string" == typeof e) gn(this, e) && (t = z(t, this.g.get(vn(this, e)))); else { e = this.g.R(); for (var n = 0; n < e.length; n++)t = z(t, e[n]) } return t }, f.set = function (e, t) { return pn(this), this.i = null, gn(this, e = vn(this, e)) && (this.h -= this.g.get(e).length), this.g.set(e, [t]), this.h += 1, this }, f.get = function (e, t) { return e && 0 < (e = this.R(e)).length ? String(e[0]) : t }, f.toString = function () { if (this.i) return this.i; if (!this.g) return ""; for (var e = [], t = this.g.T(), n = 0; n < t.length; n++) { var r = t[n], s = encodeURIComponent(String(r)); r = this.R(r); for (var i = 0; i < r.length; i++) { var o = s; "" !== r[i] && (o += "=" + encodeURIComponent(String(r[i]))), e.push(o) } } return this.i = e.join("&") }; var bn = 10; function _n(e) { return !!e.h || !!e.g && e.g.size >= e.j } function En(e) { return e.h ? 1 : e.g ? e.g.size : 0 } function Cn(e, t) { return e.h ? e.h == t : !!e.g && e.g.has(t) } function Sn(e, t) { e.g ? e.g.add(t) : e.h = t } function Tn(e, t) { e.h && e.h == t ? e.h = null : e.g && e.g.has(t) && e.g.delete(t) } function In(e) { if (null != e.h) return e.i.concat(e.h.D); if (null != e.g && 0 !== e.g.size) { let t = e.i; for (const n of e.g.values()) t = t.concat(n.D); return t } return H(e.i) } function kn() { } function An() { this.g = new kn } function xn(e, t, n) { const r = n || ""; try { Ht(e, function (e, n) { let s = e; R(e) && (s = ze(e)), t.push(r + n + "=" + encodeURIComponent(s)) }) } catch (s) { throw t.push(r + "type=" + encodeURIComponent("_badmap")), s } } function Dn(e, t, n, r, s) { try { t.onload = null, t.onerror = null, t.onabort = null, t.ontimeout = null, s(r) } catch (i) { } } function On(e) { this.l = e.$b || null, this.j = e.ib || !1 } function Rn(e, t) { Ue.call(this), this.D = e, this.u = t, this.m = void 0, this.readyState = Nn, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null } wn.prototype.cancel = function () { if (this.i = In(this), this.h) this.h.cancel(), this.h = null; else if (this.g && 0 !== this.g.size) { for (const e of this.g.values()) e.cancel(); this.g.clear() } }, kn.prototype.stringify = function (e) { return x.JSON.stringify(e, void 0) }, kn.prototype.parse = function (e) { return x.JSON.parse(e, void 0) }, B(On, Et), On.prototype.g = function () { return new Rn(this.l, this.j) }, On.prototype.i = function (e) { return function () { return e } }({}), B(Rn, Ue); var Nn = 0; function Pn(e) { e.j.read().then(e.Sa.bind(e)).catch(e.ha.bind(e)) } function Fn(e) { e.readyState = 4, e.l = null, e.j = null, e.A = null, Ln(e) } function Ln(e) { e.onreadystatechange && e.onreadystatechange.call(e) } (f = Rn.prototype).open = function (e, t) { if (this.readyState != Nn) throw this.abort(), Error("Error reopening a connection"); this.C = e, this.B = t, this.readyState = 1, Ln(this) }, f.send = function (e) { if (1 != this.readyState) throw this.abort(), Error("need to call open() first. "); this.g = !0; const t = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 }; e && (t.body = e), (this.D || x).fetch(new Request(this.B, t)).then(this.Va.bind(this), this.ha.bind(this)) }, f.abort = function () { this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted."), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = !1, Fn(this)), this.readyState = Nn }, f.Va = function (e) { if (this.g && (this.l = e, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = e.headers, this.readyState = 2, Ln(this)), this.g && (this.readyState = 3, Ln(this), this.g))) if ("arraybuffer" === this.responseType) e.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this)); else if (void 0 !== x.ReadableStream && "body" in e) { if (this.j = e.body.getReader(), this.u) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.A = new TextDecoder; Pn(this) } else e.text().then(this.Ua.bind(this), this.ha.bind(this)) }, f.Sa = function (e) { if (this.g) { if (this.u && e.value) this.response.push(e.value); else if (!this.u) { var t = e.value ? e.value : new Uint8Array(0); (t = this.A.decode(t, { stream: !e.done })) && (this.response = this.responseText += t) } e.done ? Fn(this) : Ln(this), 3 == this.readyState && Pn(this) } }, f.Ua = function (e) { this.g && (this.response = this.responseText = e, Fn(this)) }, f.Ta = function (e) { this.g && (this.response = e, Fn(this)) }, f.ha = function () { this.g && Fn(this) }, f.setRequestHeader = function (e, t) { this.v.append(e, t) }, f.getResponseHeader = function (e) { return this.h && this.h.get(e.toLowerCase()) || "" }, f.getAllResponseHeaders = function () { if (!this.h) return ""; const e = [], t = this.h.entries(); for (var n = t.next(); !n.done;)e.push((n = n.value)[0] + ": " + n[1]), n = t.next(); return e.join("\r\n") }, Object.defineProperty(Rn.prototype, "withCredentials", { get: function () { return "include" === this.m }, set: function (e) { this.m = e ? "include" : "same-origin" } }); var Mn = x.JSON.parse; function $n(e) { Ue.call(this), this.headers = new Gt, this.u = e || null, this.h = !1, this.C = this.g = null, this.H = "", this.m = 0, this.j = "", this.l = this.F = this.v = this.D = !1, this.B = 0, this.A = null, this.J = Bn, this.K = this.L = !1 } B($n, Ue); var Bn = "", Vn = /^https?$/i, Un = ["POST", "PUT"]; function jn(e) { return "content-type" == e.toLowerCase() } function qn(e, t) { e.h = !1, e.g && (e.l = !0, e.g.abort(), e.l = !1), e.j = t, e.m = 5, zn(e), Gn(e) } function zn(e) { e.D || (e.D = !0, je(e, "complete"), je(e, "error")) } function Hn(e) { if (e.h && void 0 !== A && (!e.C[1] || 4 != Yn(e) || 2 != e.ba())) if (e.v && 4 == Yn(e)) nt(e.Fa, 0, e); else if (je(e, "readystatechange"), 4 == Yn(e)) { e.h = !1; try { const c = e.ba(); e: switch (c) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var t = !0; break e; default: t = !1 }var n; if (!(n = t)) { var r; if (r = 0 === c) { var s = String(e.H).match(Kt)[1] || null; if (!s && x.self && x.self.location) { var i = x.self.location.protocol; s = i.substr(0, i.length - 1) } r = !Vn.test(s ? s.toLowerCase() : "") } n = r } if (n) je(e, "complete"), je(e, "success"); else { e.m = 6; try { var o = 2 < Yn(e) ? e.g.statusText : "" } catch (a) { o = "" } e.j = o + " [" + e.ba() + "]", zn(e) } } finally { Gn(e) } } } function Gn(e, t) { if (e.g) { Wn(e); const r = e.g, s = e.C[0] ? D : null; e.g = null, e.C = null, t || je(e, "ready"); try { r.onreadystatechange = s } catch (n) { } } } function Wn(e) { e.g && e.K && (e.g.ontimeout = null), e.A && (x.clearTimeout(e.A), e.A = null) } function Yn(e) { return e.g ? e.g.readyState : 0 } function Kn(e) { try { if (!e.g) return null; if ("response" in e.g) return e.g.response; switch (e.J) { case Bn: case "text": return e.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in e.g) return e.g.mozResponseArrayBuffer }return null } catch (t) { return null } } function Xn(e, t, n) { e: { for (r in n) { var r = !1; break e } r = !0 } r || (n = function (e) { let t = ""; return J(e, function (e, n) { t += n, t += ":", t += e, t += "\r\n" }), t }(n), "string" == typeof e ? null != n && encodeURIComponent(String(n)) : nn(e, t, n)) } function Zn(e, t, n) { return n && n.internalChannelParams && n.internalChannelParams[e] || t } function Qn(e) { this.za = 0, this.l = [], this.h = new lt, this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null, this.Za = this.V = 0, this.Xa = Zn("failFast", !1, e), this.N = this.v = this.u = this.m = this.j = null, this.X = !0, this.I = this.ta = this.U = -1, this.Y = this.A = this.C = 0, this.Pa = Zn("baseRetryDelayMs", 5e3, e), this.$a = Zn("retryDelaySeedMs", 1e4, e), this.Ya = Zn("forwardChannelMaxRetries", 2, e), this.ra = Zn("forwardChannelRequestTimeoutMs", 2e4, e), this.qa = e && e.xmlHttpFactory || void 0, this.Ba = e && e.Yb || !1, this.K = void 0, this.H = e && e.supportsCrossDomainXhr || !1, this.J = "", this.i = new wn(e && e.concurrentRequestLimit), this.Ca = new An, this.ja = e && e.fastHandshake || !1, this.Ra = e && e.Wb || !1, e && e.Aa && this.h.Aa(), e && e.forceLongPolling && (this.X = !1), this.$ = !this.ja && this.X && e && e.detectBufferingProxy || !1, this.ka = void 0, this.O = 0, this.L = !1, this.B = null, this.Wa = !e || !1 !== e.Xb } function Jn(e) { if (tr(e), 3 == e.G) { var t = e.V++, n = Zt(e.F); nn(n, "SID", e.J), nn(n, "RID", t), nn(n, "TYPE", "terminate"), ir(e, n), (t = new xt(e, e.h, t, void 0)).K = 2, t.v = rn(Zt(n)), n = !1, x.navigator && x.navigator.sendBeacon && (n = x.navigator.sendBeacon(t.v.toString(), "")), !n && x.Image && ((new Image).src = t.v, n = !0), n || (t.g = yr(t.l, null), t.g.ea(t.v)), t.F = Date.now(), Bt(t) } mr(e) } function er(e) { e.g && (lr(e), e.g.cancel(), e.g = null) } function tr(e) { er(e), e.u && (x.clearTimeout(e.u), e.u = null), hr(e), e.i.cancel(), e.m && ("number" == typeof e.m && x.clearTimeout(e.m), e.m = null) } function nr(e, t) { e.l.push(new class { constructor(e, t) { this.h = e, this.g = t } }(e.Za++, t)), 3 == e.G && rr(e) } function rr(e) { _n(e.i) || e.m || (e.m = !0, Xe(e.Ha, e), e.C = 0) } function sr(e, t) { var n; n = t ? t.m : e.V++; const r = Zt(e.F); nn(r, "SID", e.J), nn(r, "RID", n), nn(r, "AID", e.U), ir(e, r), e.o && e.s && Xn(r, e.o, e.s), n = new xt(e, e.h, n, e.C + 1), null === e.o && (n.H = e.s), t && (e.l = t.D.concat(e.l)), t = or(e, n, 1e3), n.setTimeout(Math.round(.5 * e.ra) + Math.round(.5 * e.ra * Math.random())), Sn(e.i, n), Pt(n, r, t) } function ir(e, t) { e.j && Ht({}, function (e, n) { nn(t, n, e) }) } function or(e, t, n) { n = Math.min(e.l.length, n); var r = e.j ? M(e.j.Oa, e.j, e) : null; e: { var s = e.l; let t = -1; for (; ;) { const e = ["count=" + n]; -1 == t ? 0 < n ? (t = s[0].h, e.push("ofs=" + t)) : t = 0 : e.push("ofs=" + t); let i = !0; for (let o = 0; o < n; o++) { let n = s[o].h; const a = s[o].g; if (n -= t, 0 > n) t = Math.max(0, s[o].h - 100), i = !1; else try { xn(a, e, "req" + n + "_") } catch (Hr) { r && r(a) } } if (i) { r = e.join("&"); break e } } } return e = e.l.splice(0, n), t.D = e, r } function ar(e) { e.g || e.u || (e.Y = 1, Xe(e.Ga, e), e.A = 0) } function cr(e) { return !(e.g || e.u || 3 <= e.A || (e.Y++, e.u = wt(M(e.Ga, e), fr(e, e.A)), e.A++, 0)) } function lr(e) { null != e.B && (x.clearTimeout(e.B), e.B = null) } function ur(e) { e.g = new xt(e, e.h, "rpc", e.Y), null === e.o && (e.g.H = e.s), e.g.O = 0; var t = Zt(e.oa); nn(t, "RID", "rpc"), nn(t, "SID", e.J), nn(t, "CI", e.N ? "0" : "1"), nn(t, "AID", e.U), ir(e, t), nn(t, "TYPE", "xmlhttp"), e.o && e.s && Xn(t, e.o, e.s), e.K && e.g.setTimeout(e.K); var n = e.g; e = e.la, n.K = 1, n.v = rn(Zt(t)), n.s = null, n.U = !0, Ft(n, e) } function hr(e) { null != e.v && (x.clearTimeout(e.v), e.v = null) } function dr(e, t) { var n = null; if (e.g == t) { hr(e), lr(e), e.g = null; var r = 2 } else { if (!Cn(e.i, t)) return; n = t.D, Tn(e.i, t), r = 1 } if (e.I = t.N, 0 != e.G) if (t.i) if (1 == r) { n = t.s ? t.s.length : 0, t = Date.now() - t.F; var s = e.C; je(r = ft(), new vt(r, n, t, s)), rr(e) } else ar(e); else if (3 == (s = t.o) || 0 == s && 0 < e.I || !(1 == r && function (e, t) { return !(En(e.i) >= e.i.j - (e.m ? 1 : 0) || (e.m ? (e.l = t.D.concat(e.l), 0) : 1 == e.G || 2 == e.G || e.C >= (e.Xa ? 0 : e.Ya) || (e.m = wt(M(e.Ha, e, t), fr(e, e.C)), e.C++, 0))) }(e, t) || 2 == r && cr(e))) switch (n && 0 < n.length && (t = e.i, t.i = t.i.concat(n)), s) { case 1: pr(e, 5); break; case 4: pr(e, 10); break; case 3: pr(e, 6); break; default: pr(e, 2) } } function fr(e, t) { let n = e.Pa + Math.floor(Math.random() * e.$a); return e.j || (n *= 2), n * t } function pr(e, t) { if (e.h.info("Error code " + t), 2 == t) { var n = null; e.j && (n = null); var r = M(e.jb, e); n || (n = new Xt("//www.google.com/images/cleardot.gif"), x.location && "http" == x.location.protocol || Qt(n, "https"), rn(n)), function (e, t) { const n = new lt; if (x.Image) { const r = new Image; r.onload = $(Dn, n, r, "TestLoadImage: loaded", !0, t), r.onerror = $(Dn, n, r, "TestLoadImage: error", !1, t), r.onabort = $(Dn, n, r, "TestLoadImage: abort", !1, t), r.ontimeout = $(Dn, n, r, "TestLoadImage: timeout", !1, t), x.setTimeout(function () { r.ontimeout && r.ontimeout() }, 1e4), r.src = e } else t(!1) }(n.toString(), r) } else yt(2); e.G = 0, e.j && e.j.va(t), mr(e), tr(e) } function mr(e) { e.G = 0, e.I = -1, e.j && (0 == In(e.i).length && 0 == e.l.length || (e.i.i.length = 0, H(e.l), e.l.length = 0), e.j.ua()) } function gr(e, t, n) { let r = function (e) { return e instanceof Xt ? Zt(e) : new Xt(e, void 0) }(n); if ("" != r.i) t && Jt(r, t + "." + r.i), en(r, r.m); else { const e = x.location; r = function (e, t, n, r) { var s = new Xt(null, void 0); return e && Qt(s, e), t && Jt(s, t), n && en(s, n), r && (s.l = r), s }(e.protocol, t ? t + "." + e.hostname : e.hostname, +e.port, n) } return e.aa && J(e.aa, function (e, t) { nn(r, t, e) }), n = e.sa, (t = e.D) && n && nn(r, t, n), nn(r, "VER", e.ma), ir(e, r), r } function yr(e, t, n) { if (t && !e.H) throw Error("Can't create secondary domain capable XhrIo object."); return (t = new $n(n && e.Ba && !e.qa ? new On({ ib: !0 }) : e.qa)).L = e.H, t } function vr() { } function wr() { if (ae && !(10 <= Number(ye))) throw Error("Environmental error: no available transport.") } function br(e, t) { Ue.call(this), this.g = new Qn(t), this.l = e, this.h = t && t.messageUrlParams || null, e = t && t.messageHeaders || null, t && t.clientProtocolHeaderRequired && (e ? e["X-Client-Protocol"] = "webchannel" : e = { "X-Client-Protocol": "webchannel" }), this.g.s = e, e = t && t.initMessageHeaders || null, t && t.messageContentType && (e ? e["X-WebChannel-Content-Type"] = t.messageContentType : e = { "X-WebChannel-Content-Type": t.messageContentType }), t && t.ya && (e ? e["X-WebChannel-Client-Profile"] = t.ya : e = { "X-WebChannel-Client-Profile": t.ya }), this.g.P = e, (e = t && t.httpHeadersOverwriteParam) && !G(e) && (this.g.o = e), this.A = t && t.supportsCrossDomainXhr || !1, this.v = t && t.sendRawJson || !1, (t = t && t.httpSessionIdParam) && !G(t) && (this.g.D = t, null !== (e = this.h) && t in e && t in (e = this.h) && delete e[t]), this.j = new Cr(this) } function _r(e) { It.call(this); var t = e.__sm__; if (t) { e: { for (const n in t) { e = n; break e } e = void 0 } (this.i = e) && (e = this.i, t = null !== t && e in t ? t[e] : void 0), this.data = t } else this.data = e } function Er() { kt.call(this), this.status = 1 } function Cr(e) { this.g = e } (f = $n.prototype).ea = function (e, t, n, r) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + e); t = t ? t.toUpperCase() : "GET", this.H = e, this.j = "", this.m = 0, this.D = !1, this.h = !0, this.g = this.u ? this.u.g() : St.g(), this.C = function (e) { return e.h || (e.h = e.i()) }(this.u ? this.u : St), this.g.onreadystatechange = M(this.Fa, this); try { this.F = !0, this.g.open(t, String(e), !0), this.F = !1 } catch (i) { return void qn(this, i) } e = n || ""; const s = new Gt(this.headers); r && Ht(r, function (e, t) { s.set(t, e) }), r = function (e) { e: { var t = jn; const n = e.length, r = "string" == typeof e ? e.split("") : e; for (let s = 0; s < n; s++)if (s in r && t.call(void 0, r[s], s, e)) { t = s; break e } t = -1 } return 0 > t ? null : "string" == typeof e ? e.charAt(t) : e[t] }(s.T()), n = x.FormData && e instanceof x.FormData, !(0 <= j(Un, t)) || r || n || s.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"), s.forEach(function (e, t) { this.g.setRequestHeader(t, e) }, this), this.J && (this.g.responseType = this.J), "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L); try { Wn(this), 0 < this.B && ((this.K = function (e) { return ae && function () { return e = ge, Object.prototype.hasOwnProperty.call(e, 9) ? e[9] : e[9] = function () { let e = 0; const t = Y(String(se)).split("."), n = Y("9").split("."), r = Math.max(t.length, n.length); for (let o = 0; 0 == e && o < r; o++) { var s = t[o] || "", i = n[o] || ""; do { if (s = /(\d*)(\D*)(.*)/.exec(s) || ["", "", "", ""], i = /(\d*)(\D*)(.*)/.exec(i) || ["", "", "", ""], 0 == s[0].length && 0 == i[0].length) break; e = X(0 == s[1].length ? 0 : parseInt(s[1], 10), 0 == i[1].length ? 0 : parseInt(i[1], 10)) || X(0 == s[2].length, 0 == i[2].length) || X(s[2], i[2]), s = s[3], i = i[3] } while (0 == e) } return 0 <= e }(); var e }() && "number" == typeof e.timeout && void 0 !== e.ontimeout }(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = M(this.pa, this)) : this.A = nt(this.pa, this.B, this)), this.v = !0, this.g.send(e), this.v = !1 } catch (i) { qn(this, i) } }, f.pa = function () { void 0 !== A && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, je(this, "timeout"), this.abort(8)) }, f.abort = function (e) { this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = e || 7, je(this, "complete"), je(this, "abort"), Gn(this)) }, f.M = function () { this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), Gn(this, !0)), $n.Z.M.call(this) }, f.Fa = function () { this.s || (this.F || this.v || this.l ? Hn(this) : this.cb()) }, f.cb = function () { Hn(this) }, f.ba = function () { try { return 2 < Yn(this) ? this.g.status : -1 } catch (ie) { return -1 } }, f.ga = function () { try { return this.g ? this.g.responseText : "" } catch (ie) { return "" } }, f.Qa = function (e) { if (this.g) { var t = this.g.responseText; return e && 0 == t.indexOf(e) && (t = t.substring(e.length)), Mn(t) } }, f.Da = function () { return this.m }, f.La = function () { return "string" == typeof this.j ? this.j : String(this.j) }, (f = Qn.prototype).ma = 8, f.G = 1, f.hb = function (e) { try { this.h.info("Origin Trials invoked: " + e) } catch (t) { } }, f.Ha = function (e) { if (this.m) if (this.m = null, 1 == this.G) { if (!e) { this.V = Math.floor(1e5 * Math.random()), e = this.V++; const s = new xt(this, this.h, e, void 0); let i = this.s; if (this.P && (i ? (i = ee(i), ne(i, this.P)) : i = this.P), null === this.o && (s.H = i), this.ja) e: { for (var t = 0, n = 0; n < this.l.length; n++) { var r = this.l[n]; if (void 0 === (r = "__data__" in r.g && "string" == typeof (r = r.g.__data__) ? r.length : void 0)) break; if (4096 < (t += r)) { t = n; break e } if (4096 === t || n === this.l.length - 1) { t = n + 1; break e } } t = 1e3 } else t = 1e3; t = or(this, s, t), nn(n = Zt(this.F), "RID", e), nn(n, "CVER", 22), this.D && nn(n, "X-HTTP-Session-Id", this.D), ir(this, n), this.o && i && Xn(n, this.o, i), Sn(this.i, s), this.Ra && nn(n, "TYPE", "init"), this.ja ? (nn(n, "$req", t), nn(n, "SID", "null"), s.$ = !0, Pt(s, n, null)) : Pt(s, n, t), this.G = 2 } } else 3 == this.G && (e ? sr(this, e) : 0 == this.l.length || _n(this.i) || sr(this)) }, f.Ga = function () { if (this.u = null, ur(this), this.$ && !(this.L || null == this.g || 0 >= this.O)) { var e = 2 * this.O; this.h.info("BP detection timer enabled: " + e), this.B = wt(M(this.bb, this), e) } }, f.bb = function () { this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = !1, this.L = !0, yt(10), er(this), ur(this)) }, f.ab = function () { null != this.v && (this.v = null, er(this), cr(this), yt(19)) }, f.jb = function (e) { e ? (this.h.info("Successfully pinged google.com"), yt(2)) : (this.h.info("Failed to ping google.com"), yt(1)) }, (f = vr.prototype).xa = function () { }, f.wa = function () { }, f.va = function () { }, f.ua = function () { }, f.Oa = function () { }, wr.prototype.g = function (e, t) { return new br(e, t) }, B(br, Ue), br.prototype.m = function () { this.g.j = this.j, this.A && (this.g.H = !0); var e = this.g, t = this.l, n = this.h || void 0; e.Wa && (e.h.info("Origin Trials enabled."), Xe(M(e.hb, e, t))), yt(0), e.W = t, e.aa = n || {}, e.N = e.X, e.F = gr(e, null, e.W), rr(e) }, br.prototype.close = function () { Jn(this.g) }, br.prototype.u = function (e) { if ("string" == typeof e) { var t = {}; t.__data__ = e, nr(this.g, t) } else this.v ? ((t = {}).__data__ = ze(e), nr(this.g, t)) : nr(this.g, e) }, br.prototype.M = function () { this.g.j = null, delete this.j, Jn(this.g), delete this.g, br.Z.M.call(this) }, B(_r, It), B(Er, kt), B(Cr, vr), Cr.prototype.xa = function () { je(this.g, "a") }, Cr.prototype.wa = function (e) { je(this.g, new _r(e)) }, Cr.prototype.va = function (e) { je(this.g, new Er(e)) }, Cr.prototype.ua = function () { je(this.g, "b") }, wr.prototype.createWebChannel = wr.prototype.g, br.prototype.send = br.prototype.u, br.prototype.open = br.prototype.m, br.prototype.close = br.prototype.close, bt.NO_ERROR = 0, bt.TIMEOUT = 8, bt.HTTP_ERROR = 6, _t.COMPLETE = "complete", Ct.EventType = Tt, Tt.OPEN = "a", Tt.CLOSE = "b", Tt.ERROR = "c", Tt.MESSAGE = "d", Ue.prototype.listen = Ue.prototype.N, $n.prototype.listenOnce = $n.prototype.O, $n.prototype.getLastError = $n.prototype.La, $n.prototype.getLastErrorCode = $n.prototype.Da, $n.prototype.getStatus = $n.prototype.ba, $n.prototype.getResponseJson = $n.prototype.Qa, $n.prototype.getResponseText = $n.prototype.ga, $n.prototype.send = $n.prototype.ea; var Sr = k.createWebChannelTransport = function () { return new wr }, Tr = k.getStatEventTarget = function () { return ft() }, Ir = k.ErrorCode = bt, kr = k.EventType = _t, Ar = k.Event = ht, xr = k.Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 }, Dr = k.FetchXmlHttpFactory = On, Or = k.WebChannel = Ct, Rr = k.XhrIo = $n; const Nr = "@firebase/firestore"; class Pr { constructor(e) { this.uid = e } isAuthenticated() { return null != this.uid } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(e) { return e.uid === this.uid } } Pr.UNAUTHENTICATED = new Pr(null), Pr.GOOGLE_CREDENTIALS = new Pr("google-credentials-uid"), Pr.FIRST_PARTY = new Pr("first-party-uid"), Pr.MOCK_USER = new Pr("mock-user"); let Fr = "9.6.9"; const Lr = new S.Yd("@firebase/firestore"); function Mr() { return Lr.logLevel } function $r(e, ...t) { if (Lr.logLevel <= S.in.DEBUG) { const n = t.map(Ur); Lr.debug(`Firestore (${Fr}): ${e}`, ...n) } } function Br(e, ...t) { if (Lr.logLevel <= S.in.ERROR) { const n = t.map(Ur); Lr.error(`Firestore (${Fr}): ${e}`, ...n) } } function Vr(e, ...t) { if (Lr.logLevel <= S.in.WARN) { const n = t.map(Ur); Lr.warn(`Firestore (${Fr}): ${e}`, ...n) } } function Ur(e) { if ("string" == typeof e) return e; try { return JSON.stringify(e) } catch (t) { return e } } function jr(e = "Unexpected state") { const t = `FIRESTORE (${Fr}) INTERNAL ASSERTION FAILED: ` + e; throw Br(t), new Error(t) } function qr(e, t) { e || jr() } function zr(e, t) { return e } const Hr = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class Gr extends T.ZR { constructor(e, t) { super(e, t), this.code = e, this.message = t, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}` } } class Wr { constructor() { this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } } class Yr { constructor(e, t) { this.user = t, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${e}`) } } class Kr { getToken() { return Promise.resolve(null) } invalidateToken() { } start(e, t) { e.enqueueRetryable(() => t(Pr.UNAUTHENTICATED)) } shutdown() { } } class Xr { constructor(e) { this.token = e, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(e, t) { this.changeListener = t, e.enqueueRetryable(() => t(this.token.user)) } shutdown() { this.changeListener = null } } class Zr { constructor(e) { this.t = e, this.currentUser = Pr.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(e, t) { let n = this.i; const r = e => this.i !== n ? (n = this.i, t(e)) : Promise.resolve(); let s = new Wr; this.o = () => { this.i++, this.currentUser = this.u(), s.resolve(), s = new Wr, e.enqueueRetryable(() => r(this.currentUser)) }; const i = () => { const t = s; e.enqueueRetryable(async () => { await t.promise, await r(this.currentUser) }) }, o = e => { $r("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = e, this.auth.addAuthTokenListener(this.o), i() }; this.t.onInit(e => o(e)), setTimeout(() => { if (!this.auth) { const e = this.t.getImmediate({ optional: !0 }); e ? o(e) : ($r("FirebaseAuthCredentialsProvider", "Auth not yet detected"), s.resolve(), s = new Wr) } }, 0), i() } getToken() { const e = this.i, t = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then(t => this.i !== e ? ($r("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : t ? (qr("string" == typeof t.accessToken), new Yr(t.accessToken, this.currentUser)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.auth.removeAuthTokenListener(this.o) } u() { const e = this.auth && this.auth.getUid(); return qr(null === e || "string" == typeof e), new Pr(e) } } class Qr { constructor(e, t, n) { this.type = "FirstParty", this.user = Pr.FIRST_PARTY, this.headers = new Map, this.headers.set("X-Goog-AuthUser", t); const r = e.auth.getAuthHeaderValueForFirstParty([]); r && this.headers.set("Authorization", r), n && this.headers.set("X-Goog-Iam-Authorization-Token", n) } } class Jr { constructor(e, t, n) { this.h = e, this.l = t, this.m = n } getToken() { return Promise.resolve(new Qr(this.h, this.l, this.m)) } start(e, t) { e.enqueueRetryable(() => t(Pr.FIRST_PARTY)) } shutdown() { } invalidateToken() { } } class es { constructor(e) { this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class ts { constructor(e) { this.g = e, this.forceRefresh = !1, this.appCheck = null, this.p = null } start(e, t) { const n = e => { null != e.error && $r("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${e.error.message}`); const n = e.token !== this.p; return this.p = e.token, $r("FirebaseAppCheckTokenProvider", `Received ${n ? "new" : "existing"} token.`), n ? t(e.token) : Promise.resolve() }; this.o = t => { e.enqueueRetryable(() => n(t)) }; const r = e => { $r("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = e, this.appCheck.addTokenListener(this.o) }; this.g.onInit(e => r(e)), setTimeout(() => { if (!this.appCheck) { const e = this.g.getImmediate({ optional: !0 }); e ? r(e) : $r("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }, 0) } getToken() { const e = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then(e => e ? (qr("string" == typeof e.token), this.p = e.token, new es(e.token)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.appCheck.removeTokenListener(this.o) } } class ns { constructor(e, t) { this.previousValue = e, t && (t.sequenceNumberHandler = e => this.I(e), this.T = e => t.writeSequenceNumber(e)) } I(e) { return this.previousValue = Math.max(e, this.previousValue), this.previousValue } next() { const e = ++this.previousValue; return this.T && this.T(e), e } } function rs(e) { const t = "undefined" != typeof self && (self.crypto || self.msCrypto), n = new Uint8Array(e); if (t && "function" == typeof t.getRandomValues) t.getRandomValues(n); else for (let r = 0; r < e; r++)n[r] = Math.floor(256 * Math.random()); return n } ns.A = -1; class ss { static R() { const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = Math.floor(256 / e.length) * e.length; let n = ""; for (; n.length < 20;) { const r = rs(40); for (let s = 0; s < r.length; ++s)n.length < 20 && r[s] < t && (n += e.charAt(r[s] % e.length)) } return n } } function is(e, t) { return e < t ? -1 : e > t ? 1 : 0 } function os(e, t, n) { return e.length === t.length && e.every((e, r) => n(e, t[r])) } function as(e) { return e + "\0" } class cs { constructor(e, t) { if (this.seconds = e, this.nanoseconds = t, t < 0) throw new Gr(Hr.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (t >= 1e9) throw new Gr(Hr.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (e < -62135596800) throw new Gr(Hr.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e); if (e >= 253402300800) throw new Gr(Hr.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e) } static now() { return cs.fromMillis(Date.now()) } static fromDate(e) { return cs.fromMillis(e.getTime()) } static fromMillis(e) { const t = Math.floor(e / 1e3), n = Math.floor(1e6 * (e - 1e3 * t)); return new cs(t, n) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / 1e6 } _compareTo(e) { return this.seconds === e.seconds ? is(this.nanoseconds, e.nanoseconds) : is(this.seconds, e.seconds) } isEqual(e) { return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { seconds: this.seconds, nanoseconds: this.nanoseconds } } valueOf() { return String(this.seconds - -62135596800).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } } class ls { constructor(e) { this.timestamp = e } static fromTimestamp(e) { return new ls(e) } static min() { return new ls(new cs(0, 0)) } compareTo(e) { return this.timestamp._compareTo(e.timestamp) } isEqual(e) { return this.timestamp.isEqual(e.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } } function us(e) { let t = 0; for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t++; return t } function hs(e, t) { for (const n in e) Object.prototype.hasOwnProperty.call(e, n) && t(n, e[n]) } function ds(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } class fs { constructor(e, t, n) { void 0 === t ? t = 0 : t > e.length && jr(), void 0 === n ? n = e.length - t : n > e.length - t && jr(), this.segments = e, this.offset = t, this.len = n } get length() { return this.len } isEqual(e) { return 0 === fs.comparator(this, e) } child(e) { const t = this.segments.slice(this.offset, this.limit()); return e instanceof fs ? e.forEach(e => { t.push(e) }) : t.push(e), this.construct(t) } limit() { return this.offset + this.length } popFirst(e) { return this.construct(this.segments, this.offset + (e = void 0 === e ? 1 : e), this.length - e) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(e) { return this.segments[this.offset + e] } isEmpty() { return 0 === this.length } isPrefixOf(e) { if (e.length < this.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } isImmediateParentOf(e) { if (this.length + 1 !== e.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } forEach(e) { for (let t = this.offset, n = this.limit(); t < n; t++)e(this.segments[t]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(e, t) { const n = Math.min(e.length, t.length); for (let r = 0; r < n; r++) { const n = e.get(r), s = t.get(r); if (n < s) return -1; if (n > s) return 1 } return e.length < t.length ? -1 : e.length > t.length ? 1 : 0 } } class ps extends fs { construct(e, t, n) { return new ps(e, t, n) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } static fromString(...e) { const t = []; for (const n of e) { if (n.indexOf("//") >= 0) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`); t.push(...n.split("/").filter(e => e.length > 0)) } return new ps(t) } static emptyPath() { return new ps([]) } } const ms = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class gs extends fs { construct(e, t, n) { return new gs(e, t, n) } static isValidIdentifier(e) { return ms.test(e) } canonicalString() { return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), gs.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".") } toString() { return this.canonicalString() } isKeyField() { return 1 === this.length && "__name__" === this.get(0) } static keyField() { return new gs(["__name__"]) } static fromServerFormat(e) { const t = []; let n = "", r = 0; const s = () => { if (0 === n.length) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`); t.push(n), n = "" }; let i = !1; for (; r < e.length;) { const t = e[r]; if ("\\" === t) { if (r + 1 === e.length) throw new Gr(Hr.INVALID_ARGUMENT, "Path has trailing escape character: " + e); const t = e[r + 1]; if ("\\" !== t && "." !== t && "`" !== t) throw new Gr(Hr.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e); n += t, r += 2 } else "`" === t ? (i = !i, r++) : "." !== t || i ? (n += t, r++) : (s(), r++) } if (s(), i) throw new Gr(Hr.INVALID_ARGUMENT, "Unterminated ` in path: " + e); return new gs(t) } static emptyPath() { return new gs([]) } } class ys { constructor(e) { this.fields = e, e.sort(gs.comparator) } covers(e) { for (const t of this.fields) if (t.isPrefixOf(e)) return !0; return !1 } isEqual(e) { return os(this.fields, e.fields, (e, t) => e.isEqual(t)) } } class vs { constructor(e) { this.binaryString = e } static fromBase64String(e) { const t = atob(e); return new vs(t) } static fromUint8Array(e) { const t = function (e) { let t = ""; for (let n = 0; n < e.length; ++n)t += String.fromCharCode(e[n]); return t }(e); return new vs(t) } [Symbol.iterator]() { let e = 0; return { next: () => e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return btoa(this.binaryString) } toUint8Array() { return function (e) { const t = new Uint8Array(e.length); for (let n = 0; n < e.length; n++)t[n] = e.charCodeAt(n); return t }(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(e) { return is(this.binaryString, e.binaryString) } isEqual(e) { return this.binaryString === e.binaryString } } vs.EMPTY_BYTE_STRING = new vs(""); const ws = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function bs(e) { if (qr(!!e), "string" == typeof e) { let t = 0; const n = ws.exec(e); if (qr(!!n), n[1]) { let e = n[1]; e = (e + "000000000").substr(0, 9), t = Number(e) } const r = new Date(e); return { seconds: Math.floor(r.getTime() / 1e3), nanos: t } } return { seconds: _s(e.seconds), nanos: _s(e.nanos) } } function _s(e) { return "number" == typeof e ? e : "string" == typeof e ? Number(e) : 0 } function Es(e) { return "string" == typeof e ? vs.fromBase64String(e) : vs.fromUint8Array(e) } function Cs(e) { var t, n; return "server_timestamp" === (null === (n = ((null === (t = null == e ? void 0 : e.mapValue) || void 0 === t ? void 0 : t.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue) } function Ss(e) { const t = e.mapValue.fields.__previous_value__; return Cs(t) ? Ss(t) : t } function Ts(e) { const t = bs(e.mapValue.fields.__local_write_time__.timestampValue); return new cs(t.seconds, t.nanos) } class Is { constructor(e, t, n, r, s, i, o, a) { this.databaseId = e, this.appId = t, this.persistenceKey = n, this.host = r, this.ssl = s, this.forceLongPolling = i, this.autoDetectLongPolling = o, this.useFetchStreams = a } } class ks { constructor(e, t) { this.projectId = e, this.database = t || "(default)" } static empty() { return new ks("", "") } get isDefaultDatabase() { return "(default)" === this.database } isEqual(e) { return e instanceof ks && e.projectId === this.projectId && e.database === this.database } } function As(e) { return null == e } function xs(e) { return 0 === e && 1 / e == -1 / 0 } function Ds(e) { return "number" == typeof e && Number.isInteger(e) && !xs(e) && e <= Number.MAX_SAFE_INTEGER && e >= Number.MIN_SAFE_INTEGER } class Os { constructor(e) { this.path = e } static fromPath(e) { return new Os(ps.fromString(e)) } static fromName(e) { return new Os(ps.fromString(e).popFirst(5)) } static empty() { return new Os(ps.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(e) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === e } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(e) { return null !== e && 0 === ps.comparator(this.path, e.path) } toString() { return this.path.toString() } static comparator(e, t) { return ps.comparator(e.path, t.path) } static isDocumentKey(e) { return e.length % 2 == 0 } static fromSegments(e) { return new Os(new ps(e.slice())) } } const Rs = { mapValue: { fields: { __type__: { stringValue: "__max__" } } } }, Ns = { nullValue: "NULL_VALUE" }; function Ps(e) { return "nullValue" in e ? 0 : "booleanValue" in e ? 1 : "integerValue" in e || "doubleValue" in e ? 2 : "timestampValue" in e ? 3 : "stringValue" in e ? 5 : "bytesValue" in e ? 6 : "referenceValue" in e ? 7 : "geoPointValue" in e ? 8 : "arrayValue" in e ? 9 : "mapValue" in e ? Cs(e) ? 4 : Ys(e) ? 9 : 10 : jr() } function Fs(e, t) { if (e === t) return !0; const n = Ps(e); if (n !== Ps(t)) return !1; switch (n) { case 0: case 9007199254740991: return !0; case 1: return e.booleanValue === t.booleanValue; case 4: return Ts(e).isEqual(Ts(t)); case 3: return function (e, t) { if ("string" == typeof e.timestampValue && "string" == typeof t.timestampValue && e.timestampValue.length === t.timestampValue.length) return e.timestampValue === t.timestampValue; const n = bs(e.timestampValue), r = bs(t.timestampValue); return n.seconds === r.seconds && n.nanos === r.nanos }(e, t); case 5: return e.stringValue === t.stringValue; case 6: return function (e, t) { return Es(e.bytesValue).isEqual(Es(t.bytesValue)) }(e, t); case 7: return e.referenceValue === t.referenceValue; case 8: return function (e, t) { return _s(e.geoPointValue.latitude) === _s(t.geoPointValue.latitude) && _s(e.geoPointValue.longitude) === _s(t.geoPointValue.longitude) }(e, t); case 2: return function (e, t) { if ("integerValue" in e && "integerValue" in t) return _s(e.integerValue) === _s(t.integerValue); if ("doubleValue" in e && "doubleValue" in t) { const n = _s(e.doubleValue), r = _s(t.doubleValue); return n === r ? xs(n) === xs(r) : isNaN(n) && isNaN(r) } return !1 }(e, t); case 9: return os(e.arrayValue.values || [], t.arrayValue.values || [], Fs); case 10: return function (e, t) { const n = e.mapValue.fields || {}, r = t.mapValue.fields || {}; if (us(n) !== us(r)) return !1; for (const s in n) if (n.hasOwnProperty(s) && (void 0 === r[s] || !Fs(n[s], r[s]))) return !1; return !0 }(e, t); default: return jr() } } function Ls(e, t) { return void 0 !== (e.values || []).find(e => Fs(e, t)) } function Ms(e, t) { if (e === t) return 0; const n = Ps(e), r = Ps(t); if (n !== r) return is(n, r); switch (n) { case 0: case 9007199254740991: return 0; case 1: return is(e.booleanValue, t.booleanValue); case 2: return function (e, t) { const n = _s(e.integerValue || e.doubleValue), r = _s(t.integerValue || t.doubleValue); return n < r ? -1 : n > r ? 1 : n === r ? 0 : isNaN(n) ? isNaN(r) ? 0 : -1 : 1 }(e, t); case 3: return $s(e.timestampValue, t.timestampValue); case 4: return $s(Ts(e), Ts(t)); case 5: return is(e.stringValue, t.stringValue); case 6: return function (e, t) { const n = Es(e), r = Es(t); return n.compareTo(r) }(e.bytesValue, t.bytesValue); case 7: return function (e, t) { const n = e.split("/"), r = t.split("/"); for (let s = 0; s < n.length && s < r.length; s++) { const e = is(n[s], r[s]); if (0 !== e) return e } return is(n.length, r.length) }(e.referenceValue, t.referenceValue); case 8: return function (e, t) { const n = is(_s(e.latitude), _s(t.latitude)); return 0 !== n ? n : is(_s(e.longitude), _s(t.longitude)) }(e.geoPointValue, t.geoPointValue); case 9: return function (e, t) { const n = e.values || [], r = t.values || []; for (let s = 0; s < n.length && s < r.length; ++s) { const e = Ms(n[s], r[s]); if (e) return e } return is(n.length, r.length) }(e.arrayValue, t.arrayValue); case 10: return function (e, t) { const n = e.fields || {}, r = Object.keys(n), s = t.fields || {}, i = Object.keys(s); r.sort(), i.sort(); for (let o = 0; o < r.length && o < i.length; ++o) { const e = is(r[o], i[o]); if (0 !== e) return e; const t = Ms(n[r[o]], s[i[o]]); if (0 !== t) return t } return is(r.length, i.length) }(e.mapValue, t.mapValue); default: throw jr() } } function $s(e, t) { if ("string" == typeof e && "string" == typeof t && e.length === t.length) return is(e, t); const n = bs(e), r = bs(t), s = is(n.seconds, r.seconds); return 0 !== s ? s : is(n.nanos, r.nanos) } function Bs(e) { return Vs(e) } function Vs(e) { return "nullValue" in e ? "null" : "booleanValue" in e ? "" + e.booleanValue : "integerValue" in e ? "" + e.integerValue : "doubleValue" in e ? "" + e.doubleValue : "timestampValue" in e ? function (e) { const t = bs(e); return `time(${t.seconds},${t.nanos})` }(e.timestampValue) : "stringValue" in e ? e.stringValue : "bytesValue" in e ? Es(e.bytesValue).toBase64() : "referenceValue" in e ? Os.fromName(e.referenceValue).toString() : "geoPointValue" in e ? `geo(${(t = e.geoPointValue).latitude},${t.longitude})` : "arrayValue" in e ? function (e) { let t = "[", n = !0; for (const r of e.values || []) n ? n = !1 : t += ",", t += Vs(r); return t + "]" }(e.arrayValue) : "mapValue" in e ? function (e) { const t = Object.keys(e.fields || {}).sort(); let n = "{", r = !0; for (const s of t) r ? r = !1 : n += ",", n += `${s}:${Vs(e.fields[s])}`; return n + "}" }(e.mapValue) : jr(); var t } function Us(e, t) { return { referenceValue: `projects/${e.projectId}/databases/${e.database}/documents/${t.path.canonicalString()}` } } function js(e) { return !!e && "integerValue" in e } function qs(e) { return !!e && "arrayValue" in e } function zs(e) { return !!e && "nullValue" in e } function Hs(e) { return !!e && "doubleValue" in e && isNaN(Number(e.doubleValue)) } function Gs(e) { return !!e && "mapValue" in e } function Ws(e) { if (e.geoPointValue) return { geoPointValue: Object.assign({}, e.geoPointValue) }; if (e.timestampValue && "object" == typeof e.timestampValue) return { timestampValue: Object.assign({}, e.timestampValue) }; if (e.mapValue) { const t = { mapValue: { fields: {} } }; return hs(e.mapValue.fields, (e, n) => t.mapValue.fields[e] = Ws(n)), t } if (e.arrayValue) { const t = { arrayValue: { values: [] } }; for (let n = 0; n < (e.arrayValue.values || []).length; ++n)t.arrayValue.values[n] = Ws(e.arrayValue.values[n]); return t } return Object.assign({}, e) } function Ys(e) { return "__max__" === (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue } function Ks(e, t) { return void 0 === e ? t : void 0 === t || Ms(e, t) > 0 ? e : t } function Xs(e, t) { return void 0 === e ? t : void 0 === t || Ms(e, t) < 0 ? e : t } class Zs { constructor(e) { this.value = e } static empty() { return new Zs({ mapValue: {} }) } field(e) { if (e.isEmpty()) return this.value; { let t = this.value; for (let n = 0; n < e.length - 1; ++n)if (t = (t.mapValue.fields || {})[e.get(n)], !Gs(t)) return null; return t = (t.mapValue.fields || {})[e.lastSegment()], t || null } } set(e, t) { this.getFieldsMap(e.popLast())[e.lastSegment()] = Ws(t) } setAll(e) { let t = gs.emptyPath(), n = {}, r = []; e.forEach((e, s) => { if (!t.isImmediateParentOf(s)) { const e = this.getFieldsMap(t); this.applyChanges(e, n, r), n = {}, r = [], t = s.popLast() } e ? n[s.lastSegment()] = Ws(e) : r.push(s.lastSegment()) }); const s = this.getFieldsMap(t); this.applyChanges(s, n, r) } delete(e) { const t = this.field(e.popLast()); Gs(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()] } isEqual(e) { return Fs(this.value, e.value) } getFieldsMap(e) { let t = this.value; t.mapValue.fields || (t.mapValue = { fields: {} }); for (let n = 0; n < e.length; ++n) { let r = t.mapValue.fields[e.get(n)]; Gs(r) && r.mapValue.fields || (r = { mapValue: { fields: {} } }, t.mapValue.fields[e.get(n)] = r), t = r } return t.mapValue.fields } applyChanges(e, t, n) { hs(t, (t, n) => e[t] = n); for (const r of n) delete e[r] } clone() { return new Zs(Ws(this.value)) } } function Qs(e) { const t = []; return hs(e.fields, (e, n) => { const r = new gs([e]); if (Gs(n)) { const e = Qs(n.mapValue).fields; if (0 === e.length) t.push(r); else for (const n of e) t.push(r.child(n)) } else t.push(r) }), new ys(t) } class Js { constructor(e, t, n, r, s, i) { this.key = e, this.documentType = t, this.version = n, this.readTime = r, this.data = s, this.documentState = i } static newInvalidDocument(e) { return new Js(e, 0, ls.min(), ls.min(), Zs.empty(), 0) } static newFoundDocument(e, t, n) { return new Js(e, 1, t, ls.min(), n, 0) } static newNoDocument(e, t) { return new Js(e, 2, t, ls.min(), Zs.empty(), 0) } static newUnknownDocument(e, t) { return new Js(e, 3, t, ls.min(), Zs.empty(), 2) } convertToFoundDocument(e, t) { return this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this } convertToNoDocument(e) { return this.version = e, this.documentType = 2, this.data = Zs.empty(), this.documentState = 0, this } convertToUnknownDocument(e) { return this.version = e, this.documentType = 3, this.data = Zs.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this } setReadTime(e) { return this.readTime = e, this } get hasLocalMutations() { return 1 === this.documentState } get hasCommittedMutations() { return 2 === this.documentState } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return 0 !== this.documentType } isFoundDocument() { return 1 === this.documentType } isNoDocument() { return 2 === this.documentType } isUnknownDocument() { return 3 === this.documentType } isEqual(e) { return e instanceof Js && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data) } mutableCopy() { return new Js(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState) } toString() { return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})` } } class ei { constructor(e, t, n, r) { this.indexId = e, this.collectionGroup = t, this.fields = n, this.indexState = r } } function ti(e) { return e.fields.find(e => 2 === e.kind) } function ni(e) { return e.fields.filter(e => 2 !== e.kind) } ei.UNKNOWN_ID = -1; class ri { constructor(e, t) { this.fieldPath = e, this.kind = t } } class si { constructor(e, t) { this.sequenceNumber = e, this.offset = t } static empty() { return new si(0, ii.min()) } } class ii { constructor(e, t, n) { this.readTime = e, this.documentKey = t, this.largestBatchId = n } static min() { return new ii(ls.min(), Os.empty(), -1) } } class oi { constructor(e, t = null, n = [], r = [], s = null, i = null, o = null) { this.path = e, this.collectionGroup = t, this.orderBy = n, this.filters = r, this.limit = s, this.startAt = i, this.endAt = o, this.P = null } } function ai(e, t = null, n = [], r = [], s = null, i = null, o = null) { return new oi(e, t, n, r, s, i, o) } function ci(e) { const t = zr(e); if (null === t.P) { let e = t.path.canonicalString(); null !== t.collectionGroup && (e += "|cg:" + t.collectionGroup), e += "|f:", e += t.filters.map(e => { return (t = e).field.canonicalString() + t.op.toString() + Bs(t.value); var t }).join(","), e += "|ob:", e += t.orderBy.map(e => function (e) { return e.field.canonicalString() + e.dir }(e)).join(","), As(t.limit) || (e += "|l:", e += t.limit), t.startAt && (e += "|lb:", e += t.startAt.inclusive ? "b:" : "a:", e += t.startAt.position.map(e => Bs(e)).join(",")), t.endAt && (e += "|ub:", e += t.endAt.inclusive ? "a:" : "b:", e += t.endAt.position.map(e => Bs(e)).join(",")), t.P = e } return t.P } function li(e, t) { if (e.limit !== t.limit) return !1; if (e.orderBy.length !== t.orderBy.length) return !1; for (let s = 0; s < e.orderBy.length; s++)if (!Ci(e.orderBy[s], t.orderBy[s])) return !1; if (e.filters.length !== t.filters.length) return !1; for (let s = 0; s < e.filters.length; s++)if ((n = e.filters[s]).op !== (r = t.filters[s]).op || !n.field.isEqual(r.field) || !Fs(n.value, r.value)) return !1; var n, r; return e.collectionGroup === t.collectionGroup && !!e.path.isEqual(t.path) && !!Ti(e.startAt, t.startAt) && Ti(e.endAt, t.endAt) } function ui(e) { return Os.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length } function hi(e, t) { return e.filters.filter(e => e instanceof di && e.field.isEqual(t)) } class di extends class { }{ constructor(e, t, n) { super(), this.field = e, this.op = t, this.value = n } static create(e, t, n) { return e.isKeyField() ? "in" === t || "not-in" === t ? this.V(e, t, n) : new fi(e, t, n) : "array-contains" === t ? new yi(e, n) : "in" === t ? new vi(e, n) : "not-in" === t ? new wi(e, n) : "array-contains-any" === t ? new bi(e, n) : new di(e, t, n) } static V(e, t, n) { return "in" === t ? new pi(e, n) : new mi(e, n) } matches(e) { const t = e.data.field(this.field); return "!=" === this.op ? null !== t && this.v(Ms(t, this.value)) : null !== t && Ps(this.value) === Ps(t) && this.v(Ms(t, this.value)) } v(e) { switch (this.op) { case "<": return e < 0; case "<=": return e <= 0; case "==": return 0 === e; case "!=": return 0 !== e; case ">": return e > 0; case ">=": return e >= 0; default: return jr() } } S() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } } class fi extends di { constructor(e, t, n) { super(e, t, n), this.key = Os.fromName(n.referenceValue) } matches(e) { const t = Os.comparator(e.key, this.key); return this.v(t) } } class pi extends di { constructor(e, t) { super(e, "in", t), this.keys = gi(0, t) } matches(e) { return this.keys.some(t => t.isEqual(e.key)) } } class mi extends di { constructor(e, t) { super(e, "not-in", t), this.keys = gi(0, t) } matches(e) { return !this.keys.some(t => t.isEqual(e.key)) } } function gi(e, t) { var n; return ((null === (n = t.arrayValue) || void 0 === n ? void 0 : n.values) || []).map(e => Os.fromName(e.referenceValue)) } class yi extends di { constructor(e, t) { super(e, "array-contains", t) } matches(e) { const t = e.data.field(this.field); return qs(t) && Ls(t.arrayValue, this.value) } } class vi extends di { constructor(e, t) { super(e, "in", t) } matches(e) { const t = e.data.field(this.field); return null !== t && Ls(this.value.arrayValue, t) } } class wi extends di { constructor(e, t) { super(e, "not-in", t) } matches(e) { if (Ls(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const t = e.data.field(this.field); return null !== t && !Ls(this.value.arrayValue, t) } } class bi extends di { constructor(e, t) { super(e, "array-contains-any", t) } matches(e) { const t = e.data.field(this.field); return !(!qs(t) || !t.arrayValue.values) && t.arrayValue.values.some(e => Ls(this.value.arrayValue, e)) } } class _i { constructor(e, t) { this.position = e, this.inclusive = t } } class Ei { constructor(e, t = "asc") { this.field = e, this.dir = t } } function Ci(e, t) { return e.dir === t.dir && e.field.isEqual(t.field) } function Si(e, t, n) { let r = 0; for (let s = 0; s < e.position.length; s++) { const i = t[s], o = e.position[s]; if (r = i.field.isKeyField() ? Os.comparator(Os.fromName(o.referenceValue), n.key) : Ms(o, n.data.field(i.field)), "desc" === i.dir && (r *= -1), 0 !== r) break } return r } function Ti(e, t) { if (null === e) return null === t; if (null === t) return !1; if (e.inclusive !== t.inclusive || e.position.length !== t.position.length) return !1; for (let n = 0; n < e.position.length; n++)if (!Fs(e.position[n], t.position[n])) return !1; return !0 } class Ii { constructor(e, t = null, n = [], r = [], s = null, i = "F", o = null, a = null) { this.path = e, this.collectionGroup = t, this.explicitOrderBy = n, this.filters = r, this.limit = s, this.limitType = i, this.startAt = o, this.endAt = a, this.D = null, this.C = null } } function ki(e, t, n, r, s, i, o, a) { return new Ii(e, t, n, r, s, i, o, a) } function Ai(e) { return new Ii(e) } function xi(e) { return !As(e.limit) && "F" === e.limitType } function Di(e) { return !As(e.limit) && "L" === e.limitType } function Oi(e) { return e.explicitOrderBy.length > 0 ? e.explicitOrderBy[0].field : null } function Ri(e) { for (const t of e.filters) if (t.S()) return t.field; return null } function Ni(e) { return null !== e.collectionGroup } function Pi(e) { const t = zr(e); if (null === t.D) { t.D = []; const e = Ri(t), n = Oi(t); if (null !== e && null === n) e.isKeyField() || t.D.push(new Ei(e)), t.D.push(new Ei(gs.keyField(), "asc")); else { let e = !1; for (const n of t.explicitOrderBy) t.D.push(n), n.field.isKeyField() && (e = !0); if (!e) { const e = t.explicitOrderBy.length > 0 ? t.explicitOrderBy[t.explicitOrderBy.length - 1].dir : "asc"; t.D.push(new Ei(gs.keyField(), e)) } } } return t.D } function Fi(e) { const t = zr(e); if (!t.C) if ("F" === t.limitType) t.C = ai(t.path, t.collectionGroup, Pi(t), t.filters, t.limit, t.startAt, t.endAt); else { const e = []; for (const s of Pi(t)) e.push(new Ei(s.field, "desc" === s.dir ? "asc" : "desc")); const n = t.endAt ? new _i(t.endAt.position, !t.endAt.inclusive) : null, r = t.startAt ? new _i(t.startAt.position, !t.startAt.inclusive) : null; t.C = ai(t.path, t.collectionGroup, e, t.filters, t.limit, n, r) } return t.C } function Li(e, t, n) { return new Ii(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), t, n, e.startAt, e.endAt) } function Mi(e, t) { return li(Fi(e), Fi(t)) && e.limitType === t.limitType } function $i(e) { return `${ci(Fi(e))}|lt:${e.limitType}` } function Bi(e) { return `Query(target=${function (e) { let t = e.path.canonicalString(); return null !== e.collectionGroup && (t += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (t += `, filters: [${e.filters.map(e => { return `${(t = e).field.canonicalString()} ${t.op} ${Bs(t.value)}`; var t }).join(", ")}]`), As(e.limit) || (t += ", limit: " + e.limit), e.orderBy.length > 0 && (t += `, orderBy: [${e.orderBy.map(e => function (e) { return `${e.field.canonicalString()} (${e.dir})` }(e)).join(", ")}]`), e.startAt && (t += ", startAt: ", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map(e => Bs(e)).join(",")), e.endAt && (t += ", endAt: ", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map(e => Bs(e)).join(",")), `Target(${t})` }(Fi(e))}; limitType=${e.limitType})` } function Vi(e, t) { return t.isFoundDocument() && function (e, t) { const n = t.key.path; return null !== e.collectionGroup ? t.key.hasCollectionId(e.collectionGroup) && e.path.isPrefixOf(n) : Os.isDocumentKey(e.path) ? e.path.isEqual(n) : e.path.isImmediateParentOf(n) }(e, t) && function (e, t) { for (const n of e.explicitOrderBy) if (!n.field.isKeyField() && null === t.data.field(n.field)) return !1; return !0 }(e, t) && function (e, t) { for (const n of e.filters) if (!n.matches(t)) return !1; return !0 }(e, t) && function (e, t) { return !(e.startAt && !function (e, t, n) { const r = Si(e, t, n); return e.inclusive ? r <= 0 : r < 0 }(e.startAt, Pi(e), t) || e.endAt && !function (e, t, n) { const r = Si(e, t, n); return e.inclusive ? r >= 0 : r > 0 }(e.endAt, Pi(e), t)) }(e, t) } function Ui(e) { return (t, n) => { let r = !1; for (const s of Pi(e)) { const e = ji(s, t, n); if (0 !== e) return e; r = r || s.field.isKeyField() } return 0 } } function ji(e, t, n) { const r = e.field.isKeyField() ? Os.comparator(t.key, n.key) : function (e, t, n) { const r = t.data.field(e), s = n.data.field(e); return null !== r && null !== s ? Ms(r, s) : jr() }(e.field, t, n); switch (e.dir) { case "asc": return r; case "desc": return -1 * r; default: return jr() } } function qi(e, t) { if (e.N) { if (isNaN(t)) return { doubleValue: "NaN" }; if (t === 1 / 0) return { doubleValue: "Infinity" }; if (t === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: xs(t) ? "-0" : t } } function zi(e) { return { integerValue: "" + e } } function Hi(e, t) { return Ds(t) ? zi(t) : qi(e, t) } class Gi { constructor() { this._ = void 0 } } function Wi(e, t, n) { return e instanceof Xi ? function (e, t) { const n = { fields: { __type__: { stringValue: "server_timestamp" }, __local_write_time__: { timestampValue: { seconds: e.seconds, nanos: e.nanoseconds } } } }; return t && (n.fields.__previous_value__ = t), { mapValue: n } }(n, t) : e instanceof Zi ? Qi(e, t) : e instanceof Ji ? eo(e, t) : function (e, t) { const n = Ki(e, t), r = no(n) + no(e.k); return js(n) && js(e.k) ? zi(r) : qi(e.M, r) }(e, t) } function Yi(e, t, n) { return e instanceof Zi ? Qi(e, t) : e instanceof Ji ? eo(e, t) : n } function Ki(e, t) { return e instanceof to ? js(n = t) || function (e) { return !!e && "doubleValue" in e }(n) ? t : { integerValue: 0 } : null; var n } class Xi extends Gi { } class Zi extends Gi { constructor(e) { super(), this.elements = e } } function Qi(e, t) { const n = ro(t); for (const r of e.elements) n.some(e => Fs(e, r)) || n.push(r); return { arrayValue: { values: n } } } class Ji extends Gi { constructor(e) { super(), this.elements = e } } function eo(e, t) { let n = ro(t); for (const r of e.elements) n = n.filter(e => !Fs(e, r)); return { arrayValue: { values: n } } } class to extends Gi { constructor(e, t) { super(), this.M = e, this.k = t } } function no(e) { return _s(e.integerValue || e.doubleValue) } function ro(e) { return qs(e) && e.arrayValue.values ? e.arrayValue.values.slice() : [] } class so { constructor(e, t) { this.field = e, this.transform = t } } class io { constructor(e, t) { this.version = e, this.transformResults = t } } class oo { constructor(e, t) { this.updateTime = e, this.exists = t } static none() { return new oo } static exists(e) { return new oo(void 0, e) } static updateTime(e) { return new oo(e) } get isNone() { return void 0 === this.updateTime && void 0 === this.exists } isEqual(e) { return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime) } } function ao(e, t) { return void 0 !== e.updateTime ? t.isFoundDocument() && t.version.isEqual(e.updateTime) : void 0 === e.exists || e.exists === t.isFoundDocument() } class co { } function lo(e, t, n) { e instanceof mo ? function (e, t, n) { const r = e.value.clone(), s = vo(e.fieldTransforms, t, n.transformResults); r.setAll(s), t.convertToFoundDocument(n.version, r).setHasCommittedMutations() }(e, t, n) : e instanceof go ? function (e, t, n) { if (!ao(e.precondition, t)) return void t.convertToUnknownDocument(n.version); const r = vo(e.fieldTransforms, t, n.transformResults), s = t.data; s.setAll(yo(e)), s.setAll(r), t.convertToFoundDocument(n.version, s).setHasCommittedMutations() }(e, t, n) : function (e, t, n) { t.convertToNoDocument(n.version).setHasCommittedMutations() }(0, t, n) } function uo(e, t, n) { e instanceof mo ? function (e, t, n) { if (!ao(e.precondition, t)) return; const r = e.value.clone(), s = wo(e.fieldTransforms, n, t); r.setAll(s), t.convertToFoundDocument(po(t), r).setHasLocalMutations() }(e, t, n) : e instanceof go ? function (e, t, n) { if (!ao(e.precondition, t)) return; const r = wo(e.fieldTransforms, n, t), s = t.data; s.setAll(yo(e)), s.setAll(r), t.convertToFoundDocument(po(t), s).setHasLocalMutations() }(e, t, n) : function (e, t) { ao(e.precondition, t) && t.convertToNoDocument(ls.min()) }(e, t) } function ho(e, t) { let n = null; for (const r of e.fieldTransforms) { const e = t.data.field(r.field), s = Ki(r.transform, e || null); null != s && (null == n && (n = Zs.empty()), n.set(r.field, s)) } return n || null } function fo(e, t) { return e.type === t.type && !!e.key.isEqual(t.key) && !!e.precondition.isEqual(t.precondition) && !!function (e, t) { return void 0 === e && void 0 === t || !(!e || !t) && os(e, t, (e, t) => function (e, t) { return e.field.isEqual(t.field) && function (e, t) { return e instanceof Zi && t instanceof Zi || e instanceof Ji && t instanceof Ji ? os(e.elements, t.elements, Fs) : e instanceof to && t instanceof to ? Fs(e.k, t.k) : e instanceof Xi && t instanceof Xi }(e.transform, t.transform) }(e, t)) }(e.fieldTransforms, t.fieldTransforms) && (0 === e.type ? e.value.isEqual(t.value) : 1 !== e.type || e.data.isEqual(t.data) && e.fieldMask.isEqual(t.fieldMask)) } function po(e) { return e.isFoundDocument() ? e.version : ls.min() } class mo extends co { constructor(e, t, n, r = []) { super(), this.key = e, this.value = t, this.precondition = n, this.fieldTransforms = r, this.type = 0 } } class go extends co { constructor(e, t, n, r, s = []) { super(), this.key = e, this.data = t, this.fieldMask = n, this.precondition = r, this.fieldTransforms = s, this.type = 1 } } function yo(e) { const t = new Map; return e.fieldMask.fields.forEach(n => { if (!n.isEmpty()) { const r = e.data.field(n); t.set(n, r) } }), t } function vo(e, t, n) { const r = new Map; qr(e.length === n.length); for (let s = 0; s < n.length; s++) { const i = e[s], o = i.transform, a = t.data.field(i.field); r.set(i.field, Yi(o, a, n[s])) } return r } function wo(e, t, n) { const r = new Map; for (const s of e) { const e = s.transform, i = n.data.field(s.field); r.set(s.field, Wi(e, i, t)) } return r } class bo extends co { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [] } } class _o extends co { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [] } } class Eo { constructor(e) { this.count = e } } var Co, So; function To(e) { switch (e) { default: return jr(); case Hr.CANCELLED: case Hr.UNKNOWN: case Hr.DEADLINE_EXCEEDED: case Hr.RESOURCE_EXHAUSTED: case Hr.INTERNAL: case Hr.UNAVAILABLE: case Hr.UNAUTHENTICATED: return !1; case Hr.INVALID_ARGUMENT: case Hr.NOT_FOUND: case Hr.ALREADY_EXISTS: case Hr.PERMISSION_DENIED: case Hr.FAILED_PRECONDITION: case Hr.ABORTED: case Hr.OUT_OF_RANGE: case Hr.UNIMPLEMENTED: case Hr.DATA_LOSS: return !0 } } function Io(e) { if (void 0 === e) return Br("GRPC error has no .code"), Hr.UNKNOWN; switch (e) { case Co.OK: return Hr.OK; case Co.CANCELLED: return Hr.CANCELLED; case Co.UNKNOWN: return Hr.UNKNOWN; case Co.DEADLINE_EXCEEDED: return Hr.DEADLINE_EXCEEDED; case Co.RESOURCE_EXHAUSTED: return Hr.RESOURCE_EXHAUSTED; case Co.INTERNAL: return Hr.INTERNAL; case Co.UNAVAILABLE: return Hr.UNAVAILABLE; case Co.UNAUTHENTICATED: return Hr.UNAUTHENTICATED; case Co.INVALID_ARGUMENT: return Hr.INVALID_ARGUMENT; case Co.NOT_FOUND: return Hr.NOT_FOUND; case Co.ALREADY_EXISTS: return Hr.ALREADY_EXISTS; case Co.PERMISSION_DENIED: return Hr.PERMISSION_DENIED; case Co.FAILED_PRECONDITION: return Hr.FAILED_PRECONDITION; case Co.ABORTED: return Hr.ABORTED; case Co.OUT_OF_RANGE: return Hr.OUT_OF_RANGE; case Co.UNIMPLEMENTED: return Hr.UNIMPLEMENTED; case Co.DATA_LOSS: return Hr.DATA_LOSS; default: return jr() } } (So = Co || (Co = {}))[So.OK = 0] = "OK", So[So.CANCELLED = 1] = "CANCELLED", So[So.UNKNOWN = 2] = "UNKNOWN", So[So.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", So[So.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", So[So.NOT_FOUND = 5] = "NOT_FOUND", So[So.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", So[So.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", So[So.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", So[So.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", So[So.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", So[So.ABORTED = 10] = "ABORTED", So[So.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", So[So.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", So[So.INTERNAL = 13] = "INTERNAL", So[So.UNAVAILABLE = 14] = "UNAVAILABLE", So[So.DATA_LOSS = 15] = "DATA_LOSS"; class ko { constructor(e, t) { this.mapKeyFn = e, this.equalsFn = t, this.inner = {}, this.innerSize = 0 } get(e) { const t = this.mapKeyFn(e), n = this.inner[t]; if (void 0 !== n) for (const [r, s] of n) if (this.equalsFn(r, e)) return s } has(e) { return void 0 !== this.get(e) } set(e, t) { const n = this.mapKeyFn(e), r = this.inner[n]; if (void 0 === r) return this.inner[n] = [[e, t]], void this.innerSize++; for (let s = 0; s < r.length; s++)if (this.equalsFn(r[s][0], e)) return void (r[s] = [e, t]); r.push([e, t]), this.innerSize++ } delete(e) { const t = this.mapKeyFn(e), n = this.inner[t]; if (void 0 === n) return !1; for (let r = 0; r < n.length; r++)if (this.equalsFn(n[r][0], e)) return 1 === n.length ? delete this.inner[t] : n.splice(r, 1), this.innerSize--, !0; return !1 } forEach(e) { hs(this.inner, (t, n) => { for (const [r, s] of n) e(r, s) }) } isEmpty() { return ds(this.inner) } size() { return this.innerSize } } class Ao { constructor(e, t) { this.comparator = e, this.root = t || Do.EMPTY } insert(e, t) { return new Ao(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, Do.BLACK, null, null)) } remove(e) { return new Ao(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Do.BLACK, null, null)) } get(e) { let t = this.root; for (; !t.isEmpty();) { const n = this.comparator(e, t.key); if (0 === n) return t.value; n < 0 ? t = t.left : n > 0 && (t = t.right) } return null } indexOf(e) { let t = 0, n = this.root; for (; !n.isEmpty();) { const r = this.comparator(e, n.key); if (0 === r) return t + n.left.size; r < 0 ? n = n.left : (t += n.left.size + 1, n = n.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(e) { return this.root.inorderTraversal(e) } forEach(e) { this.inorderTraversal((t, n) => (e(t, n), !1)) } toString() { const e = []; return this.inorderTraversal((t, n) => (e.push(`${t}:${n}`), !1)), `{${e.join(", ")}}` } reverseTraversal(e) { return this.root.reverseTraversal(e) } getIterator() { return new xo(this.root, null, this.comparator, !1) } getIteratorFrom(e) { return new xo(this.root, e, this.comparator, !1) } getReverseIterator() { return new xo(this.root, null, this.comparator, !0) } getReverseIteratorFrom(e) { return new xo(this.root, e, this.comparator, !0) } } class xo { constructor(e, t, n, r) { this.isReverse = r, this.nodeStack = []; let s = 1; for (; !e.isEmpty();)if (s = t ? n(e.key, t) : 1, t && r && (s *= -1), s < 0) e = this.isReverse ? e.left : e.right; else { if (0 === s) { this.nodeStack.push(e); break } this.nodeStack.push(e), e = this.isReverse ? e.right : e.left } } getNext() { let e = this.nodeStack.pop(); const t = { key: e.key, value: e.value }; if (this.isReverse) for (e = e.left; !e.isEmpty();)this.nodeStack.push(e), e = e.right; else for (e = e.right; !e.isEmpty();)this.nodeStack.push(e), e = e.left; return t } hasNext() { return this.nodeStack.length > 0 } peek() { if (0 === this.nodeStack.length) return null; const e = this.nodeStack[this.nodeStack.length - 1]; return { key: e.key, value: e.value } } } class Do { constructor(e, t, n, r, s) { this.key = e, this.value = t, this.color = null != n ? n : Do.RED, this.left = null != r ? r : Do.EMPTY, this.right = null != s ? s : Do.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(e, t, n, r, s) { return new Do(null != e ? e : this.key, null != t ? t : this.value, null != n ? n : this.color, null != r ? r : this.left, null != s ? s : this.right) } isEmpty() { return !1 } inorderTraversal(e) { return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e) } reverseTraversal(e) { return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(e, t, n) { let r = this; const s = n(e, r.key); return r = s < 0 ? r.copy(null, null, null, r.left.insert(e, t, n), null) : 0 === s ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, n)), r.fixUp() } removeMin() { if (this.left.isEmpty()) return Do.EMPTY; let e = this; return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp() } remove(e, t) { let n, r = this; if (t(e, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(e, t), null); else { if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), 0 === t(e, r.key)) { if (r.right.isEmpty()) return Do.EMPTY; n = r.right.min(), r = r.copy(n.key, n.value, null, null, r.right.removeMin()) } r = r.copy(null, null, null, null, r.right.remove(e, t)) } return r.fixUp() } isRed() { return this.color } fixUp() { let e = this; return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e } moveRedLeft() { let e = this.colorFlip(); return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e } moveRedRight() { let e = this.colorFlip(); return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e } rotateLeft() { const e = this.copy(null, null, Do.RED, null, this.right.left); return this.right.copy(null, null, this.color, e, null) } rotateRight() { const e = this.copy(null, null, Do.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, e) } colorFlip() { const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, e, t) } checkMaxDepth() { const e = this.check(); return Math.pow(2, e) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed()) throw jr(); if (this.right.isRed()) throw jr(); const e = this.left.check(); if (e !== this.right.check()) throw jr(); return e + (this.isRed() ? 0 : 1) } } Do.EMPTY = null, Do.RED = !0, Do.BLACK = !1, Do.EMPTY = new class { constructor() { this.size = 0 } get key() { throw jr() } get value() { throw jr() } get color() { throw jr() } get left() { throw jr() } get right() { throw jr() } copy(e, t, n, r, s) { return this } insert(e, t, n) { return new Do(e, t) } remove(e, t) { return this } isEmpty() { return !0 } inorderTraversal(e) { return !1 } reverseTraversal(e) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } }; class Oo { constructor(e) { this.comparator = e, this.data = new Ao(this.comparator) } has(e) { return null !== this.data.get(e) } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(e) { return this.data.indexOf(e) } forEach(e) { this.data.inorderTraversal((t, n) => (e(t), !1)) } forEachInRange(e, t) { const n = this.data.getIteratorFrom(e[0]); for (; n.hasNext();) { const r = n.getNext(); if (this.comparator(r.key, e[1]) >= 0) return; t(r.key) } } forEachWhile(e, t) { let n; for (n = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); n.hasNext();)if (!e(n.getNext().key)) return } firstAfterOrEqual(e) { const t = this.data.getIteratorFrom(e); return t.hasNext() ? t.getNext().key : null } getIterator() { return new Ro(this.data.getIterator()) } getIteratorFrom(e) { return new Ro(this.data.getIteratorFrom(e)) } add(e) { return this.copy(this.data.remove(e).insert(e, !0)) } delete(e) { return this.has(e) ? this.copy(this.data.remove(e)) : this } isEmpty() { return this.data.isEmpty() } unionWith(e) { let t = this; return t.size < e.size && (t = e, e = this), e.forEach(e => { t = t.add(e) }), t } isEqual(e) { if (!(e instanceof Oo)) return !1; if (this.size !== e.size) return !1; const t = this.data.getIterator(), n = e.data.getIterator(); for (; t.hasNext();) { const e = t.getNext().key, r = n.getNext().key; if (0 !== this.comparator(e, r)) return !1 } return !0 } toArray() { const e = []; return this.forEach(t => { e.push(t) }), e } toString() { const e = []; return this.forEach(t => e.push(t)), "SortedSet(" + e.toString() + ")" } copy(e) { const t = new Oo(this.comparator); return t.data = e, t } } class Ro { constructor(e) { this.iter = e } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } } function No(e) { return e.hasNext() ? e.getNext() : void 0 } const Po = new Ao(Os.comparator); function Fo() { return Po } const Lo = new Ao(Os.comparator); function Mo() { return Lo } function $o() { return new ko(e => e.toString(), (e, t) => e.isEqual(t)) } const Bo = new Ao(Os.comparator), Vo = new Oo(Os.comparator); function Uo(...e) { let t = Vo; for (const n of e) t = t.add(n); return t } const jo = new Oo(is); function qo() { return jo } class zo { constructor(e, t, n, r, s) { this.snapshotVersion = e, this.targetChanges = t, this.targetMismatches = n, this.documentUpdates = r, this.resolvedLimboDocuments = s } static createSynthesizedRemoteEventForCurrentChange(e, t) { const n = new Map; return n.set(e, Ho.createSynthesizedTargetChangeForCurrentChange(e, t)), new zo(ls.min(), n, qo(), Fo(), Uo()) } } class Ho { constructor(e, t, n, r, s) { this.resumeToken = e, this.current = t, this.addedDocuments = n, this.modifiedDocuments = r, this.removedDocuments = s } static createSynthesizedTargetChangeForCurrentChange(e, t) { return new Ho(vs.EMPTY_BYTE_STRING, t, Uo(), Uo(), Uo()) } } class Go { constructor(e, t, n, r) { this.O = e, this.removedTargetIds = t, this.key = n, this.$ = r } } class Wo { constructor(e, t) { this.targetId = e, this.F = t } } class Yo { constructor(e, t, n = vs.EMPTY_BYTE_STRING, r = null) { this.state = e, this.targetIds = t, this.resumeToken = n, this.cause = r } } class Ko { constructor() { this.B = 0, this.L = Qo(), this.q = vs.EMPTY_BYTE_STRING, this.U = !1, this.K = !0 } get current() { return this.U } get resumeToken() { return this.q } get G() { return 0 !== this.B } get j() { return this.K } W(e) { e.approximateByteSize() > 0 && (this.K = !0, this.q = e) } H() { let e = Uo(), t = Uo(), n = Uo(); return this.L.forEach((r, s) => { switch (s) { case 0: e = e.add(r); break; case 2: t = t.add(r); break; case 1: n = n.add(r); break; default: jr() } }), new Ho(this.q, this.U, e, t, n) } J() { this.K = !1, this.L = Qo() } Y(e, t) { this.K = !0, this.L = this.L.insert(e, t) } X(e) { this.K = !0, this.L = this.L.remove(e) } Z() { this.B += 1 } tt() { this.B -= 1 } et() { this.K = !0, this.U = !0 } } class Xo { constructor(e) { this.nt = e, this.st = new Map, this.it = Fo(), this.rt = Zo(), this.ot = new Oo(is) } at(e) { for (const t of e.O) e.$ && e.$.isFoundDocument() ? this.ut(t, e.$) : this.ct(t, e.key, e.$); for (const t of e.removedTargetIds) this.ct(t, e.key, e.$) } ht(e) { this.forEachTarget(e, t => { const n = this.lt(t); switch (e.state) { case 0: this.ft(t) && n.W(e.resumeToken); break; case 1: n.tt(), n.G || n.J(), n.W(e.resumeToken); break; case 2: n.tt(), n.G || this.removeTarget(t); break; case 3: this.ft(t) && (n.et(), n.W(e.resumeToken)); break; case 4: this.ft(t) && (this.dt(t), n.W(e.resumeToken)); break; default: jr() } }) } forEachTarget(e, t) { e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.st.forEach((e, n) => { this.ft(n) && t(n) }) } _t(e) { const t = e.targetId, n = e.F.count, r = this.wt(t); if (r) { const e = r.target; if (ui(e)) if (0 === n) { const n = new Os(e.path); this.ct(t, n, Js.newNoDocument(n, ls.min())) } else qr(1 === n); else this.gt(t) !== n && (this.dt(t), this.ot = this.ot.add(t)) } } yt(e) { const t = new Map; this.st.forEach((n, r) => { const s = this.wt(r); if (s) { if (n.current && ui(s.target)) { const t = new Os(s.target.path); null !== this.it.get(t) || this.It(r, t) || this.ct(r, t, Js.newNoDocument(t, e)) } n.j && (t.set(r, n.H()), n.J()) } }); let n = Uo(); this.rt.forEach((e, t) => { let r = !0; t.forEachWhile(e => { const t = this.wt(e); return !t || 2 === t.purpose || (r = !1, !1) }), r && (n = n.add(e)) }), this.it.forEach((t, n) => n.setReadTime(e)); const r = new zo(e, t, this.ot, this.it, n); return this.it = Fo(), this.rt = Zo(), this.ot = new Oo(is), r } ut(e, t) { if (!this.ft(e)) return; const n = this.It(e, t.key) ? 2 : 0; this.lt(e).Y(t.key, n), this.it = this.it.insert(t.key, t), this.rt = this.rt.insert(t.key, this.Tt(t.key).add(e)) } ct(e, t, n) { if (!this.ft(e)) return; const r = this.lt(e); this.It(e, t) ? r.Y(t, 1) : r.X(t), this.rt = this.rt.insert(t, this.Tt(t).delete(e)), n && (this.it = this.it.insert(t, n)) } removeTarget(e) { this.st.delete(e) } gt(e) { const t = this.lt(e).H(); return this.nt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size } Z(e) { this.lt(e).Z() } lt(e) { let t = this.st.get(e); return t || (t = new Ko, this.st.set(e, t)), t } Tt(e) { let t = this.rt.get(e); return t || (t = new Oo(is), this.rt = this.rt.insert(e, t)), t } ft(e) { const t = null !== this.wt(e); return t || $r("WatchChangeAggregator", "Detected inactive target", e), t } wt(e) { const t = this.st.get(e); return t && t.G ? null : this.nt.Et(e) } dt(e) { this.st.set(e, new Ko), this.nt.getRemoteKeysForTarget(e).forEach(t => { this.ct(e, t, null) }) } It(e, t) { return this.nt.getRemoteKeysForTarget(e).has(t) } } function Zo() { return new Ao(Os.comparator) } function Qo() { return new Ao(Os.comparator) } const Jo = { asc: "ASCENDING", desc: "DESCENDING" }, ea = { "<": "LESS_THAN", "<=": "LESS_THAN_OR_EQUAL", ">": "GREATER_THAN", ">=": "GREATER_THAN_OR_EQUAL", "==": "EQUAL", "!=": "NOT_EQUAL", "array-contains": "ARRAY_CONTAINS", in: "IN", "not-in": "NOT_IN", "array-contains-any": "ARRAY_CONTAINS_ANY" }; class ta { constructor(e, t) { this.databaseId = e, this.N = t } } function na(e, t) { return e.N ? `${new Date(1e3 * t.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + t.nanoseconds).slice(-9)}Z` : { seconds: "" + t.seconds, nanos: t.nanoseconds } } function ra(e, t) { return e.N ? t.toBase64() : t.toUint8Array() } function sa(e, t) { return na(e, t.toTimestamp()) } function ia(e) { return qr(!!e), ls.fromTimestamp(function (e) { const t = bs(e); return new cs(t.seconds, t.nanos) }(e)) } function oa(e, t) { return function (e) { return new ps(["projects", e.projectId, "databases", e.database]) }(e).child("documents").child(t).canonicalString() } function aa(e) { const t = ps.fromString(e); return qr(xa(t)), t } function ca(e, t) { return oa(e.databaseId, t.path) } function la(e, t) { const n = aa(t); if (n.get(1) !== e.databaseId.projectId) throw new Gr(Hr.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + e.databaseId.projectId); if (n.get(3) !== e.databaseId.database) throw new Gr(Hr.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + e.databaseId.database); return new Os(fa(n)) } function ua(e, t) { return oa(e.databaseId, t) } function ha(e) { const t = aa(e); return 4 === t.length ? ps.emptyPath() : fa(t) } function da(e) { return new ps(["projects", e.databaseId.projectId, "databases", e.databaseId.database]).canonicalString() } function fa(e) { return qr(e.length > 4 && "documents" === e.get(4)), e.popFirst(5) } function pa(e, t, n) { return { name: ca(e, t), fields: n.value.mapValue.fields } } function ma(e, t, n) { const r = la(e, t.name), s = ia(t.updateTime), i = new Zs({ mapValue: { fields: t.fields } }), o = Js.newFoundDocument(r, s, i); return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o } function ga(e, t) { let n; if (t instanceof mo) n = { update: pa(e, t.key, t.value) }; else if (t instanceof bo) n = { delete: ca(e, t.key) }; else if (t instanceof go) n = { update: pa(e, t.key, t.data), updateMask: Aa(t.fieldMask) }; else { if (!(t instanceof _o)) return jr(); n = { verify: ca(e, t.key) } } return t.fieldTransforms.length > 0 && (n.updateTransforms = t.fieldTransforms.map(e => function (e, t) { const n = t.transform; if (n instanceof Xi) return { fieldPath: t.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (n instanceof Zi) return { fieldPath: t.field.canonicalString(), appendMissingElements: { values: n.elements } }; if (n instanceof Ji) return { fieldPath: t.field.canonicalString(), removeAllFromArray: { values: n.elements } }; if (n instanceof to) return { fieldPath: t.field.canonicalString(), increment: n.k }; throw jr() }(0, e))), t.precondition.isNone || (n.currentDocument = function (e, t) { return void 0 !== t.updateTime ? { updateTime: sa(e, t.updateTime) } : void 0 !== t.exists ? { exists: t.exists } : jr() }(e, t.precondition)), n } function ya(e, t) { const n = t.currentDocument ? function (e) { return void 0 !== e.updateTime ? oo.updateTime(ia(e.updateTime)) : void 0 !== e.exists ? oo.exists(e.exists) : oo.none() }(t.currentDocument) : oo.none(), r = t.updateTransforms ? t.updateTransforms.map(t => function (e, t) { let n = null; "setToServerValue" in t ? (qr("REQUEST_TIME" === t.setToServerValue), n = new Xi) : "appendMissingElements" in t ? n = new Zi(t.appendMissingElements.values || []) : "removeAllFromArray" in t ? n = new Ji(t.removeAllFromArray.values || []) : "increment" in t ? n = new to(e, t.increment) : jr(); const r = gs.fromServerFormat(t.fieldPath); return new so(r, n) }(e, t)) : []; if (t.update) { const s = la(e, t.update.name), i = new Zs({ mapValue: { fields: t.update.fields } }); if (t.updateMask) { const e = function (e) { return new ys((e.fieldPaths || []).map(e => gs.fromServerFormat(e))) }(t.updateMask); return new go(s, i, e, n, r) } return new mo(s, i, n, r) } if (t.delete) { const r = la(e, t.delete); return new bo(r, n) } if (t.verify) { const r = la(e, t.verify); return new _o(r, n) } return jr() } function va(e, t) { return { documents: [ua(e, t.path)] } } function wa(e, t) { const n = { structuredQuery: {} }, r = t.path; null !== t.collectionGroup ? (n.parent = ua(e, r), n.structuredQuery.from = [{ collectionId: t.collectionGroup, allDescendants: !0 }]) : (n.parent = ua(e, r.popLast()), n.structuredQuery.from = [{ collectionId: r.lastSegment() }]); const s = function (e) { if (0 === e.length) return; const t = e.map(e => function (e) { if ("==" === e.op) { if (Hs(e.value)) return { unaryFilter: { field: Sa(e.field), op: "IS_NAN" } }; if (zs(e.value)) return { unaryFilter: { field: Sa(e.field), op: "IS_NULL" } } } else if ("!=" === e.op) { if (Hs(e.value)) return { unaryFilter: { field: Sa(e.field), op: "IS_NOT_NAN" } }; if (zs(e.value)) return { unaryFilter: { field: Sa(e.field), op: "IS_NOT_NULL" } } } return { fieldFilter: { field: Sa(e.field), op: Ca(e.op), value: e.value } } }(e)); return 1 === t.length ? t[0] : { compositeFilter: { op: "AND", filters: t } } }(t.filters); s && (n.structuredQuery.where = s); const i = function (e) { if (0 !== e.length) return e.map(e => function (e) { return { field: Sa(e.field), direction: Ea(e.dir) } }(e)) }(t.orderBy); i && (n.structuredQuery.orderBy = i); const o = function (e, t) { return e.N || As(t) ? t : { value: t } }(e, t.limit); var a; return null !== o && (n.structuredQuery.limit = o), t.startAt && (n.structuredQuery.startAt = { before: (a = t.startAt).inclusive, values: a.position }), t.endAt && (n.structuredQuery.endAt = function (e) { return { before: !e.inclusive, values: e.position } }(t.endAt)), n } function ba(e) { let t = ha(e.parent); const n = e.structuredQuery, r = n.from ? n.from.length : 0; let s = null; if (r > 0) { qr(1 === r); const e = n.from[0]; e.allDescendants ? s = e.collectionId : t = t.child(e.collectionId) } let i = []; n.where && (i = _a(n.where)); let o = []; n.orderBy && (o = n.orderBy.map(e => function (e) { return new Ei(Ta(e.field), function (e) { switch (e) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } }(e.direction)) }(e))); let a = null; n.limit && (a = function (e) { let t; return t = "object" == typeof e ? e.value : e, As(t) ? null : t }(n.limit)); let c = null; n.startAt && (c = function (e) { return new _i(e.values || [], !!e.before) }(n.startAt)); let l = null; return n.endAt && (l = function (e) { return new _i(e.values || [], !e.before) }(n.endAt)), ki(t, s, o, i, a, "F", c, l) } function _a(e) { return e ? void 0 !== e.unaryFilter ? [ka(e)] : void 0 !== e.fieldFilter ? [Ia(e)] : void 0 !== e.compositeFilter ? e.compositeFilter.filters.map(e => _a(e)).reduce((e, t) => e.concat(t)) : jr() : [] } function Ea(e) { return Jo[e] } function Ca(e) { return ea[e] } function Sa(e) { return { fieldPath: e.canonicalString() } } function Ta(e) { return gs.fromServerFormat(e.fieldPath) } function Ia(e) { return di.create(Ta(e.fieldFilter.field), function (e) { switch (e) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; default: return jr() } }(e.fieldFilter.op), e.fieldFilter.value) } function ka(e) { switch (e.unaryFilter.op) { case "IS_NAN": const t = Ta(e.unaryFilter.field); return di.create(t, "==", { doubleValue: NaN }); case "IS_NULL": const n = Ta(e.unaryFilter.field); return di.create(n, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const r = Ta(e.unaryFilter.field); return di.create(r, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const s = Ta(e.unaryFilter.field); return di.create(s, "!=", { nullValue: "NULL_VALUE" }); default: return jr() } } function Aa(e) { const t = []; return e.fields.forEach(e => t.push(e.canonicalString())), { fieldPaths: t } } function xa(e) { return e.length >= 4 && "projects" === e.get(0) && "databases" === e.get(2) } function Da(e) { let t = ""; for (let n = 0; n < e.length; n++)t.length > 0 && (t = Ra(t)), t = Oa(e.get(n), t); return Ra(t) } function Oa(e, t) { let n = t; const r = e.length; for (let s = 0; s < r; s++) { const t = e.charAt(s); switch (t) { case "\0": n += "\x01\x10"; break; case "\x01": n += "\x01\x11"; break; default: n += t } } return n } function Ra(e) { return e + "\x01\x01" } function Na(e) { const t = e.length; if (qr(t >= 2), 2 === t) return qr("\x01" === e.charAt(0) && "\x01" === e.charAt(1)), ps.emptyPath(); const n = t - 2, r = []; let s = ""; for (let i = 0; i < t;) { const t = e.indexOf("\x01", i); switch ((t < 0 || t > n) && jr(), e.charAt(t + 1)) { case "\x01": const n = e.substring(i, t); let o; 0 === s.length ? o = n : (s += n, o = s, s = ""), r.push(o); break; case "\x10": s += e.substring(i, t), s += "\0"; break; case "\x11": s += e.substring(i, t + 1); break; default: jr() }i = t + 2 } return new ps(r) } const Pa = ["userId", "batchId"]; function Fa(e, t) { return [e, Da(t)] } function La(e, t, n) { return [e, Da(t), n] } const Ma = {}, $a = ["parentPath", "readTime"], Ba = ["canonicalId", "targetId"], Va = ["targetId", "path"], Ua = ["path", "targetId"], ja = ["collectionId", "parent"], qa = ["indexId", "uid"], za = ["uid", "sequenceNumber"], Ha = ["indexId", "uid", "arrayValue", "directionalValue", "documentKey"], Ga = ["indexId", "uid", "documentKey"], Wa = ["userId", "collectionPath", "documentId"], Ya = ["userId", "collectionPath", "largestBatchId"], Ka = ["userId", "collectionGroup", "largestBatchId"], Xa = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"], Za = [...Xa, "documentOverlays"], Qa = [...Za, "indexConfiguration", "indexState", "indexEntries"], Ja = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class ec { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(e) { this.onCommittedListeners.push(e) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach(e => e()) } } class tc { constructor(e) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e(e => { this.isDone = !0, this.result = e, this.nextCallback && this.nextCallback(e) }, e => { this.isDone = !0, this.error = e, this.catchCallback && this.catchCallback(e) }) } catch(e) { return this.next(void 0, e) } next(e, t) { return this.callbackAttached && jr(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new tc((n, r) => { this.nextCallback = t => { this.wrapSuccess(e, t).next(n, r) }, this.catchCallback = e => { this.wrapFailure(t, e).next(n, r) } }) } toPromise() { return new Promise((e, t) => { this.next(e, t) }) } wrapUserFunction(e) { try { const t = e(); return t instanceof tc ? t : tc.resolve(t) } catch (e) { return tc.reject(e) } } wrapSuccess(e, t) { return e ? this.wrapUserFunction(() => e(t)) : tc.resolve(t) } wrapFailure(e, t) { return e ? this.wrapUserFunction(() => e(t)) : tc.reject(t) } static resolve(e) { return new tc((t, n) => { t(e) }) } static reject(e) { return new tc((t, n) => { n(e) }) } static waitFor(e) { return new tc((t, n) => { let r = 0, s = 0, i = !1; e.forEach(e => { ++r, e.next(() => { ++s, i && s === r && t() }, e => n(e)) }), i = !0, s === r && t() }) } static or(e) { let t = tc.resolve(!1); for (const n of e) t = t.next(e => e ? tc.resolve(e) : n()); return t } static forEach(e, t) { const n = []; return e.forEach((e, r) => { n.push(t.call(this, e, r)) }), this.waitFor(n) } } class nc { constructor(e, t) { this.action = e, this.transaction = t, this.aborted = !1, this.At = new Wr, this.transaction.oncomplete = () => { this.At.resolve() }, this.transaction.onabort = () => { t.error ? this.At.reject(new ic(e, t.error)) : this.At.resolve() }, this.transaction.onerror = t => { const n = uc(t.target.error); this.At.reject(new ic(e, n)) } } static open(e, t, n, r) { try { return new nc(t, e.transaction(r, n)) } catch (e) { throw new ic(t, e) } } get Rt() { return this.At.promise } abort(e) { e && this.At.reject(e), this.aborted || ($r("SimpleDb", "Aborting transaction:", e ? e.message : "Client-initiated abort"), this.aborted = !0, this.transaction.abort()) } bt() { const e = this.transaction; this.aborted || "function" != typeof e.commit || e.commit() } store(e) { const t = this.transaction.objectStore(e); return new ac(t) } } class rc { constructor(e, t, n) { this.name = e, this.version = t, this.Pt = n, 12.2 === rc.Vt((0, T.z$)()) && Br("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.") } static delete(e) { return $r("SimpleDb", "Removing database:", e), cc(window.indexedDB.deleteDatabase(e)).toPromise() } static vt() { if (!(0, T.hl)()) return !1; if (rc.St()) return !0; const e = (0, T.z$)(), t = rc.Vt(e), n = 0 < t && t < 10, r = rc.Dt(e), s = 0 < r && r < 4.5; return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || n || s) } static St() { var e; return "undefined" != typeof process && "YES" === (null === (e = process.env) || void 0 === e ? void 0 : e.Ct) } static xt(e, t) { return e.store(t) } static Vt(e) { const t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = t ? t[1].split("_").slice(0, 2).join(".") : "-1"; return Number(n) } static Dt(e) { const t = e.match(/Android ([\d.]+)/i), n = t ? t[1].split(".").slice(0, 2).join(".") : "-1"; return Number(n) } async Nt(e) { return this.db || ($r("SimpleDb", "Opening database:", this.name), this.db = await new Promise((t, n) => { const r = indexedDB.open(this.name, this.version); r.onsuccess = e => { t(e.target.result) }, r.onblocked = () => { n(new ic(e, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.")) }, r.onerror = t => { const r = t.target.error; n("VersionError" === r.name ? new Gr(Hr.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.") : "InvalidStateError" === r.name ? new Gr(Hr.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + r) : new ic(e, r)) }, r.onupgradeneeded = e => { $r("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', e.oldVersion), this.Pt.kt(e.target.result, r.transaction, e.oldVersion, this.version).next(() => { $r("SimpleDb", "Database upgrade to version " + this.version + " complete") }) } })), this.Mt && (this.db.onversionchange = e => this.Mt(e)), this.db } Ot(e) { this.Mt = e, this.db && (this.db.onversionchange = t => e(t)) } async runTransaction(e, t, n, r) { const s = "readonly" === t; let i = 0; for (; ;) { ++i; try { this.db = await this.Nt(e); const t = nc.open(this.db, e, s ? "readonly" : "readwrite", n), i = r(t).next(e => (t.bt(), e)).catch(e => (t.abort(e), tc.reject(e))).toPromise(); return i.catch(() => { }), await t.Rt, i } catch (e) { const t = "FirebaseError" !== e.name && i < 3; if ($r("SimpleDb", "Transaction failed with error:", e.message, "Retrying:", t), this.close(), !t) return Promise.reject(e) } } } close() { this.db && this.db.close(), this.db = void 0 } } class sc { constructor(e) { this.$t = e, this.Ft = !1, this.Bt = null } get isDone() { return this.Ft } get Lt() { return this.Bt } set cursor(e) { this.$t = e } done() { this.Ft = !0 } qt(e) { this.Bt = e } delete() { return cc(this.$t.delete()) } } class ic extends Gr { constructor(e, t) { super(Hr.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${t}`), this.name = "IndexedDbTransactionError" } } function oc(e) { return "IndexedDbTransactionError" === e.name } class ac { constructor(e) { this.store = e } put(e, t) { let n; return void 0 !== t ? ($r("SimpleDb", "PUT", this.store.name, e, t), n = this.store.put(t, e)) : ($r("SimpleDb", "PUT", this.store.name, "<auto-key>", e), n = this.store.put(e)), cc(n) } add(e) { return $r("SimpleDb", "ADD", this.store.name, e, e), cc(this.store.add(e)) } get(e) { return cc(this.store.get(e)).next(t => (void 0 === t && (t = null), $r("SimpleDb", "GET", this.store.name, e, t), t)) } delete(e) { return $r("SimpleDb", "DELETE", this.store.name, e), cc(this.store.delete(e)) } count() { return $r("SimpleDb", "COUNT", this.store.name), cc(this.store.count()) } Ut(e, t) { const n = this.options(e, t); if (n.index || "function" != typeof this.store.getAll) { const e = this.cursor(n), t = []; return this.Kt(e, (e, n) => { t.push(n) }).next(() => t) } { const e = this.store.getAll(n.range); return new tc((t, n) => { e.onerror = e => { n(e.target.error) }, e.onsuccess = e => { t(e.target.result) } }) } } Gt(e, t) { const n = this.store.getAll(e, null === t ? void 0 : t); return new tc((e, t) => { n.onerror = e => { t(e.target.error) }, n.onsuccess = t => { e(t.target.result) } }) } Qt(e, t) { $r("SimpleDb", "DELETE ALL", this.store.name); const n = this.options(e, t); n.jt = !1; const r = this.cursor(n); return this.Kt(r, (e, t, n) => n.delete()) } Wt(e, t) { let n; t ? n = e : (n = {}, t = e); const r = this.cursor(n); return this.Kt(r, t) } zt(e) { const t = this.cursor({}); return new tc((n, r) => { t.onerror = e => { const t = uc(e.target.error); r(t) }, t.onsuccess = t => { const r = t.target.result; r ? e(r.primaryKey, r.value).next(e => { e ? r.continue() : n() }) : n() } }) } Kt(e, t) { const n = []; return new tc((r, s) => { e.onerror = e => { s(e.target.error) }, e.onsuccess = e => { const s = e.target.result; if (!s) return void r(); const i = new sc(s), o = t(s.primaryKey, s.value, i); if (o instanceof tc) { const e = o.catch(e => (i.done(), tc.reject(e))); n.push(e) } i.isDone ? r() : null === i.Lt ? s.continue() : s.continue(i.Lt) } }).next(() => tc.waitFor(n)) } options(e, t) { let n; return void 0 !== e && ("string" == typeof e ? n = e : t = e), { index: n, range: t } } cursor(e) { let t = "next"; if (e.reverse && (t = "prev"), e.index) { const n = this.store.index(e.index); return e.jt ? n.openKeyCursor(e.range, t) : n.openCursor(e.range, t) } return this.store.openCursor(e.range, t) } } function cc(e) { return new tc((t, n) => { e.onsuccess = e => { t(e.target.result) }, e.onerror = e => { const t = uc(e.target.error); n(t) } }) } let lc = !1; function uc(e) { const t = rc.Vt((0, T.z$)()); if (t >= 12.2 && t < 13) { const t = "An internal error was encountered in the Indexed Database server"; if (e.message.indexOf(t) >= 0) { const e = new Gr("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`); return lc || (lc = !0, setTimeout(() => { throw e }, 0)), e } } return e } class hc extends ec { constructor(e, t) { super(), this.Ht = e, this.currentSequenceNumber = t } } function dc(e, t) { const n = zr(e); return rc.xt(n.Ht, t) } class fc { constructor(e, t, n, r) { this.batchId = e, this.localWriteTime = t, this.baseMutations = n, this.mutations = r } applyToRemoteDocument(e, t) { const n = t.mutationResults; for (let r = 0; r < this.mutations.length; r++) { const t = this.mutations[r]; t.key.isEqual(e.key) && lo(t, e, n[r]) } } applyToLocalView(e) { for (const t of this.baseMutations) t.key.isEqual(e.key) && uo(t, e, this.localWriteTime); for (const t of this.mutations) t.key.isEqual(e.key) && uo(t, e, this.localWriteTime) } applyToLocalDocumentSet(e) { this.mutations.forEach(t => { const n = e.get(t.key), r = n; this.applyToLocalView(r), n.isValidDocument() || r.convertToNoDocument(ls.min()) }) } keys() { return this.mutations.reduce((e, t) => e.add(t.key), Uo()) } isEqual(e) { return this.batchId === e.batchId && os(this.mutations, e.mutations, (e, t) => fo(e, t)) && os(this.baseMutations, e.baseMutations, (e, t) => fo(e, t)) } } class pc { constructor(e, t, n, r) { this.batch = e, this.commitVersion = t, this.mutationResults = n, this.docVersions = r } static from(e, t, n) { qr(e.mutations.length === n.length); let r = Bo; const s = e.mutations; for (let i = 0; i < s.length; i++)r = r.insert(s[i].key, n[i].version); return new pc(e, t, n, r) } } class mc { constructor(e, t) { this.largestBatchId = e, this.mutation = t } getKey() { return this.mutation.key } isEqual(e) { return null !== e && this.mutation === e.mutation } toString() { return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }` } } class gc { constructor(e, t, n, r, s = ls.min(), i = ls.min(), o = vs.EMPTY_BYTE_STRING) { this.target = e, this.targetId = t, this.purpose = n, this.sequenceNumber = r, this.snapshotVersion = s, this.lastLimboFreeSnapshotVersion = i, this.resumeToken = o } withSequenceNumber(e) { return new gc(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken) } withResumeToken(e, t) { return new gc(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e) } withLastLimboFreeSnapshotVersion(e) { return new gc(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken) } } class yc { constructor(e) { this.Jt = e } } function vc(e, t) { let n; if (t.document) n = ma(e.Jt, t.document, !!t.hasCommittedMutations); else if (t.noDocument) { const e = Os.fromSegments(t.noDocument.path), r = Cc(t.noDocument.readTime); n = Js.newNoDocument(e, r), t.hasCommittedMutations && n.setHasCommittedMutations() } else { if (!t.unknownDocument) return jr(); { const e = Os.fromSegments(t.unknownDocument.path), r = Cc(t.unknownDocument.version); n = Js.newUnknownDocument(e, r) } } return t.readTime && n.setReadTime(_c(t.readTime)), n } function wc(e, t) { const n = t.key.path.popLast().toArray(), r = bc(t.readTime); if (t.isFoundDocument()) return { document: function (e, t) { return { name: ca(e, t.key), fields: t.data.value.mapValue.fields, updateTime: na(e, t.version.toTimestamp()) } }(e.Jt, t), hasCommittedMutations: t.hasCommittedMutations, readTime: r, parentPath: n }; if (t.isNoDocument()) { const e = t.key.path.toArray(), s = t.hasCommittedMutations; return { noDocument: { path: e, readTime: Ec(t.version) }, hasCommittedMutations: s, readTime: r, parentPath: n } } return t.isUnknownDocument() ? { unknownDocument: { path: t.key.path.toArray(), version: Ec(t.version) }, hasCommittedMutations: !0, readTime: r, parentPath: n } : jr() } function bc(e) { const t = e.toTimestamp(); return [t.seconds, t.nanoseconds] } function _c(e) { const t = new cs(e[0], e[1]); return ls.fromTimestamp(t) } function Ec(e) { const t = e.toTimestamp(); return { seconds: t.seconds, nanoseconds: t.nanoseconds } } function Cc(e) { const t = new cs(e.seconds, e.nanoseconds); return ls.fromTimestamp(t) } function Sc(e, t) { const n = (t.baseMutations || []).map(t => ya(e.Jt, t)); for (let i = 0; i < t.mutations.length - 1; ++i) { const e = t.mutations[i]; i + 1 < t.mutations.length && void 0 !== t.mutations[i + 1].transform && (e.updateTransforms = t.mutations[i + 1].transform.fieldTransforms, t.mutations.splice(i + 1, 1), ++i) } const r = t.mutations.map(t => ya(e.Jt, t)), s = cs.fromMillis(t.localWriteTimeMs); return new fc(t.batchId, s, n, r) } function Tc(e) { const t = Cc(e.readTime), n = void 0 !== e.lastLimboFreeSnapshotVersion ? Cc(e.lastLimboFreeSnapshotVersion) : ls.min(); let r; var s; return void 0 !== e.query.documents ? (qr(1 === (s = e.query).documents.length), r = Fi(Ai(ha(s.documents[0])))) : r = function (e) { return Fi(ba(e)) }(e.query), new gc(r, e.targetId, 0, e.lastListenSequenceNumber, t, n, vs.fromBase64String(e.resumeToken)) } function Ic(e, t) { const n = Ec(t.snapshotVersion), r = Ec(t.lastLimboFreeSnapshotVersion); let s; s = ui(t.target) ? va(e.Jt, t.target) : wa(e.Jt, t.target); const i = t.resumeToken.toBase64(); return { targetId: t.targetId, canonicalId: ci(t.target), readTime: n, resumeToken: i, lastListenSequenceNumber: t.sequenceNumber, lastLimboFreeSnapshotVersion: r, query: s } } function kc(e) { const t = ba({ parent: e.parent, structuredQuery: e.structuredQuery }); return "LAST" === e.limitType ? Li(t, t.limit, "L") : t } function Ac(e, t) { return new mc(t.largestBatchId, ya(e.Jt, t.overlayMutation)) } function xc(e, t) { const n = t.path.lastSegment(); return [e, Da(t.path.popLast()), n] } class Dc { getBundleMetadata(e, t) { return Oc(e).get(t).next(e => { if (e) return { id: (t = e).bundleId, createTime: Cc(t.createTime), version: t.version }; var t }) } saveBundleMetadata(e, t) { return Oc(e).put({ bundleId: (n = t).id, createTime: Ec(ia(n.createTime)), version: n.version }); var n } getNamedQuery(e, t) { return Rc(e).get(t).next(e => { if (e) return { name: (t = e).name, query: kc(t.bundledQuery), readTime: Cc(t.readTime) }; var t }) } saveNamedQuery(e, t) { return Rc(e).put(function (e) { return { name: e.name, readTime: Ec(ia(e.readTime)), bundledQuery: e.bundledQuery } }(t)) } } function Oc(e) { return dc(e, "bundles") } function Rc(e) { return dc(e, "namedQueries") } class Nc { constructor(e, t) { this.M = e, this.userId = t } static Yt(e, t) { return new Nc(e, t.uid || "") } getOverlay(e, t) { return Pc(e).get(xc(this.userId, t)).next(e => e ? Ac(this.M, e) : null) } saveOverlays(e, t, n) { const r = []; return n.forEach((n, s) => { const i = new mc(t, s); r.push(this.Xt(e, i)) }), tc.waitFor(r) } removeOverlaysForBatchId(e, t, n) { const r = new Set; t.forEach(e => r.add(Da(e.getCollectionPath()))); const s = []; return r.forEach(t => { const r = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, n + 1], !1, !0); s.push(Pc(e).Qt("collectionPathOverlayIndex", r)) }), tc.waitFor(s) } getOverlaysForCollection(e, t, n) { const r = $o(), s = Da(t), i = IDBKeyRange.bound([this.userId, s, n], [this.userId, s, Number.POSITIVE_INFINITY], !0); return Pc(e).Ut("collectionPathOverlayIndex", i).next(e => { for (const t of e) { const e = Ac(this.M, t); r.set(e.getKey(), e) } return r }) } getOverlaysForCollectionGroup(e, t, n, r) { const s = $o(); let i; const o = IDBKeyRange.bound([this.userId, t, n], [this.userId, t, Number.POSITIVE_INFINITY], !0); return Pc(e).Wt({ index: "collectionGroupOverlayIndex", range: o }, (e, t, n) => { const o = Ac(this.M, t); s.size() < r || o.largestBatchId === i ? (s.set(o.getKey(), o), i = o.largestBatchId) : n.done() }).next(() => s) } Xt(e, t) { return Pc(e).put(function (e, t, n) { const [r, s, i] = xc(t, n.mutation.key); return { userId: t, collectionPath: s, documentId: i, collectionGroup: n.mutation.key.getCollectionGroup(), largestBatchId: n.largestBatchId, overlayMutation: ga(e.Jt, n.mutation) } }(this.M, this.userId, t)) } } function Pc(e) { return dc(e, "documentOverlays") } class Fc { constructor() { } Zt(e, t) { this.te(e, t), t.ee() } te(e, t) { if ("nullValue" in e) this.ne(t, 5); else if ("booleanValue" in e) this.ne(t, 10), t.se(e.booleanValue ? 1 : 0); else if ("integerValue" in e) this.ne(t, 15), t.se(_s(e.integerValue)); else if ("doubleValue" in e) { const n = _s(e.doubleValue); isNaN(n) ? this.ne(t, 13) : (this.ne(t, 15), xs(n) ? t.se(0) : t.se(n)) } else if ("timestampValue" in e) { const n = e.timestampValue; this.ne(t, 20), "string" == typeof n ? t.ie(n) : (t.ie(`${n.seconds || ""}`), t.se(n.nanos || 0)) } else if ("stringValue" in e) this.re(e.stringValue, t), this.oe(t); else if ("bytesValue" in e) this.ne(t, 30), t.ae(Es(e.bytesValue)), this.oe(t); else if ("referenceValue" in e) this.ue(e.referenceValue, t); else if ("geoPointValue" in e) { const n = e.geoPointValue; this.ne(t, 45), t.se(n.latitude || 0), t.se(n.longitude || 0) } else "mapValue" in e ? Ys(e) ? this.ne(t, Number.MAX_SAFE_INTEGER) : (this.ce(e.mapValue, t), this.oe(t)) : "arrayValue" in e ? (this.he(e.arrayValue, t), this.oe(t)) : jr() } re(e, t) { this.ne(t, 25), this.le(e, t) } le(e, t) { t.ie(e) } ce(e, t) { const n = e.fields || {}; this.ne(t, 55); for (const r of Object.keys(n)) this.re(r, t), this.te(n[r], t) } he(e, t) { const n = e.values || []; this.ne(t, 50); for (const r of n) this.te(r, t) } ue(e, t) { this.ne(t, 37), Os.fromName(e).path.forEach(e => { this.ne(t, 60), this.le(e, t) }) } ne(e, t) { e.se(t) } oe(e) { e.se(2) } } function Lc(e) { if (0 === e) return 8; let t = 0; return e >> 4 == 0 && (t += 4, e <<= 4), e >> 6 == 0 && (t += 2, e <<= 2), e >> 7 == 0 && (t += 1), t } function Mc(e) { const t = 64 - function (e) { let t = 0; for (let n = 0; n < 8; ++n) { const r = Lc(255 & e[n]); if (t += r, 8 !== r) break } return t }(e); return Math.ceil(t / 8) } Fc.fe = new Fc; class $c { constructor() { this.buffer = new Uint8Array(1024), this.position = 0 } de(e) { const t = e[Symbol.iterator](); let n = t.next(); for (; !n.done;)this._e(n.value), n = t.next(); this.we() } me(e) { const t = e[Symbol.iterator](); let n = t.next(); for (; !n.done;)this.ge(n.value), n = t.next(); this.ye() } pe(e) { for (const t of e) { const e = t.charCodeAt(0); if (e < 128) this._e(e); else if (e < 2048) this._e(960 | e >>> 6), this._e(128 | 63 & e); else if (t < "\ud800" || "\udbff" < t) this._e(480 | e >>> 12), this._e(128 | 63 & e >>> 6), this._e(128 | 63 & e); else { const e = t.codePointAt(0); this._e(240 | e >>> 18), this._e(128 | 63 & e >>> 12), this._e(128 | 63 & e >>> 6), this._e(128 | 63 & e) } } this.we() } Ie(e) { for (const t of e) { const e = t.charCodeAt(0); if (e < 128) this.ge(e); else if (e < 2048) this.ge(960 | e >>> 6), this.ge(128 | 63 & e); else if (t < "\ud800" || "\udbff" < t) this.ge(480 | e >>> 12), this.ge(128 | 63 & e >>> 6), this.ge(128 | 63 & e); else { const e = t.codePointAt(0); this.ge(240 | e >>> 18), this.ge(128 | 63 & e >>> 12), this.ge(128 | 63 & e >>> 6), this.ge(128 | 63 & e) } } this.ye() } Te(e) { const t = this.Ee(e), n = Mc(t); this.Ae(1 + n), this.buffer[this.position++] = 255 & n; for (let r = t.length - n; r < t.length; ++r)this.buffer[this.position++] = 255 & t[r] } Re(e) { const t = this.Ee(e), n = Mc(t); this.Ae(1 + n), this.buffer[this.position++] = ~(255 & n); for (let r = t.length - n; r < t.length; ++r)this.buffer[this.position++] = ~(255 & t[r]) } be() { this.Pe(255), this.Pe(255) } Ve() { this.ve(255), this.ve(255) } reset() { this.position = 0 } seed(e) { this.Ae(e.length), this.buffer.set(e, this.position), this.position += e.length } Se() { return this.buffer.slice(0, this.position) } Ee(e) { const t = function (e) { const t = new DataView(new ArrayBuffer(8)); return t.setFloat64(0, e, !1), new Uint8Array(t.buffer) }(e), n = 0 != (128 & t[0]); t[0] ^= n ? 255 : 128; for (let r = 1; r < t.length; ++r)t[r] ^= n ? 255 : 0; return t } _e(e) { const t = 255 & e; 0 === t ? (this.Pe(0), this.Pe(255)) : 255 === t ? (this.Pe(255), this.Pe(0)) : this.Pe(t) } ge(e) { const t = 255 & e; 0 === t ? (this.ve(0), this.ve(255)) : 255 === t ? (this.ve(255), this.ve(0)) : this.ve(e) } we() { this.Pe(0), this.Pe(1) } ye() { this.ve(0), this.ve(1) } Pe(e) { this.Ae(1), this.buffer[this.position++] = e } ve(e) { this.Ae(1), this.buffer[this.position++] = ~e } Ae(e) { const t = e + this.position; if (t <= this.buffer.length) return; let n = 2 * this.buffer.length; n < t && (n = t); const r = new Uint8Array(n); r.set(this.buffer), this.buffer = r } } class Bc { constructor(e) { this.De = e } ae(e) { this.De.de(e) } ie(e) { this.De.pe(e) } se(e) { this.De.Te(e) } ee() { this.De.be() } } class Vc { constructor(e) { this.De = e } ae(e) { this.De.me(e) } ie(e) { this.De.Ie(e) } se(e) { this.De.Re(e) } ee() { this.De.Ve() } } class Uc { constructor() { this.De = new $c, this.Ce = new Bc(this.De), this.xe = new Vc(this.De) } seed(e) { this.De.seed(e) } Ne(e) { return 0 === e ? this.Ce : this.xe } Se() { return this.De.Se() } reset() { this.De.reset() } } class jc { constructor(e, t, n, r) { this.indexId = e, this.documentKey = t, this.arrayValue = n, this.directionalValue = r } ke() { const e = this.directionalValue.length, t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e, n = new Uint8Array(t); return n.set(this.directionalValue, 0), t !== e ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new jc(this.indexId, this.documentKey, this.arrayValue, n) } } function qc(e, t) { let n = e.indexId - t.indexId; return 0 !== n ? n : (n = zc(e.arrayValue, t.arrayValue), 0 !== n ? n : (n = zc(e.directionalValue, t.directionalValue), 0 !== n ? n : Os.comparator(e.documentKey, t.documentKey))) } function zc(e, t) { for (let n = 0; n < e.length && n < t.length; ++n) { const r = e[n] - t[n]; if (0 !== r) return r } return e.length - t.length } class Hc { constructor(e) { this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment(), this.Me = e.orderBy, this.Oe = []; for (const t of e.filters) { const e = t; e.S() ? this.$e = e : this.Oe.push(e) } } Fe(e) { const t = ti(e); if (void 0 !== t && !this.Be(t)) return !1; const n = ni(e); let r = 0, s = 0; for (; r < n.length && this.Be(n[r]); ++r); if (r === n.length) return !0; if (void 0 !== this.$e) { const e = n[r]; if (!this.Le(this.$e, e) || !this.qe(this.Me[s++], e)) return !1; ++r } for (; r < n.length; ++r) { const e = n[r]; if (s >= this.Me.length || !this.qe(this.Me[s++], e)) return !1 } return !0 } Be(e) { for (const t of this.Oe) if (this.Le(t, e)) return !0; return !1 } Le(e, t) { return !(void 0 === e || !e.field.isEqual(t.fieldPath)) && 2 === t.kind == ("array-contains" === e.op || "array-contains-any" === e.op) } qe(e, t) { return !!e.field.isEqual(t.fieldPath) && (0 === t.kind && "asc" === e.dir || 1 === t.kind && "desc" === e.dir) } } class Gc { constructor() { this.Ue = new Wc } addToCollectionParentIndex(e, t) { return this.Ue.add(t), tc.resolve() } getCollectionParents(e, t) { return tc.resolve(this.Ue.getEntries(t)) } addFieldIndex(e, t) { return tc.resolve() } deleteFieldIndex(e, t) { return tc.resolve() } getDocumentsMatchingTarget(e, t) { return tc.resolve(null) } getFieldIndex(e, t) { return tc.resolve(null) } getFieldIndexes(e, t) { return tc.resolve([]) } getNextCollectionGroupToUpdate(e) { return tc.resolve(null) } updateCollectionGroup(e, t, n) { return tc.resolve() } updateIndexEntries(e, t) { return tc.resolve() } } class Wc { constructor() { this.index = {} } add(e) { const t = e.lastSegment(), n = e.popLast(), r = this.index[t] || new Oo(ps.comparator), s = !r.has(n); return this.index[t] = r.add(n), s } has(e) { const t = e.lastSegment(), n = e.popLast(), r = this.index[t]; return r && r.has(n) } getEntries(e) { return (this.index[e] || new Oo(ps.comparator)).toArray() } } const Yc = new Uint8Array(0); class Kc { constructor(e) { this.user = e, this.Ke = new Wc, this.Ge = new ko(e => ci(e), (e, t) => li(e, t)), this.uid = e.uid || "" } addToCollectionParentIndex(e, t) { if (!this.Ke.has(t)) { const n = t.lastSegment(), r = t.popLast(); e.addOnCommittedListener(() => { this.Ke.add(t) }); const s = { collectionId: n, parent: Da(r) }; return Xc(e).put(s) } return tc.resolve() } getCollectionParents(e, t) { const n = [], r = IDBKeyRange.bound([t, ""], [as(t), ""], !1, !0); return Xc(e).Ut(r).next(e => { for (const r of e) { if (r.collectionId !== t) break; n.push(Na(r.parent)) } return n }) } addFieldIndex(e, t) { const n = Qc(e), r = function (e) { return { indexId: e.indexId, collectionGroup: e.collectionGroup, fields: e.fields.map(e => [e.fieldPath.canonicalString(), e.kind]) } }(t); return delete r.indexId, n.add(r).next() } deleteFieldIndex(e, t) { const n = Qc(e), r = Jc(e), s = Zc(e); return n.delete(t.indexId).next(() => r.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))).next(() => s.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))) } getDocumentsMatchingTarget(e, t) { const n = Zc(e); let r = !0; const s = new Map; return tc.forEach(this.Qe(t), t => this.getFieldIndex(e, t).next(e => { r && (r = !!e), s.set(t, e) })).next(() => { if (r) { let e = Uo(); return tc.forEach(s, (r, s) => { var i; $r("IndexedDbIndexManager", `Using index ${i = r, `id=${i.indexId}|cg=${i.collectionGroup}|f=${i.fields.map(e => `${e.fieldPath}:${e.kind}`).join(",")}`} to execute ${ci(t)}`); const o = function (e, t) { const n = ti(t); if (void 0 === n) return null; for (const r of hi(e, n.fieldPath)) switch (r.op) { case "array-contains-any": return r.value.arrayValue.values || []; case "array-contains": return [r.value] }return null }(s, r), a = function (e, t) { const n = new Map; for (const r of ni(t)) for (const t of hi(e, r.fieldPath)) switch (t.op) { case "==": case "in": n.set(r.fieldPath.canonicalString(), t.value); break; case "not-in": case "!=": return n.set(r.fieldPath.canonicalString(), t.value), Array.from(n.values()) }return null }(s, r), c = function (e, t) { const n = []; let r = !0; for (const i of ni(t)) { let t, o = !0; for (const n of hi(e, i.fieldPath)) { let e, r = !0; switch (n.op) { case "<": case "<=": e = "nullValue" in (s = n.value) ? Ns : "booleanValue" in s ? { booleanValue: !1 } : "integerValue" in s || "doubleValue" in s ? { doubleValue: NaN } : "timestampValue" in s ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "stringValue" in s ? { stringValue: "" } : "bytesValue" in s ? { bytesValue: "" } : "referenceValue" in s ? Us(ks.empty(), Os.empty()) : "geoPointValue" in s ? { geoPointValue: { latitude: -90, longitude: -180 } } : "arrayValue" in s ? { arrayValue: {} } : "mapValue" in s ? { mapValue: {} } : jr(); break; case "==": case "in": case ">=": e = n.value; break; case ">": e = n.value, r = !1; break; case "!=": case "not-in": e = Ns }Ks(t, e) === e && (t = e, o = r) } if (null !== e.startAt) for (let n = 0; n < e.orderBy.length; ++n)if (e.orderBy[n].field.isEqual(i.fieldPath)) { const r = e.startAt.position[n]; Ks(t, r) === r && (t = r, o = e.startAt.inclusive); break } if (void 0 === t) return null; n.push(t), r && (r = o) } var s; return new _i(n, r) }(s, r), l = function (e, t) { const n = []; let r = !0; for (const i of ni(t)) { let t, o = !0; for (const n of hi(e, i.fieldPath)) { let e, r = !0; switch (n.op) { case ">=": case ">": e = "nullValue" in (s = n.value) ? { booleanValue: !1 } : "booleanValue" in s ? { doubleValue: NaN } : "integerValue" in s || "doubleValue" in s ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "timestampValue" in s ? { stringValue: "" } : "stringValue" in s ? { bytesValue: "" } : "bytesValue" in s ? Us(ks.empty(), Os.empty()) : "referenceValue" in s ? { geoPointValue: { latitude: -90, longitude: -180 } } : "geoPointValue" in s ? { arrayValue: {} } : "arrayValue" in s ? { mapValue: {} } : "mapValue" in s ? Rs : jr(), r = !1; break; case "==": case "in": case "<=": e = n.value; break; case "<": e = n.value, r = !1; break; case "!=": case "not-in": e = Rs }Xs(t, e) === e && (t = e, o = r) } if (null !== e.endAt) for (let n = 0; n < e.orderBy.length; ++n)if (e.orderBy[n].field.isEqual(i.fieldPath)) { const r = e.endAt.position[n]; Xs(t, r) === r && (t = r, o = e.endAt.inclusive); break } if (void 0 === t) return null; n.push(t), r && (r = o) } var s; return new _i(n, r) }(s, r), u = this.je(r, s, c), h = this.je(r, s, l), d = this.We(r, s, a), f = this.ze(r.indexId, o, u, !!c && c.inclusive, h, !!l && l.inclusive, d); return tc.forEach(f, r => n.Gt(r, t.limit).next(t => { t.forEach(t => { e = e.add(new Os(Na(t.documentKey))) }) })) }).next(() => e) } return tc.resolve(null) }) } Qe(e) { let t = this.Ge.get(e); return t || (t = [e], this.Ge.set(e, t), t) } ze(e, t, n, r, s, i, o) { const a = (null != t ? t.length : 1) * Math.max(null != n ? n.length : 1, null != s ? s.length : 1), c = a / (null != t ? t.length : 1), l = []; for (let u = 0; u < a; ++u) { const a = t ? this.He(t[u / c]) : Yc, h = n ? this.Je(e, a, n[u % c], r) : this.Ye(e), d = s ? this.Xe(e, a, s[u % c], i) : this.Ye(e + 1); l.push(...this.createRange(h, d, o.map(t => this.Je(e, a, t, !0)))) } return l } Je(e, t, n, r) { const s = new jc(e, Os.empty(), t, n); return r ? s : s.ke() } Xe(e, t, n, r) { const s = new jc(e, Os.empty(), t, n); return r ? s.ke() : s } Ye(e) { return new jc(e, Os.empty(), Yc, Yc) } getFieldIndex(e, t) { const n = new Hc(t), r = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment(); return this.getFieldIndexes(e, r).next(e => { const t = e.filter(e => n.Fe(e)); return t.sort((e, t) => t.fields.length - e.fields.length), t.length > 0 ? t[0] : null }) } Ze(e, t) { const n = new Uc; for (const r of ni(e)) { const e = t.data.field(r.fieldPath); if (null == e) return null; const s = n.Ne(r.kind); Fc.fe.Zt(e, s) } return n.Se() } He(e) { const t = new Uc; return Fc.fe.Zt(e, t.Ne(0)), t.Se() } We(e, t, n) { if (null === n) return []; let r = []; r.push(new Uc); let s = 0; for (const i of ni(e)) { const e = n[s++]; for (const n of r) if (this.tn(t, i.fieldPath) && qs(e)) r = this.en(r, i, e); else { const t = n.Ne(i.kind); Fc.fe.Zt(e, t) } } return this.nn(r) } je(e, t, n) { return null == n ? null : this.We(e, t, n.position) } nn(e) { const t = []; for (let n = 0; n < e.length; ++n)t[n] = e[n].Se(); return t } en(e, t, n) { const r = [...e], s = []; for (const i of n.arrayValue.values || []) for (const e of r) { const n = new Uc; n.seed(e.Se()), Fc.fe.Zt(i, n.Ne(t.kind)), s.push(n) } return s } tn(e, t) { return !!e.filters.find(e => e instanceof di && e.field.isEqual(t) && ("in" === e.op || "not-in" === e.op)) } getFieldIndexes(e, t) { const n = Qc(e), r = Jc(e); return (t ? n.Ut("collectionGroupIndex", IDBKeyRange.bound(t, t)) : n.Ut()).next(e => { const t = []; return tc.forEach(e, e => r.get([e.indexId, this.uid]).next(n => { t.push(function (e, t) { const n = t ? new si(t.sequenceNumber, new ii(Cc(t.readTime), new Os(Na(t.documentKey)), t.largestBatchId)) : si.empty(), r = e.fields.map(([e, t]) => new ri(gs.fromServerFormat(e), t)); return new ei(e.indexId, e.collectionGroup, r, n) }(e, n)) })).next(() => t) }) } getNextCollectionGroupToUpdate(e) { return this.getFieldIndexes(e).next(e => 0 === e.length ? null : (e.sort((e, t) => { const n = e.indexState.sequenceNumber - t.indexState.sequenceNumber; return 0 !== n ? n : is(e.collectionGroup, t.collectionGroup) }), e[0].collectionGroup)) } updateCollectionGroup(e, t, n) { const r = Qc(e), s = Jc(e); return this.sn(e).next(e => r.Ut("collectionGroupIndex", IDBKeyRange.bound(t, t)).next(t => tc.forEach(t, t => s.put(function (e, t, n, r) { return { indexId: e, uid: t.uid || "", sequenceNumber: n, readTime: Ec(r.readTime), documentKey: Da(r.documentKey.path), largestBatchId: r.largestBatchId } }(t.indexId, this.user, e, n))))) } updateIndexEntries(e, t) { const n = new Map; return tc.forEach(t, (t, r) => { const s = n.get(t.collectionGroup); return (s ? tc.resolve(s) : this.getFieldIndexes(e, t.collectionGroup)).next(s => (n.set(t.collectionGroup, s), tc.forEach(s, n => this.rn(e, t, n).next(t => { const s = this.on(r, n); return t.isEqual(s) ? tc.resolve() : this.an(e, r, t, s) })))) }) } un(e, t, n) { return Zc(e).put({ indexId: n.indexId, uid: this.uid, arrayValue: n.arrayValue, directionalValue: n.directionalValue, documentKey: Da(t.key.path) }) } cn(e, t, n) { return Zc(e).delete([n.indexId, this.uid, n.arrayValue, n.directionalValue, Da(t.key.path)]) } rn(e, t, n) { const r = Zc(e); let s = new Oo(qc); return r.Wt({ index: "documentKeyIndex", range: IDBKeyRange.only([n.indexId, this.uid, Da(t.path)]) }, (e, r) => { s = s.add(new jc(n.indexId, t, r.arrayValue, r.directionalValue)) }).next(() => s) } on(e, t) { let n = new Oo(qc); const r = this.Ze(t, e); if (null == r) return n; const s = ti(t); if (null != s) { const i = e.data.field(s.fieldPath); if (qs(i)) for (const s of i.arrayValue.values || []) n = n.add(new jc(t.indexId, e.key, this.He(s), r)) } else n = n.add(new jc(t.indexId, e.key, Yc, r)); return n } an(e, t, n, r) { $r("IndexedDbIndexManager", "Updating index entries for document '%s'", t.key); const s = []; return function (e, t, n, r, s) { const i = e.getIterator(), o = t.getIterator(); let a = No(i), c = No(o); for (; a || c;) { let e = !1, t = !1; if (a && c) { const r = n(a, c); r < 0 ? t = !0 : r > 0 && (e = !0) } else null != a ? t = !0 : e = !0; e ? (r(c), c = No(o)) : t ? (s(a), a = No(i)) : (a = No(i), c = No(o)) } }(n, r, qc, n => { s.push(this.un(e, t, n)) }, n => { s.push(this.cn(e, t, n)) }), tc.waitFor(s) } sn(e) { let t = 1; return Jc(e).Wt({ index: "sequenceNumberIndex", reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, (e, n, r) => { r.done(), t = n.sequenceNumber + 1 }).next(() => t) } createRange(e, t, n) { n = n.sort((e, t) => qc(e, t)).filter((e, t, n) => !t || 0 !== qc(e, n[t - 1])); const r = []; r.push(e); for (const i of n) { const n = qc(i, e), s = qc(i, t); if (0 === n) r[0] = e.ke(); else if (n > 0 && s < 0) r.push(i), r.push(i.ke()); else if (s > 0) break } r.push(t); const s = []; for (let i = 0; i < r.length; i += 2)s.push(IDBKeyRange.bound([r[i].indexId, this.uid, r[i].arrayValue, r[i].directionalValue, ""], [r[i + 1].indexId, this.uid, r[i + 1].arrayValue, r[i + 1].directionalValue, ""])); return s } } function Xc(e) { return dc(e, "collectionParents") } function Zc(e) { return dc(e, "indexEntries") } function Qc(e) { return dc(e, "indexConfiguration") } function Jc(e) { return dc(e, "indexState") } const el = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 }; class tl { constructor(e, t, n) { this.cacheSizeCollectionThreshold = e, this.percentileToCollect = t, this.maximumSequenceNumbersToCollect = n } static withCacheSize(e) { return new tl(e, tl.DEFAULT_COLLECTION_PERCENTILE, tl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT) } } function nl(e, t, n) { const r = e.store("mutations"), s = e.store("documentMutations"), i = [], o = IDBKeyRange.only(n.batchId); let a = 0; const c = r.Wt({ range: o }, (e, t, n) => (a++, n.delete())); i.push(c.next(() => { qr(1 === a) })); const l = []; for (const u of n.mutations) { const e = La(t, u.key.path, n.batchId); i.push(s.delete(e)), l.push(u.key) } return tc.waitFor(i).next(() => l) } function rl(e) { if (!e) return 0; let t; if (e.document) t = e.document; else if (e.unknownDocument) t = e.unknownDocument; else { if (!e.noDocument) throw jr(); t = e.noDocument } return JSON.stringify(t).length } tl.DEFAULT_COLLECTION_PERCENTILE = 10, tl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, tl.DEFAULT = new tl(41943040, tl.DEFAULT_COLLECTION_PERCENTILE, tl.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), tl.DISABLED = new tl(-1, 0, 0); class sl { constructor(e, t, n, r) { this.userId = e, this.M = t, this.indexManager = n, this.referenceDelegate = r, this.hn = {} } static Yt(e, t, n, r) { qr("" !== e.uid); const s = e.isAuthenticated() ? e.uid : ""; return new sl(s, t, n, r) } checkEmpty(e) { let t = !0; const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]); return ol(e).Wt({ index: "userMutationsIndex", range: n }, (e, n, r) => { t = !1, r.done() }).next(() => t) } addMutationBatch(e, t, n, r) { const s = al(e), i = ol(e); return i.add({}).next(o => { qr("number" == typeof o); const a = new fc(o, t, n, r), c = function (e, t, n) { const r = n.baseMutations.map(t => ga(e.Jt, t)), s = n.mutations.map(t => ga(e.Jt, t)); return { userId: t, batchId: n.batchId, localWriteTimeMs: n.localWriteTime.toMillis(), baseMutations: r, mutations: s } }(this.M, this.userId, a), l = []; let u = new Oo((e, t) => is(e.canonicalString(), t.canonicalString())); for (const e of r) { const t = La(this.userId, e.key.path, o); u = u.add(e.key.path.popLast()), l.push(i.put(c)), l.push(s.put(t, Ma)) } return u.forEach(t => { l.push(this.indexManager.addToCollectionParentIndex(e, t)) }), e.addOnCommittedListener(() => { this.hn[o] = a.keys() }), tc.waitFor(l).next(() => a) }) } lookupMutationBatch(e, t) { return ol(e).get(t).next(e => e ? (qr(e.userId === this.userId), Sc(this.M, e)) : null) } ln(e, t) { return this.hn[t] ? tc.resolve(this.hn[t]) : this.lookupMutationBatch(e, t).next(e => { if (e) { const n = e.keys(); return this.hn[t] = n, n } return null }) } getNextMutationBatchAfterBatchId(e, t) { const n = t + 1, r = IDBKeyRange.lowerBound([this.userId, n]); let s = null; return ol(e).Wt({ index: "userMutationsIndex", range: r }, (e, t, r) => { t.userId === this.userId && (qr(t.batchId >= n), s = Sc(this.M, t)), r.done() }).next(() => s) } getHighestUnacknowledgedBatchId(e) { const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]); let n = -1; return ol(e).Wt({ index: "userMutationsIndex", range: t, reverse: !0 }, (e, t, r) => { n = t.batchId, r.done() }).next(() => n) } getAllMutationBatches(e) { const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]); return ol(e).Ut("userMutationsIndex", t).next(e => e.map(e => Sc(this.M, e))) } getAllMutationBatchesAffectingDocumentKey(e, t) { const n = Fa(this.userId, t.path), r = IDBKeyRange.lowerBound(n), s = []; return al(e).Wt({ range: r }, (n, r, i) => { const [o, a, c] = n, l = Na(a); if (o === this.userId && t.path.isEqual(l)) return ol(e).get(c).next(e => { if (!e) throw jr(); qr(e.userId === this.userId), s.push(Sc(this.M, e)) }); i.done() }).next(() => s) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let n = new Oo(is); const r = []; return t.forEach(t => { const s = Fa(this.userId, t.path), i = IDBKeyRange.lowerBound(s), o = al(e).Wt({ range: i }, (e, r, s) => { const [i, o, a] = e, c = Na(o); i === this.userId && t.path.isEqual(c) ? n = n.add(a) : s.done() }); r.push(o) }), tc.waitFor(r).next(() => this.fn(e, n)) } getAllMutationBatchesAffectingQuery(e, t) { const n = t.path, r = n.length + 1, s = Fa(this.userId, n), i = IDBKeyRange.lowerBound(s); let o = new Oo(is); return al(e).Wt({ range: i }, (e, t, s) => { const [i, a, c] = e, l = Na(a); i === this.userId && n.isPrefixOf(l) ? l.length === r && (o = o.add(c)) : s.done() }).next(() => this.fn(e, o)) } fn(e, t) { const n = [], r = []; return t.forEach(t => { r.push(ol(e).get(t).next(e => { if (null === e) throw jr(); qr(e.userId === this.userId), n.push(Sc(this.M, e)) })) }), tc.waitFor(r).next(() => n) } removeMutationBatch(e, t) { return nl(e.Ht, this.userId, t).next(n => (e.addOnCommittedListener(() => { this.dn(t.batchId) }), tc.forEach(n, t => this.referenceDelegate.markPotentiallyOrphaned(e, t)))) } dn(e) { delete this.hn[e] } performConsistencyCheck(e) { return this.checkEmpty(e).next(t => { if (!t) return tc.resolve(); const n = IDBKeyRange.lowerBound([this.userId]), r = []; return al(e).Wt({ range: n }, (e, t, n) => { if (e[0] === this.userId) { const t = Na(e[1]); r.push(t) } else n.done() }).next(() => { qr(0 === r.length) }) }) } containsKey(e, t) { return il(e, this.userId, t) } _n(e) { return cl(e).get(this.userId).next(e => e || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: "" }) } } function il(e, t, n) { const r = Fa(t, n.path), s = r[1], i = IDBKeyRange.lowerBound(r); let o = !1; return al(e).Wt({ range: i, jt: !0 }, (e, n, r) => { const [i, a, c] = e; i === t && a === s && (o = !0), r.done() }).next(() => o) } function ol(e) { return dc(e, "mutations") } function al(e) { return dc(e, "documentMutations") } function cl(e) { return dc(e, "mutationQueues") } class ll { constructor(e) { this.wn = e } next() { return this.wn += 2, this.wn } static mn() { return new ll(0) } static gn() { return new ll(-1) } } class ul { constructor(e, t) { this.referenceDelegate = e, this.M = t } allocateTargetId(e) { return this.yn(e).next(t => { const n = new ll(t.highestTargetId); return t.highestTargetId = n.next(), this.pn(e, t).next(() => t.highestTargetId) }) } getLastRemoteSnapshotVersion(e) { return this.yn(e).next(e => ls.fromTimestamp(new cs(e.lastRemoteSnapshotVersion.seconds, e.lastRemoteSnapshotVersion.nanoseconds))) } getHighestSequenceNumber(e) { return this.yn(e).next(e => e.highestListenSequenceNumber) } setTargetsMetadata(e, t, n) { return this.yn(e).next(r => (r.highestListenSequenceNumber = t, n && (r.lastRemoteSnapshotVersion = n.toTimestamp()), t > r.highestListenSequenceNumber && (r.highestListenSequenceNumber = t), this.pn(e, r))) } addTargetData(e, t) { return this.In(e, t).next(() => this.yn(e).next(n => (n.targetCount += 1, this.Tn(t, n), this.pn(e, n)))) } updateTargetData(e, t) { return this.In(e, t) } removeTargetData(e, t) { return this.removeMatchingKeysForTargetId(e, t.targetId).next(() => hl(e).delete(t.targetId)).next(() => this.yn(e)).next(t => (qr(t.targetCount > 0), t.targetCount -= 1, this.pn(e, t))) } removeTargets(e, t, n) { let r = 0; const s = []; return hl(e).Wt((i, o) => { const a = Tc(o); a.sequenceNumber <= t && null === n.get(a.targetId) && (r++, s.push(this.removeTargetData(e, a))) }).next(() => tc.waitFor(s)).next(() => r) } forEachTarget(e, t) { return hl(e).Wt((e, n) => { const r = Tc(n); t(r) }) } yn(e) { return dl(e).get("targetGlobalKey").next(e => (qr(null !== e), e)) } pn(e, t) { return dl(e).put("targetGlobalKey", t) } In(e, t) { return hl(e).put(Ic(this.M, t)) } Tn(e, t) { let n = !1; return e.targetId > t.highestTargetId && (t.highestTargetId = e.targetId, n = !0), e.sequenceNumber > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = e.sequenceNumber, n = !0), n } getTargetCount(e) { return this.yn(e).next(e => e.targetCount) } getTargetData(e, t) { const n = ci(t), r = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]); let s = null; return hl(e).Wt({ range: r, index: "queryTargetsIndex" }, (e, n, r) => { const i = Tc(n); li(t, i.target) && (s = i, r.done()) }).next(() => s) } addMatchingKeys(e, t, n) { const r = [], s = fl(e); return t.forEach(t => { const i = Da(t.path); r.push(s.put({ targetId: n, path: i })), r.push(this.referenceDelegate.addReference(e, n, t)) }), tc.waitFor(r) } removeMatchingKeys(e, t, n) { const r = fl(e); return tc.forEach(t, t => { const s = Da(t.path); return tc.waitFor([r.delete([n, s]), this.referenceDelegate.removeReference(e, n, t)]) }) } removeMatchingKeysForTargetId(e, t) { const n = fl(e), r = IDBKeyRange.bound([t], [t + 1], !1, !0); return n.delete(r) } getMatchingKeysForTargetId(e, t) { const n = IDBKeyRange.bound([t], [t + 1], !1, !0), r = fl(e); let s = Uo(); return r.Wt({ range: n, jt: !0 }, (e, t, n) => { const r = Na(e[1]), i = new Os(r); s = s.add(i) }).next(() => s) } containsKey(e, t) { const n = Da(t.path), r = IDBKeyRange.bound([n], [as(n)], !1, !0); let s = 0; return fl(e).Wt({ index: "documentTargetsIndex", jt: !0, range: r }, ([e, t], n, r) => { 0 !== e && (s++, r.done()) }).next(() => s > 0) } Et(e, t) { return hl(e).get(t).next(e => e ? Tc(e) : null) } } function hl(e) { return dc(e, "targets") } function dl(e) { return dc(e, "targetGlobal") } function fl(e) { return dc(e, "targetDocuments") } async function pl(e) { if (e.code !== Hr.FAILED_PRECONDITION || e.message !== Ja) throw e; $r("LocalStore", "Unexpectedly lost primary lease") } function ml([e, t], [n, r]) { const s = is(e, n); return 0 === s ? is(t, r) : s } class gl { constructor(e) { this.En = e, this.buffer = new Oo(ml), this.An = 0 } Rn() { return ++this.An } bn(e) { const t = [e, this.Rn()]; if (this.buffer.size < this.En) this.buffer = this.buffer.add(t); else { const e = this.buffer.last(); ml(t, e) < 0 && (this.buffer = this.buffer.delete(e).add(t)) } } get maxValue() { return this.buffer.last()[0] } } class yl { constructor(e, t) { this.garbageCollector = e, this.asyncQueue = t, this.Pn = !1, this.Vn = null } start(e) { -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.vn(e) } stop() { this.Vn && (this.Vn.cancel(), this.Vn = null) } get started() { return null !== this.Vn } vn(e) { const t = this.Pn ? 3e5 : 6e4; $r("LruGarbageCollector", `Garbage collection scheduled in ${t}ms`), this.Vn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t, async () => { this.Vn = null, this.Pn = !0; try { await e.collectGarbage(this.garbageCollector) } catch (e) { oc(e) ? $r("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", e) : await pl(e) } await this.vn(e) }) } } class vl { constructor(e, t) { this.Sn = e, this.params = t } calculateTargetCount(e, t) { return this.Sn.Dn(e).next(e => Math.floor(t / 100 * e)) } nthSequenceNumber(e, t) { if (0 === t) return tc.resolve(ns.A); const n = new gl(t); return this.Sn.forEachTarget(e, e => n.bn(e.sequenceNumber)).next(() => this.Sn.Cn(e, e => n.bn(e))).next(() => n.maxValue) } removeTargets(e, t, n) { return this.Sn.removeTargets(e, t, n) } removeOrphanedDocuments(e, t) { return this.Sn.removeOrphanedDocuments(e, t) } collect(e, t) { return -1 === this.params.cacheSizeCollectionThreshold ? ($r("LruGarbageCollector", "Garbage collection skipped; disabled"), tc.resolve(el)) : this.getCacheSize(e).next(n => n < this.params.cacheSizeCollectionThreshold ? ($r("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), el) : this.xn(e, t)) } getCacheSize(e) { return this.Sn.getCacheSize(e) } xn(e, t) { let n, r, s, i, o, a, c; const l = Date.now(); return this.calculateTargetCount(e, this.params.percentileToCollect).next(t => (t > this.params.maximumSequenceNumbersToCollect ? ($r("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${t}`), r = this.params.maximumSequenceNumbersToCollect) : r = t, i = Date.now(), this.nthSequenceNumber(e, r))).next(r => (n = r, o = Date.now(), this.removeTargets(e, n, t))).next(t => (s = t, a = Date.now(), this.removeOrphanedDocuments(e, n))).next(e => (c = Date.now(), Mr() <= S.in.DEBUG && $r("LruGarbageCollector", `LRU Garbage Collection\n\tCounted targets in ${i - l}ms\n\tDetermined least recently used ${r} in ` + (o - i) + "ms\n" + `\tRemoved ${s} targets in ` + (a - o) + "ms\n" + `\tRemoved ${e} documents in ` + (c - a) + "ms\n" + `Total Duration: ${c - l}ms`), tc.resolve({ didRun: !0, sequenceNumbersCollected: r, targetsRemoved: s, documentsRemoved: e }))) } } class wl { constructor(e, t) { this.db = e, this.garbageCollector = function (e, t) { return new vl(e, t) }(this, t) } Dn(e) { const t = this.Nn(e); return this.db.getTargetCache().getTargetCount(e).next(e => t.next(t => e + t)) } Nn(e) { let t = 0; return this.Cn(e, e => { t++ }).next(() => t) } forEachTarget(e, t) { return this.db.getTargetCache().forEachTarget(e, t) } Cn(e, t) { return this.kn(e, (e, n) => t(n)) } addReference(e, t, n) { return bl(e, n) } removeReference(e, t, n) { return bl(e, n) } removeTargets(e, t, n) { return this.db.getTargetCache().removeTargets(e, t, n) } markPotentiallyOrphaned(e, t) { return bl(e, t) } Mn(e, t) { return function (e, t) { let n = !1; return cl(e).zt(r => il(e, r, t).next(e => (e && (n = !0), tc.resolve(!e)))).next(() => n) }(e, t) } removeOrphanedDocuments(e, t) { const n = this.db.getRemoteDocumentCache().newChangeBuffer(), r = []; let s = 0; return this.kn(e, (i, o) => { if (o <= t) { const t = this.Mn(e, i).next(t => { if (!t) return s++, n.getEntry(e, i).next(() => (n.removeEntry(i, ls.min()), fl(e).delete([0, Da(i.path)]))) }); r.push(t) } }).next(() => tc.waitFor(r)).next(() => n.apply(e)).next(() => s) } removeTarget(e, t) { const n = t.withSequenceNumber(e.currentSequenceNumber); return this.db.getTargetCache().updateTargetData(e, n) } updateLimboDocument(e, t) { return bl(e, t) } kn(e, t) { const n = fl(e); let r, s = ns.A; return n.Wt({ index: "documentTargetsIndex" }, ([e, n], { path: i, sequenceNumber: o }) => { 0 === e ? (s !== ns.A && t(new Os(Na(r)), s), s = o, r = i) : s = ns.A }).next(() => { s !== ns.A && t(new Os(Na(r)), s) }) } getCacheSize(e) { return this.db.getRemoteDocumentCache().getSize(e) } } function bl(e, t) { return fl(e).put(function (e, t) { return { targetId: 0, path: Da(e.path), sequenceNumber: t } }(t, e.currentSequenceNumber)) } class _l { constructor() { this.changes = new ko(e => e.toString(), (e, t) => e.isEqual(t)), this.changesApplied = !1 } addEntry(e) { this.assertNotApplied(), this.changes.set(e.key, e) } removeEntry(e, t) { this.assertNotApplied(), this.changes.set(e, Js.newInvalidDocument(e).setReadTime(t)) } getEntry(e, t) { this.assertNotApplied(); const n = this.changes.get(t); return void 0 !== n ? tc.resolve(n) : this.getFromCache(e, t) } getEntries(e, t) { return this.getAllFromCache(e, t) } apply(e) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e) } assertNotApplied() { } } class El { constructor(e) { this.M = e } setIndexManager(e) { this.indexManager = e } addEntry(e, t, n) { return Tl(e).put(Il(t), n) } removeEntry(e, t) { const n = Tl(e), r = Il(t); return n.delete(r) } updateMetadata(e, t) { return this.getMetadata(e).next(n => (n.byteSize += t, this.On(e, n))) } getEntry(e, t) { return Tl(e).get(Il(t)).next(e => this.$n(t, e)) } Fn(e, t) { return Tl(e).get(Il(t)).next(e => ({ document: this.$n(t, e), size: rl(e) })) } getEntries(e, t) { let n = Fo(); return this.Bn(e, t, (e, t) => { const r = this.$n(e, t); n = n.insert(e, r) }).next(() => n) } Ln(e, t) { let n = Fo(), r = new Ao(Os.comparator); return this.Bn(e, t, (e, t) => { const s = this.$n(e, t); n = n.insert(e, s), r = r.insert(e, rl(t)) }).next(() => ({ documents: n, qn: r })) } Bn(e, t, n) { if (t.isEmpty()) return tc.resolve(); const r = IDBKeyRange.bound(t.first().path.toArray(), t.last().path.toArray()), s = t.getIterator(); let i = s.getNext(); return Tl(e).Wt({ range: r }, (e, t, r) => { const o = Os.fromSegments(e); for (; i && Os.comparator(i, o) < 0;)n(i, null), i = s.getNext(); i && i.isEqual(o) && (n(i, t), i = s.hasNext() ? s.getNext() : null), i ? r.qt(i.path.toArray()) : r.done() }).next(() => { for (; i;)n(i, null), i = s.hasNext() ? s.getNext() : null }) } getAll(e, t, n) { let r = Fo(); const s = t.length + 1, i = {}; if (n.isEqual(ls.min())) { const e = t.toArray(); i.range = IDBKeyRange.lowerBound(e) } else { const e = t.toArray(), r = bc(n); i.range = IDBKeyRange.lowerBound([e, r], !0), i.index = "collectionReadTimeIndex" } return Tl(e).Wt(i, (e, n, i) => { if (e.length !== s) return; const o = this.$n(Os.fromSegments(e), n); t.isPrefixOf(o.key.path) ? r = r.insert(o.key, o) : i.done() }).next(() => r) } newChangeBuffer(e) { return new Cl(this, !!e && e.trackRemovals) } getSize(e) { return this.getMetadata(e).next(e => e.byteSize) } getMetadata(e) { return Sl(e).get("remoteDocumentGlobalKey").next(e => (qr(!!e), e)) } On(e, t) { return Sl(e).put("remoteDocumentGlobalKey", t) } $n(e, t) { if (t) { const e = vc(this.M, t); if (!e.isNoDocument() || !e.version.isEqual(ls.min())) return e } return Js.newInvalidDocument(e) } } class Cl extends _l { constructor(e, t) { super(), this.Un = e, this.trackRemovals = t, this.Kn = new ko(e => e.toString(), (e, t) => e.isEqual(t)) } applyChanges(e) { const t = []; let n = 0, r = new Oo((e, t) => is(e.canonicalString(), t.canonicalString())); return this.changes.forEach((s, i) => { const o = this.Kn.get(s); if (i.isValidDocument()) { const a = wc(this.Un.M, i); r = r.add(s.path.popLast()); const c = rl(a); n += c - o, t.push(this.Un.addEntry(e, s, a)) } else if (n -= o, this.trackRemovals) { const n = wc(this.Un.M, i.convertToNoDocument(ls.min())); t.push(this.Un.addEntry(e, s, n)) } else t.push(this.Un.removeEntry(e, s)) }), r.forEach(n => { t.push(this.Un.indexManager.addToCollectionParentIndex(e, n)) }), t.push(this.Un.updateMetadata(e, n)), tc.waitFor(t) } getFromCache(e, t) { return this.Un.Fn(e, t).next(e => (this.Kn.set(t, e.size), e.document)) } getAllFromCache(e, t) { return this.Un.Ln(e, t).next(({ documents: e, qn: t }) => (t.forEach((e, t) => { this.Kn.set(e, t) }), e)) } } function Sl(e) { return dc(e, "remoteDocumentGlobal") } function Tl(e) { return dc(e, "remoteDocuments") } function Il(e) { return e.path.toArray() } class kl { constructor(e) { this.M = e } kt(e, t, n, r) { const s = new nc("createOrUpgrade", t); n < 1 && r >= 1 && (function (e) { e.createObjectStore("owner") }(e), function (e) { e.createObjectStore("mutationQueues", { keyPath: "userId" }), e.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", Pa, { unique: !0 }), e.createObjectStore("documentMutations") }(e), Al(e), function (e) { e.createObjectStore("remoteDocuments") }(e)); let i = tc.resolve(); return n < 3 && r >= 3 && (0 !== n && (function (e) { e.deleteObjectStore("targetDocuments"), e.deleteObjectStore("targets"), e.deleteObjectStore("targetGlobal") }(e), Al(e)), i = i.next(() => function (e) { const t = e.store("targetGlobal"), n = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: ls.min().toTimestamp(), targetCount: 0 }; return t.put("targetGlobalKey", n) }(s))), n < 4 && r >= 4 && (0 !== n && (i = i.next(() => function (e, t) { return t.store("mutations").Ut().next(n => { e.deleteObjectStore("mutations"), e.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", Pa, { unique: !0 }); const r = t.store("mutations"), s = n.map(e => r.put(e)); return tc.waitFor(s) }) }(e, s))), i = i.next(() => { !function (e) { e.createObjectStore("clientMetadata", { keyPath: "clientId" }) }(e) })), n < 5 && r >= 5 && (i = i.next(() => this.Gn(s))), n < 6 && r >= 6 && (i = i.next(() => (function (e) { e.createObjectStore("remoteDocumentGlobal") }(e), this.Qn(s)))), n < 7 && r >= 7 && (i = i.next(() => this.jn(s))), n < 8 && r >= 8 && (i = i.next(() => this.Wn(e, s))), n < 9 && r >= 9 && (i = i.next(() => { !function (e) { e.objectStoreNames.contains("remoteDocumentChanges") && e.deleteObjectStore("remoteDocumentChanges") }(e), function (e) { const t = e.objectStore("remoteDocuments"); t.createIndex("readTimeIndex", "readTime", { unique: !1 }), t.createIndex("collectionReadTimeIndex", $a, { unique: !1 }) }(t) })), n < 10 && r >= 10 && (i = i.next(() => this.zn(s))), n < 11 && r >= 11 && (i = i.next(() => { !function (e) { e.createObjectStore("bundles", { keyPath: "bundleId" }) }(e), function (e) { e.createObjectStore("namedQueries", { keyPath: "name" }) }(e) })), n < 12 && r >= 12 && (i = i.next(() => { !function (e) { const t = e.createObjectStore("documentOverlays", { keyPath: Wa }); t.createIndex("collectionPathOverlayIndex", Ya, { unique: !1 }), t.createIndex("collectionGroupOverlayIndex", Ka, { unique: !1 }) }(e) })), n < 13 && r >= 13 && (i = i.next(() => { !function (e) { e.createObjectStore("indexConfiguration", { keyPath: "indexId", autoIncrement: !0 }).createIndex("collectionGroupIndex", "collectionGroup", { unique: !1 }), e.createObjectStore("indexState", { keyPath: qa }).createIndex("sequenceNumberIndex", za, { unique: !1 }), e.createObjectStore("indexEntries", { keyPath: Ha }).createIndex("documentKeyIndex", Ga, { unique: !1 }) }(e) })), i } Qn(e) { let t = 0; return e.store("remoteDocuments").Wt((e, n) => { t += rl(n) }).next(() => { const n = { byteSize: t }; return e.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n) }) } Gn(e) { const t = e.store("mutationQueues"), n = e.store("mutations"); return t.Ut().next(t => tc.forEach(t, t => { const r = IDBKeyRange.bound([t.userId, -1], [t.userId, t.lastAcknowledgedBatchId]); return n.Ut("userMutationsIndex", r).next(n => tc.forEach(n, n => { qr(n.userId === t.userId); const r = Sc(this.M, n); return nl(e, t.userId, r).next(() => { }) })) })) } jn(e) { const t = e.store("targetDocuments"), n = e.store("remoteDocuments"); return e.store("targetGlobal").get("targetGlobalKey").next(e => { const r = []; return n.Wt((n, s) => { const i = new ps(n), o = function (e) { return [0, Da(e)] }(i); r.push(t.get(o).next(n => n ? tc.resolve() : (n => t.put({ targetId: 0, path: Da(n), sequenceNumber: e.highestListenSequenceNumber }))(i))) }).next(() => tc.waitFor(r)) }) } Wn(e, t) { e.createObjectStore("collectionParents", { keyPath: ja }); const n = t.store("collectionParents"), r = new Wc, s = e => { if (r.add(e)) { const t = e.lastSegment(), r = e.popLast(); return n.put({ collectionId: t, parent: Da(r) }) } }; return t.store("remoteDocuments").Wt({ jt: !0 }, (e, t) => { const n = new ps(e); return s(n.popLast()) }).next(() => t.store("documentMutations").Wt({ jt: !0 }, ([e, t, n], r) => { const i = Na(t); return s(i.popLast()) })) } zn(e) { const t = e.store("targets"); return t.Wt((e, n) => { const r = Tc(n), s = Ic(this.M, r); return t.put(s) }) } } function Al(e) { e.createObjectStore("targetDocuments", { keyPath: Va }).createIndex("documentTargetsIndex", Ua, { unique: !0 }), e.createObjectStore("targets", { keyPath: "targetId" }).createIndex("queryTargetsIndex", Ba, { unique: !0 }), e.createObjectStore("targetGlobal") } const xl = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time."; class Dl { constructor(e, t, n, r, s, i, o, a, c, l, u = 12) { if (this.allowTabSynchronization = e, this.persistenceKey = t, this.clientId = n, this.Hn = s, this.window = i, this.document = o, this.Jn = c, this.Yn = l, this.Xn = u, this.Zn = null, this.ts = !1, this.isPrimary = !1, this.networkEnabled = !0, this.es = null, this.inForeground = !1, this.ns = null, this.ss = null, this.rs = Number.NEGATIVE_INFINITY, this.os = e => Promise.resolve(), !Dl.vt()) throw new Gr(Hr.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled."); this.referenceDelegate = new wl(this, r), this.us = t + "main", this.M = new yc(a), this.cs = new rc(this.us, this.Xn, new kl(this.M)), this.hs = new ul(this.referenceDelegate, this.M), this.ls = function (e) { return new El(e) }(this.M), this.fs = new Dc, this.window && this.window.localStorage ? this.ds = this.window.localStorage : (this.ds = null, !1 === l && Br("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.")) } start() { return this._s().then(() => { if (!this.isPrimary && !this.allowTabSynchronization) throw new Gr(Hr.FAILED_PRECONDITION, xl); return this.ws(), this.gs(), this.ys(), this.runTransaction("getHighestListenSequenceNumber", "readonly", e => this.hs.getHighestSequenceNumber(e)) }).then(e => { this.Zn = new ns(e, this.Jn) }).then(() => { this.ts = !0 }).catch(e => (this.cs && this.cs.close(), Promise.reject(e))) } ps(e) { return this.os = async t => { if (this.started) return e(t) }, e(this.isPrimary) } setDatabaseDeletedListener(e) { this.cs.Ot(async t => { null === t.newVersion && await e() }) } setNetworkEnabled(e) { this.networkEnabled !== e && (this.networkEnabled = e, this.Hn.enqueueAndForget(async () => { this.started && await this._s() })) } _s() { return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", e => Rl(e).put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground }).next(() => { if (this.isPrimary) return this.Is(e).next(e => { e || (this.isPrimary = !1, this.Hn.enqueueRetryable(() => this.os(!1))) }) }).next(() => this.Ts(e)).next(t => this.isPrimary && !t ? this.Es(e).next(() => !1) : !!t && this.As(e).next(() => !0))).catch(e => { if (oc(e)) return $r("IndexedDbPersistence", "Failed to extend owner lease: ", e), this.isPrimary; if (!this.allowTabSynchronization) throw e; return $r("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), !1 }).then(e => { this.isPrimary !== e && this.Hn.enqueueRetryable(() => this.os(e)), this.isPrimary = e }) } Is(e) { return Ol(e).get("owner").next(e => tc.resolve(this.Rs(e))) } bs(e) { return Rl(e).delete(this.clientId) } async Ps() { if (this.isPrimary && !this.Vs(this.rs, 18e5)) { this.rs = Date.now(); const e = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", e => { const t = dc(e, "clientMetadata"); return t.Ut().next(e => { const n = this.vs(e, 18e5), r = e.filter(e => -1 === n.indexOf(e)); return tc.forEach(r, e => t.delete(e.clientId)).next(() => r) }) }).catch(() => []); if (this.ds) for (const t of e) this.ds.removeItem(this.Ss(t.clientId)) } } ys() { this.ss = this.Hn.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this._s().then(() => this.Ps()).then(() => this.ys())) } Rs(e) { return !!e && e.ownerId === this.clientId } Ts(e) { return this.Yn ? tc.resolve(!0) : Ol(e).get("owner").next(t => { if (null !== t && this.Vs(t.leaseTimestampMs, 5e3) && !this.Ds(t.ownerId)) { if (this.Rs(t) && this.networkEnabled) return !0; if (!this.Rs(t)) { if (!t.allowTabSynchronization) throw new Gr(Hr.FAILED_PRECONDITION, xl); return !1 } } return !(!this.networkEnabled || !this.inForeground) || Rl(e).Ut().next(e => void 0 === this.vs(e, 5e3).find(e => { if (this.clientId !== e.clientId) { const t = !this.inForeground && e.inForeground, n = this.networkEnabled === e.networkEnabled; if (!this.networkEnabled && e.networkEnabled || t && n) return !0 } return !1 })) }).next(e => (this.isPrimary !== e && $r("IndexedDbPersistence", `Client ${e ? "is" : "is not"} eligible for a primary lease.`), e)) } async shutdown() { this.ts = !1, this.Cs(), this.ss && (this.ss.cancel(), this.ss = null), this.xs(), this.Ns(), await this.cs.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], e => { const t = new hc(e, ns.A); return this.Es(t).next(() => this.bs(t)) }), this.cs.close(), this.ks() } vs(e, t) { return e.filter(e => this.Vs(e.updateTimeMs, t) && !this.Ds(e.clientId)) } Ms() { return this.runTransaction("getActiveClients", "readonly", e => Rl(e).Ut().next(e => this.vs(e, 18e5).map(e => e.clientId))) } get started() { return this.ts } getMutationQueue(e, t) { return sl.Yt(e, this.M, t, this.referenceDelegate) } getTargetCache() { return this.hs } getRemoteDocumentCache() { return this.ls } getIndexManager(e) { return new Kc(e) } getDocumentOverlayCache(e) { return Nc.Yt(this.M, e) } getBundleCache() { return this.fs } runTransaction(e, t, n) { $r("IndexedDbPersistence", "Starting transaction:", e); const r = "readonly" === t ? "readonly" : "readwrite", s = 13 === (i = this.Xn) ? Qa : 12 === i ? Za : 11 === i ? Xa : void jr(); var i; let o; return this.cs.runTransaction(e, r, s, r => (o = new hc(r, this.Zn ? this.Zn.next() : ns.A), "readwrite-primary" === t ? this.Is(o).next(e => !!e || this.Ts(o)).next(t => { if (!t) throw Br(`Failed to obtain primary lease for action '${e}'.`), this.isPrimary = !1, this.Hn.enqueueRetryable(() => this.os(!1)), new Gr(Hr.FAILED_PRECONDITION, Ja); return n(o) }).next(e => this.As(o).next(() => e)) : this.Os(o).next(() => n(o)))).then(e => (o.raiseOnCommittedEvent(), e)) } Os(e) { return Ol(e).get("owner").next(e => { if (null !== e && this.Vs(e.leaseTimestampMs, 5e3) && !this.Ds(e.ownerId) && !this.Rs(e) && !(this.Yn || this.allowTabSynchronization && e.allowTabSynchronization)) throw new Gr(Hr.FAILED_PRECONDITION, xl) }) } As(e) { const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() }; return Ol(e).put("owner", t) } static vt() { return rc.vt() } Es(e) { const t = Ol(e); return t.get("owner").next(e => this.Rs(e) ? ($r("IndexedDbPersistence", "Releasing primary lease."), t.delete("owner")) : tc.resolve()) } Vs(e, t) { const n = Date.now(); return !(e < n - t || e > n && (Br(`Detected an update time that is in the future: ${e} > ${n}`), 1)) } ws() { null !== this.document && "function" == typeof this.document.addEventListener && (this.ns = () => { this.Hn.enqueueAndForget(() => (this.inForeground = "visible" === this.document.visibilityState, this._s())) }, this.document.addEventListener("visibilitychange", this.ns), this.inForeground = "visible" === this.document.visibilityState) } xs() { this.ns && (this.document.removeEventListener("visibilitychange", this.ns), this.ns = null) } gs() { var e; "function" == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) && (this.es = () => { this.Cs(), (0, T.G6)() && navigator.appVersion.match(/Version\/1[45]/) && this.Hn.enterRestrictedMode(!0), this.Hn.enqueueAndForget(() => this.shutdown()) }, this.window.addEventListener("pagehide", this.es)) } Ns() { this.es && (this.window.removeEventListener("pagehide", this.es), this.es = null) } Ds(e) { var t; try { const n = null !== (null === (t = this.ds) || void 0 === t ? void 0 : t.getItem(this.Ss(e))); return $r("IndexedDbPersistence", `Client '${e}' ${n ? "is" : "is not"} zombied in LocalStorage`), n } catch (e) { return Br("IndexedDbPersistence", "Failed to get zombied client id.", e), !1 } } Cs() { if (this.ds) try { this.ds.setItem(this.Ss(this.clientId), String(Date.now())) } catch (B) { Br("Failed to set zombie client id.", B) } } ks() { if (this.ds) try { this.ds.removeItem(this.Ss(this.clientId)) } catch (B) { } } Ss(e) { return `firestore_zombie_${this.persistenceKey}_${e}` } } function Ol(e) { return dc(e, "owner") } function Rl(e) { return dc(e, "clientMetadata") } function Nl(e, t) { let n = e.projectId; return e.isDefaultDatabase || (n += "." + e.database), "firestore/" + t + "/" + n + "/" } class Pl { constructor(e, t) { this.progress = e, this.$s = t } } class Fl { constructor(e, t, n) { this.ls = e, this.Fs = t, this.indexManager = n } Bs(e, t) { return this.Fs.getAllMutationBatchesAffectingDocumentKey(e, t).next(n => this.Ls(e, t, n)) } Ls(e, t, n) { return this.ls.getEntry(e, t).next(e => { for (const t of n) t.applyToLocalView(e); return e }) } qs(e, t) { e.forEach((e, n) => { for (const r of t) r.applyToLocalView(n) }) } Us(e, t) { return this.ls.getEntries(e, t).next(t => this.Ks(e, t).next(() => t)) } Ks(e, t) { return this.Fs.getAllMutationBatchesAffectingDocumentKeys(e, t).next(e => this.qs(t, e)) } Gs(e, t, n) { return function (e) { return Os.isDocumentKey(e.path) && null === e.collectionGroup && 0 === e.filters.length }(t) ? this.Qs(e, t.path) : Ni(t) ? this.js(e, t, n) : this.Ws(e, t, n) } Qs(e, t) { return this.Bs(e, new Os(t)).next(e => { let t = Mo(); return e.isFoundDocument() && (t = t.insert(e.key, e)), t }) } js(e, t, n) { const r = t.collectionGroup; let s = Mo(); return this.indexManager.getCollectionParents(e, r).next(i => tc.forEach(i, i => { const o = function (e, t) { return new Ii(t, null, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt) }(t, i.child(r)); return this.Ws(e, o, n).next(e => { e.forEach((e, t) => { s = s.insert(e, t) }) }) }).next(() => s)) } Ws(e, t, n) { let r; return this.ls.getAll(e, t.path, n).next(n => (r = n, this.Fs.getAllMutationBatchesAffectingQuery(e, t))).next(e => { for (const t of e) for (const e of t.mutations) { const n = e.key; let s = r.get(n); null == s && (s = Js.newInvalidDocument(n), r = r.insert(n, s)), uo(e, s, t.localWriteTime), s.isFoundDocument() || (r = r.remove(n)) } }).next(() => (r.forEach((e, n) => { Vi(t, n) || (r = r.remove(e)) }), r)) } } class Ll { constructor(e, t, n, r) { this.targetId = e, this.fromCache = t, this.zs = n, this.Hs = r } static Js(e, t) { let n = Uo(), r = Uo(); for (const s of t.docChanges) switch (s.type) { case 0: n = n.add(s.doc.key); break; case 1: r = r.add(s.doc.key) }return new Ll(e, t.fromCache, n, r) } } class Ml { Ys(e) { this.Xs = e } Gs(e, t, n, r) { return function (e) { return 0 === e.filters.length && null === e.limit && null == e.startAt && null == e.endAt && (0 === e.explicitOrderBy.length || 1 === e.explicitOrderBy.length && e.explicitOrderBy[0].field.isKeyField()) }(t) || n.isEqual(ls.min()) ? this.Zs(e, t) : this.Xs.Us(e, r).next(s => { const i = this.ti(t, s); return (xi(t) || Di(t)) && this.ei(t.limitType, i, r, n) ? this.Zs(e, t) : (Mr() <= S.in.DEBUG && $r("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), Bi(t)), this.Xs.Gs(e, t, n).next(e => (i.forEach(t => { e = e.insert(t.key, t) }), e))) }) } ti(e, t) { let n = new Oo(Ui(e)); return t.forEach((t, r) => { Vi(e, r) && (n = n.add(r)) }), n } ei(e, t, n, r) { if (n.size !== t.size) return !0; const s = "F" === e ? t.last() : t.first(); return !!s && (s.hasPendingWrites || s.version.compareTo(r) > 0) } Zs(e, t) { return Mr() <= S.in.DEBUG && $r("QueryEngine", "Using full collection scan to execute query:", Bi(t)), this.Xs.Gs(e, t, ls.min()) } } class $l { constructor(e, t, n, r) { this.persistence = e, this.ni = t, this.M = r, this.si = new Ao(is), this.ii = new ko(e => ci(e), li), this.ri = ls.min(), this.oi = e.getRemoteDocumentCache(), this.hs = e.getTargetCache(), this.fs = e.getBundleCache(), this.ai(n) } ai(e) { this.indexManager = this.persistence.getIndexManager(e), this.Fs = this.persistence.getMutationQueue(e, this.indexManager), this.ui = new Fl(this.oi, this.Fs, this.indexManager), this.oi.setIndexManager(this.indexManager), this.ni.Ys(this.ui) } collectGarbage(e) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", t => e.collect(t, this.si)) } } function Bl(e, t, n, r) { return new $l(e, t, n, r) } async function Vl(e, t) { const n = zr(e); return await n.persistence.runTransaction("Handle user change", "readonly", e => { let r; return n.Fs.getAllMutationBatches(e).next(s => (r = s, n.ai(t), n.Fs.getAllMutationBatches(e))).next(t => { const s = [], i = []; let o = Uo(); for (const e of r) { s.push(e.batchId); for (const t of e.mutations) o = o.add(t.key) } for (const e of t) { i.push(e.batchId); for (const t of e.mutations) o = o.add(t.key) } return n.ui.Us(e, o).next(e => ({ ci: e, removedBatchIds: s, addedBatchIds: i })) }) }) } function Ul(e) { const t = zr(e); return t.persistence.runTransaction("Get last remote snapshot version", "readonly", e => t.hs.getLastRemoteSnapshotVersion(e)) } function jl(e, t, n) { let r = Uo(); return n.forEach(e => r = r.add(e)), t.getEntries(e, r).next(e => { let r = Fo(); return n.forEach((n, s) => { const i = e.get(n); s.isNoDocument() && s.version.isEqual(ls.min()) ? (t.removeEntry(n, s.readTime), r = r.insert(n, s)) : !i.isValidDocument() || s.version.compareTo(i.version) > 0 || 0 === s.version.compareTo(i.version) && i.hasPendingWrites ? (t.addEntry(s), r = r.insert(n, s)) : $r("LocalStore", "Ignoring outdated watch update for ", n, ". Current version:", i.version, " Watch version:", s.version) }), r }) } function ql(e, t) { const n = zr(e); return n.persistence.runTransaction("Get next mutation batch", "readonly", e => (void 0 === t && (t = -1), n.Fs.getNextMutationBatchAfterBatchId(e, t))) } function zl(e, t) { const n = zr(e); return n.persistence.runTransaction("Allocate target", "readwrite", e => { let r; return n.hs.getTargetData(e, t).next(s => s ? (r = s, tc.resolve(r)) : n.hs.allocateTargetId(e).next(s => (r = new gc(t, s, 0, e.currentSequenceNumber), n.hs.addTargetData(e, r).next(() => r)))) }).then(e => { const r = n.si.get(e.targetId); return (null === r || e.snapshotVersion.compareTo(r.snapshotVersion) > 0) && (n.si = n.si.insert(e.targetId, e), n.ii.set(t, e.targetId)), e }) } async function Hl(e, t, n) { const r = zr(e), s = r.si.get(t), i = n ? "readwrite" : "readwrite-primary"; try { n || await r.persistence.runTransaction("Release target", i, e => r.persistence.referenceDelegate.removeTarget(e, s)) } catch (e) { if (!oc(e)) throw e; $r("LocalStore", `Failed to update sequence numbers for target ${t}: ${e}`) } r.si = r.si.remove(t), r.ii.delete(s.target) } function Gl(e, t, n) { const r = zr(e); let s = ls.min(), i = Uo(); return r.persistence.runTransaction("Execute query", "readonly", e => function (e, t, n) { const r = zr(e), s = r.ii.get(n); return void 0 !== s ? tc.resolve(r.si.get(s)) : r.hs.getTargetData(t, n) }(r, e, Fi(t)).next(t => { if (t) return s = t.lastLimboFreeSnapshotVersion, r.hs.getMatchingKeysForTargetId(e, t.targetId).next(e => { i = e }) }).next(() => r.ni.Gs(e, t, n ? s : ls.min(), n ? i : Uo())).next(e => ({ documents: e, hi: i }))) } function Wl(e, t) { const n = zr(e), r = zr(n.hs), s = n.si.get(t); return s ? Promise.resolve(s.target) : n.persistence.runTransaction("Get target data", "readonly", e => r.Et(e, t).next(e => e ? e.target : null)) } function Yl(e) { const t = zr(e); return t.persistence.runTransaction("Get new document changes", "readonly", e => function (e, t, n) { const r = zr(e); let s = Fo(), i = bc(n); const o = Tl(t), a = IDBKeyRange.lowerBound(i, !0); return o.Wt({ index: "readTimeIndex", range: a }, (e, t) => { const n = vc(r.M, t); s = s.insert(n.key, n), i = t.readTime }).next(() => ({ $s: s, readTime: _c(i) })) }(t.oi, e, t.ri)).then(({ $s: e, readTime: n }) => (t.ri = n, e)) } async function Kl(e, t, n = Uo()) { const r = await zl(e, Fi(kc(t.bundledQuery))), s = zr(e); return s.persistence.runTransaction("Save named query", "readwrite", e => { const i = ia(t.readTime); if (r.snapshotVersion.compareTo(i) >= 0) return s.fs.saveNamedQuery(e, t); const o = r.withResumeToken(vs.EMPTY_BYTE_STRING, i); return s.si = s.si.insert(o.targetId, o), s.hs.updateTargetData(e, o).next(() => s.hs.removeMatchingKeysForTargetId(e, r.targetId)).next(() => s.hs.addMatchingKeys(e, n, r.targetId)).next(() => s.fs.saveNamedQuery(e, t)) }) } class Xl { constructor(e) { this.M = e, this._i = new Map, this.wi = new Map } getBundleMetadata(e, t) { return tc.resolve(this._i.get(t)) } saveBundleMetadata(e, t) { var n; return this._i.set(t.id, { id: (n = t).id, version: n.version, createTime: ia(n.createTime) }), tc.resolve() } getNamedQuery(e, t) { return tc.resolve(this.wi.get(t)) } saveNamedQuery(e, t) { return this.wi.set(t.name, function (e) { return { name: e.name, query: kc(e.bundledQuery), readTime: ia(e.readTime) } }(t)), tc.resolve() } } class Zl { constructor() { this.overlays = new Ao(Os.comparator), this.mi = new Map } getOverlay(e, t) { return tc.resolve(this.overlays.get(t)) } saveOverlays(e, t, n) { return n.forEach((n, r) => { this.Xt(e, t, r) }), tc.resolve() } removeOverlaysForBatchId(e, t, n) { const r = this.mi.get(n); return void 0 !== r && (r.forEach(e => this.overlays = this.overlays.remove(e)), this.mi.delete(n)), tc.resolve() } getOverlaysForCollection(e, t, n) { const r = $o(), s = t.length + 1, i = new Os(t.child("")), o = this.overlays.getIteratorFrom(i); for (; o.hasNext();) { const e = o.getNext().value, i = e.getKey(); if (!t.isPrefixOf(i.path)) break; i.path.length === s && e.largestBatchId > n && r.set(e.getKey(), e) } return tc.resolve(r) } getOverlaysForCollectionGroup(e, t, n, r) { let s = new Ao((e, t) => e - t); const i = this.overlays.getIterator(); for (; i.hasNext();) { const e = i.getNext().value; if (e.getKey().getCollectionGroup() === t && e.largestBatchId > n) { let t = s.get(e.largestBatchId); null === t && (t = $o(), s = s.insert(e.largestBatchId, t)), t.set(e.getKey(), e) } } const o = $o(), a = s.getIterator(); for (; a.hasNext() && (a.getNext().value.forEach((e, t) => o.set(e, t)), !(o.size() >= r));); return tc.resolve(o) } Xt(e, t, n) { if (null === n) return; const r = this.overlays.get(n.key); if (null !== r) { const e = this.mi.get(r.largestBatchId).delete(n.key); this.mi.set(r.largestBatchId, e) } this.overlays = this.overlays.insert(n.key, new mc(t, n)); let s = this.mi.get(t); void 0 === s && (s = Uo(), this.mi.set(t, s)), this.mi.set(t, s.add(n.key)) } } class Ql { constructor() { this.gi = new Oo(Jl.yi), this.pi = new Oo(Jl.Ii) } isEmpty() { return this.gi.isEmpty() } addReference(e, t) { const n = new Jl(e, t); this.gi = this.gi.add(n), this.pi = this.pi.add(n) } Ti(e, t) { e.forEach(e => this.addReference(e, t)) } removeReference(e, t) { this.Ei(new Jl(e, t)) } Ai(e, t) { e.forEach(e => this.removeReference(e, t)) } Ri(e) { const t = new Os(new ps([])), n = new Jl(t, e), r = new Jl(t, e + 1), s = []; return this.pi.forEachInRange([n, r], e => { this.Ei(e), s.push(e.key) }), s } bi() { this.gi.forEach(e => this.Ei(e)) } Ei(e) { this.gi = this.gi.delete(e), this.pi = this.pi.delete(e) } Pi(e) { const t = new Os(new ps([])), n = new Jl(t, e), r = new Jl(t, e + 1); let s = Uo(); return this.pi.forEachInRange([n, r], e => { s = s.add(e.key) }), s } containsKey(e) { const t = new Jl(e, 0), n = this.gi.firstAfterOrEqual(t); return null !== n && e.isEqual(n.key) } } class Jl { constructor(e, t) { this.key = e, this.Vi = t } static yi(e, t) { return Os.comparator(e.key, t.key) || is(e.Vi, t.Vi) } static Ii(e, t) { return is(e.Vi, t.Vi) || Os.comparator(e.key, t.key) } } class eu { constructor(e, t) { this.indexManager = e, this.referenceDelegate = t, this.Fs = [], this.vi = 1, this.Si = new Oo(Jl.yi) } checkEmpty(e) { return tc.resolve(0 === this.Fs.length) } addMutationBatch(e, t, n, r) { const s = this.vi; this.vi++; const i = new fc(s, t, n, r); this.Fs.push(i); for (const o of r) this.Si = this.Si.add(new Jl(o.key, s)), this.indexManager.addToCollectionParentIndex(e, o.key.path.popLast()); return tc.resolve(i) } lookupMutationBatch(e, t) { return tc.resolve(this.Di(t)) } getNextMutationBatchAfterBatchId(e, t) { const n = this.Ci(t + 1), r = n < 0 ? 0 : n; return tc.resolve(this.Fs.length > r ? this.Fs[r] : null) } getHighestUnacknowledgedBatchId() { return tc.resolve(0 === this.Fs.length ? -1 : this.vi - 1) } getAllMutationBatches(e) { return tc.resolve(this.Fs.slice()) } getAllMutationBatchesAffectingDocumentKey(e, t) { const n = new Jl(t, 0), r = new Jl(t, Number.POSITIVE_INFINITY), s = []; return this.Si.forEachInRange([n, r], e => { const t = this.Di(e.Vi); s.push(t) }), tc.resolve(s) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let n = new Oo(is); return t.forEach(e => { const t = new Jl(e, 0), r = new Jl(e, Number.POSITIVE_INFINITY); this.Si.forEachInRange([t, r], e => { n = n.add(e.Vi) }) }), tc.resolve(this.xi(n)) } getAllMutationBatchesAffectingQuery(e, t) { const n = t.path, r = n.length + 1; let s = n; Os.isDocumentKey(s) || (s = s.child("")); const i = new Jl(new Os(s), 0); let o = new Oo(is); return this.Si.forEachWhile(e => { const t = e.key.path; return !!n.isPrefixOf(t) && (t.length === r && (o = o.add(e.Vi)), !0) }, i), tc.resolve(this.xi(o)) } xi(e) { const t = []; return e.forEach(e => { const n = this.Di(e); null !== n && t.push(n) }), t } removeMutationBatch(e, t) { qr(0 === this.Ni(t.batchId, "removed")), this.Fs.shift(); let n = this.Si; return tc.forEach(t.mutations, r => { const s = new Jl(r.key, t.batchId); return n = n.delete(s), this.referenceDelegate.markPotentiallyOrphaned(e, r.key) }).next(() => { this.Si = n }) } dn(e) { } containsKey(e, t) { const n = new Jl(t, 0), r = this.Si.firstAfterOrEqual(n); return tc.resolve(t.isEqual(r && r.key)) } performConsistencyCheck(e) { return tc.resolve() } Ni(e, t) { return this.Ci(e) } Ci(e) { return 0 === this.Fs.length ? 0 : e - this.Fs[0].batchId } Di(e) { const t = this.Ci(e); return t < 0 || t >= this.Fs.length ? null : this.Fs[t] } } class tu { constructor(e) { this.ki = e, this.docs = new Ao(Os.comparator), this.size = 0 } setIndexManager(e) { this.indexManager = e } addEntry(e, t) { const n = t.key, r = this.docs.get(n), s = r ? r.size : 0, i = this.ki(t); return this.docs = this.docs.insert(n, { document: t.mutableCopy(), size: i }), this.size += i - s, this.indexManager.addToCollectionParentIndex(e, n.path.popLast()) } removeEntry(e) { const t = this.docs.get(e); t && (this.docs = this.docs.remove(e), this.size -= t.size) } getEntry(e, t) { const n = this.docs.get(t); return tc.resolve(n ? n.document.mutableCopy() : Js.newInvalidDocument(t)) } getEntries(e, t) { let n = Fo(); return t.forEach(e => { const t = this.docs.get(e); n = n.insert(e, t ? t.document.mutableCopy() : Js.newInvalidDocument(e)) }), tc.resolve(n) } getAll(e, t, n) { let r = Fo(); const s = new Os(t.child("")), i = this.docs.getIteratorFrom(s); for (; i.hasNext();) { const { key: e, value: { document: s } } = i.getNext(); if (!t.isPrefixOf(e.path)) break; e.path.length > t.length + 1 || s.readTime.compareTo(n) <= 0 || (r = r.insert(s.key, s.mutableCopy())) } return tc.resolve(r) } Mi(e, t) { return tc.forEach(this.docs, e => t(e)) } newChangeBuffer(e) { return new nu(this) } getSize(e) { return tc.resolve(this.size) } } class nu extends _l { constructor(e) { super(), this.Un = e } applyChanges(e) { const t = []; return this.changes.forEach((n, r) => { r.isValidDocument() ? t.push(this.Un.addEntry(e, r)) : this.Un.removeEntry(n) }), tc.waitFor(t) } getFromCache(e, t) { return this.Un.getEntry(e, t) } getAllFromCache(e, t) { return this.Un.getEntries(e, t) } } class ru { constructor(e) { this.persistence = e, this.Oi = new ko(e => ci(e), li), this.lastRemoteSnapshotVersion = ls.min(), this.highestTargetId = 0, this.$i = 0, this.Fi = new Ql, this.targetCount = 0, this.Bi = ll.mn() } forEachTarget(e, t) { return this.Oi.forEach((e, n) => t(n)), tc.resolve() } getLastRemoteSnapshotVersion(e) { return tc.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(e) { return tc.resolve(this.$i) } allocateTargetId(e) { return this.highestTargetId = this.Bi.next(), tc.resolve(this.highestTargetId) } setTargetsMetadata(e, t, n) { return n && (this.lastRemoteSnapshotVersion = n), t > this.$i && (this.$i = t), tc.resolve() } In(e) { this.Oi.set(e.target, e); const t = e.targetId; t > this.highestTargetId && (this.Bi = new ll(t), this.highestTargetId = t), e.sequenceNumber > this.$i && (this.$i = e.sequenceNumber) } addTargetData(e, t) { return this.In(t), this.targetCount += 1, tc.resolve() } updateTargetData(e, t) { return this.In(t), tc.resolve() } removeTargetData(e, t) { return this.Oi.delete(t.target), this.Fi.Ri(t.targetId), this.targetCount -= 1, tc.resolve() } removeTargets(e, t, n) { let r = 0; const s = []; return this.Oi.forEach((i, o) => { o.sequenceNumber <= t && null === n.get(o.targetId) && (this.Oi.delete(i), s.push(this.removeMatchingKeysForTargetId(e, o.targetId)), r++) }), tc.waitFor(s).next(() => r) } getTargetCount(e) { return tc.resolve(this.targetCount) } getTargetData(e, t) { const n = this.Oi.get(t) || null; return tc.resolve(n) } addMatchingKeys(e, t, n) { return this.Fi.Ti(t, n), tc.resolve() } removeMatchingKeys(e, t, n) { this.Fi.Ai(t, n); const r = this.persistence.referenceDelegate, s = []; return r && t.forEach(t => { s.push(r.markPotentiallyOrphaned(e, t)) }), tc.waitFor(s) } removeMatchingKeysForTargetId(e, t) { return this.Fi.Ri(t), tc.resolve() } getMatchingKeysForTargetId(e, t) { const n = this.Fi.Pi(t); return tc.resolve(n) } containsKey(e, t) { return tc.resolve(this.Fi.containsKey(t)) } } class su { constructor(e, t) { this.Li = {}, this.overlays = {}, this.Zn = new ns(0), this.ts = !1, this.ts = !0, this.referenceDelegate = e(this), this.hs = new ru(this), this.indexManager = new Gc, this.ls = function (e) { return new tu(e) }(e => this.referenceDelegate.qi(e)), this.M = new yc(t), this.fs = new Xl(this.M) } start() { return Promise.resolve() } shutdown() { return this.ts = !1, Promise.resolve() } get started() { return this.ts } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(e) { return this.indexManager } getDocumentOverlayCache(e) { let t = this.overlays[e.toKey()]; return t || (t = new Zl, this.overlays[e.toKey()] = t), t } getMutationQueue(e, t) { let n = this.Li[e.toKey()]; return n || (n = new eu(t, this.referenceDelegate), this.Li[e.toKey()] = n), n } getTargetCache() { return this.hs } getRemoteDocumentCache() { return this.ls } getBundleCache() { return this.fs } runTransaction(e, t, n) { $r("MemoryPersistence", "Starting transaction:", e); const r = new iu(this.Zn.next()); return this.referenceDelegate.Ui(), n(r).next(e => this.referenceDelegate.Ki(r).next(() => e)).toPromise().then(e => (r.raiseOnCommittedEvent(), e)) } Gi(e, t) { return tc.or(Object.values(this.Li).map(n => () => n.containsKey(e, t))) } } class iu extends ec { constructor(e) { super(), this.currentSequenceNumber = e } } class ou { constructor(e) { this.persistence = e, this.Qi = new Ql, this.ji = null } static Wi(e) { return new ou(e) } get zi() { if (this.ji) return this.ji; throw jr() } addReference(e, t, n) { return this.Qi.addReference(n, t), this.zi.delete(n.toString()), tc.resolve() } removeReference(e, t, n) { return this.Qi.removeReference(n, t), this.zi.add(n.toString()), tc.resolve() } markPotentiallyOrphaned(e, t) { return this.zi.add(t.toString()), tc.resolve() } removeTarget(e, t) { this.Qi.Ri(t.targetId).forEach(e => this.zi.add(e.toString())); const n = this.persistence.getTargetCache(); return n.getMatchingKeysForTargetId(e, t.targetId).next(e => { e.forEach(e => this.zi.add(e.toString())) }).next(() => n.removeTargetData(e, t)) } Ui() { this.ji = new Set } Ki(e) { const t = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return tc.forEach(this.zi, n => { const r = Os.fromPath(n); return this.Hi(e, r).next(e => { e || t.removeEntry(r, ls.min()) }) }).next(() => (this.ji = null, t.apply(e))) } updateLimboDocument(e, t) { return this.Hi(e, t).next(e => { e ? this.zi.delete(t.toString()) : this.zi.add(t.toString()) }) } qi(e) { return 0 } Hi(e, t) { return tc.or([() => tc.resolve(this.Qi.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Gi(e, t)]) } } function au(e, t) { return `firestore_clients_${e}_${t}` } function cu(e, t, n) { let r = `firestore_mutations_${e}_${n}`; return t.isAuthenticated() && (r += `_${t.uid}`), r } function lu(e, t) { return `firestore_targets_${e}_${t}` } class uu { constructor(e, t, n, r) { this.user = e, this.batchId = t, this.state = n, this.error = r } static Ji(e, t, n) { const r = JSON.parse(n); let s, i = "object" == typeof r && -1 !== ["pending", "acknowledged", "rejected"].indexOf(r.state) && (void 0 === r.error || "object" == typeof r.error); return i && r.error && (i = "string" == typeof r.error.message && "string" == typeof r.error.code, i && (s = new Gr(r.error.code, r.error.message))), i ? new uu(e, t, r.state, s) : (Br("SharedClientState", `Failed to parse mutation state for ID '${t}': ${n}`), null) } Yi() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class hu { constructor(e, t, n) { this.targetId = e, this.state = t, this.error = n } static Ji(e, t) { const n = JSON.parse(t); let r, s = "object" == typeof n && -1 !== ["not-current", "current", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error); return s && n.error && (s = "string" == typeof n.error.message && "string" == typeof n.error.code, s && (r = new Gr(n.error.code, n.error.message))), s ? new hu(e, n.state, r) : (Br("SharedClientState", `Failed to parse target state for ID '${e}': ${t}`), null) } Yi() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class du { constructor(e, t) { this.clientId = e, this.activeTargetIds = t } static Ji(e, t) { const n = JSON.parse(t); let r = "object" == typeof n && n.activeTargetIds instanceof Array, s = qo(); for (let i = 0; r && i < n.activeTargetIds.length; ++i)r = Ds(n.activeTargetIds[i]), s = s.add(n.activeTargetIds[i]); return r ? new du(e, s) : (Br("SharedClientState", `Failed to parse client data for instance '${e}': ${t}`), null) } } class fu { constructor(e, t) { this.clientId = e, this.onlineState = t } static Ji(e) { const t = JSON.parse(e); return "object" == typeof t && -1 !== ["Unknown", "Online", "Offline"].indexOf(t.onlineState) && "string" == typeof t.clientId ? new fu(t.clientId, t.onlineState) : (Br("SharedClientState", `Failed to parse online state: ${e}`), null) } } class pu { constructor() { this.activeTargetIds = qo() } Xi(e) { this.activeTargetIds = this.activeTargetIds.add(e) } Zi(e) { this.activeTargetIds = this.activeTargetIds.delete(e) } Yi() { const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(e) } } class mu { constructor(e, t, n, r, s) { this.window = e, this.Hn = t, this.persistenceKey = n, this.tr = r, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.er = this.nr.bind(this), this.sr = new Ao(is), this.started = !1, this.ir = []; const i = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); this.storage = this.window.localStorage, this.currentUser = s, this.rr = au(this.persistenceKey, this.tr), this.ar = function (e) { return `firestore_sequence_number_${e}` }(this.persistenceKey), this.sr = this.sr.insert(this.tr, new pu), this.ur = new RegExp(`^firestore_clients_${i}_([^_]*)$`), this.cr = new RegExp(`^firestore_mutations_${i}_(\\d+)(?:_(.*))?$`), this.hr = new RegExp(`^firestore_targets_${i}_(\\d+)$`), this.lr = function (e) { return `firestore_online_state_${e}` }(this.persistenceKey), this.dr = function (e) { return `firestore_bundle_loaded_${e}` }(this.persistenceKey), this.window.addEventListener("storage", this.er) } static vt(e) { return !(!e || !e.localStorage) } async start() { const e = await this.syncEngine.Ms(); for (const n of e) { if (n === this.tr) continue; const e = this.getItem(au(this.persistenceKey, n)); if (e) { const t = du.Ji(n, e); t && (this.sr = this.sr.insert(t.clientId, t)) } } this._r(); const t = this.storage.getItem(this.lr); if (t) { const e = this.wr(t); e && this.mr(e) } for (const n of this.ir) this.nr(n); this.ir = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = !0 } writeSequenceNumber(e) { this.setItem(this.ar, JSON.stringify(e)) } getAllActiveQueryTargets() { return this.gr(this.sr) } isActiveQueryTarget(e) { let t = !1; return this.sr.forEach((n, r) => { r.activeTargetIds.has(e) && (t = !0) }), t } addPendingMutation(e) { this.yr(e, "pending") } updateMutationState(e, t, n) { this.yr(e, t, n), this.pr(e) } addLocalQueryTarget(e) { let t = "not-current"; if (this.isActiveQueryTarget(e)) { const n = this.storage.getItem(lu(this.persistenceKey, e)); if (n) { const r = hu.Ji(e, n); r && (t = r.state) } } return this.Ir.Xi(e), this._r(), t } removeLocalQueryTarget(e) { this.Ir.Zi(e), this._r() } isLocalQueryTarget(e) { return this.Ir.activeTargetIds.has(e) } clearQueryState(e) { this.removeItem(lu(this.persistenceKey, e)) } updateQueryState(e, t, n) { this.Tr(e, t, n) } handleUserChange(e, t, n) { t.forEach(e => { this.pr(e) }), this.currentUser = e, n.forEach(e => { this.addPendingMutation(e) }) } setOnlineState(e) { this.Er(e) } notifyBundleLoaded() { this.Ar() } shutdown() { this.started && (this.window.removeEventListener("storage", this.er), this.removeItem(this.rr), this.started = !1) } getItem(e) { const t = this.storage.getItem(e); return $r("SharedClientState", "READ", e, t), t } setItem(e, t) { $r("SharedClientState", "SET", e, t), this.storage.setItem(e, t) } removeItem(e) { $r("SharedClientState", "REMOVE", e), this.storage.removeItem(e) } nr(e) { const t = e; if (t.storageArea === this.storage) { if ($r("SharedClientState", "EVENT", t.key, t.newValue), t.key === this.rr) return void Br("Received WebStorage notification for local change. Another client might have garbage-collected our state"); this.Hn.enqueueRetryable(async () => { if (this.started) { if (null !== t.key) if (this.ur.test(t.key)) { if (null == t.newValue) { const e = this.Rr(t.key); return this.br(e, null) } { const e = this.Pr(t.key, t.newValue); if (e) return this.br(e.clientId, e) } } else if (this.cr.test(t.key)) { if (null !== t.newValue) { const e = this.Vr(t.key, t.newValue); if (e) return this.vr(e) } } else if (this.hr.test(t.key)) { if (null !== t.newValue) { const e = this.Sr(t.key, t.newValue); if (e) return this.Dr(e) } } else if (t.key === this.lr) { if (null !== t.newValue) { const e = this.wr(t.newValue); if (e) return this.mr(e) } } else if (t.key === this.ar) { const e = function (e) { let t = ns.A; if (null != e) try { const n = JSON.parse(e); qr("number" == typeof n), t = n } catch (e) { Br("SharedClientState", "Failed to read sequence number from WebStorage", e) } return t }(t.newValue); e !== ns.A && this.sequenceNumberHandler(e) } else if (t.key === this.dr) return this.syncEngine.Cr() } else this.ir.push(t) }) } } get Ir() { return this.sr.get(this.tr) } _r() { this.setItem(this.rr, this.Ir.Yi()) } yr(e, t, n) { const r = new uu(this.currentUser, e, t, n), s = cu(this.persistenceKey, this.currentUser, e); this.setItem(s, r.Yi()) } pr(e) { const t = cu(this.persistenceKey, this.currentUser, e); this.removeItem(t) } Er(e) { this.storage.setItem(this.lr, JSON.stringify({ clientId: this.tr, onlineState: e })) } Tr(e, t, n) { const r = lu(this.persistenceKey, e), s = new hu(e, t, n); this.setItem(r, s.Yi()) } Ar() { this.setItem(this.dr, "value-not-used") } Rr(e) { const t = this.ur.exec(e); return t ? t[1] : null } Pr(e, t) { const n = this.Rr(e); return du.Ji(n, t) } Vr(e, t) { const n = this.cr.exec(e), r = Number(n[1]); return uu.Ji(new Pr(void 0 !== n[2] ? n[2] : null), r, t) } Sr(e, t) { const n = this.hr.exec(e), r = Number(n[1]); return hu.Ji(r, t) } wr(e) { return fu.Ji(e) } async vr(e) { if (e.user.uid === this.currentUser.uid) return this.syncEngine.Nr(e.batchId, e.state, e.error); $r("SharedClientState", `Ignoring mutation for non-active user ${e.user.uid}`) } Dr(e) { return this.syncEngine.kr(e.targetId, e.state, e.error) } br(e, t) { const n = t ? this.sr.insert(e, t) : this.sr.remove(e), r = this.gr(this.sr), s = this.gr(n), i = [], o = []; return s.forEach(e => { r.has(e) || i.push(e) }), r.forEach(e => { s.has(e) || o.push(e) }), this.syncEngine.Mr(i, o).then(() => { this.sr = n }) } mr(e) { this.sr.get(e.clientId) && this.onlineStateHandler(e.onlineState) } gr(e) { let t = qo(); return e.forEach((e, n) => { t = t.unionWith(n.activeTargetIds) }), t } } class gu { constructor() { this.Or = new pu, this.$r = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(e) { } updateMutationState(e, t, n) { } addLocalQueryTarget(e) { return this.Or.Xi(e), this.$r[e] || "not-current" } updateQueryState(e, t, n) { this.$r[e] = t } removeLocalQueryTarget(e) { this.Or.Zi(e) } isLocalQueryTarget(e) { return this.Or.activeTargetIds.has(e) } clearQueryState(e) { delete this.$r[e] } getAllActiveQueryTargets() { return this.Or.activeTargetIds } isActiveQueryTarget(e) { return this.Or.activeTargetIds.has(e) } start() { return this.Or = new pu, Promise.resolve() } handleUserChange(e, t, n) { } setOnlineState(e) { } shutdown() { } writeSequenceNumber(e) { } notifyBundleLoaded() { } } class yu { Fr(e) { } shutdown() { } } class vu { constructor() { this.Br = () => this.Lr(), this.qr = () => this.Ur(), this.Kr = [], this.Gr() } Fr(e) { this.Kr.push(e) } shutdown() { window.removeEventListener("online", this.Br), window.removeEventListener("offline", this.qr) } Gr() { window.addEventListener("online", this.Br), window.addEventListener("offline", this.qr) } Lr() { $r("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"); for (const e of this.Kr) e(0) } Ur() { $r("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"); for (const e of this.Kr) e(1) } static vt() { return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener } } const wu = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery" }; class bu { constructor(e) { this.Qr = e.Qr, this.jr = e.jr } Wr(e) { this.zr = e } Hr(e) { this.Jr = e } onMessage(e) { this.Yr = e } close() { this.jr() } send(e) { this.Qr(e) } Xr() { this.zr() } Zr(e) { this.Jr(e) } eo(e) { this.Yr(e) } } class _u extends class { constructor(e) { this.databaseInfo = e, this.databaseId = e.databaseId, this.no = (e.ssl ? "https" : "http") + "://" + e.host, this.so = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents" } io(e, t, n, r, s) { const i = this.ro(e, t); $r("RestConnection", "Sending: ", i, n); const o = {}; return this.oo(o, r, s), this.ao(e, i, o, n).then(e => ($r("RestConnection", "Received: ", e), e), t => { throw Vr("RestConnection", `${e} failed with error: `, t, "url: ", i, "request:", n), t }) } uo(e, t, n, r, s) { return this.io(e, t, n, r, s) } oo(e, t, n) { e["X-Goog-Api-Client"] = "gl-js/ fire/" + Fr, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((t, n) => e[n] = t), n && n.headers.forEach((t, n) => e[n] = t) } ro(e, t) { return `${this.no}/v1/${t}:${wu[e]}` } }{ constructor(e) { super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams } ao(e, t, n, r) { return new Promise((s, i) => { const o = new Rr; o.listenOnce(kr.COMPLETE, () => { try { switch (o.getLastErrorCode()) { case Ir.NO_ERROR: const t = o.getResponseJson(); $r("Connection", "XHR received:", JSON.stringify(t)), s(t); break; case Ir.TIMEOUT: $r("Connection", 'RPC "' + e + '" timed out'), i(new Gr(Hr.DEADLINE_EXCEEDED, "Request time out")); break; case Ir.HTTP_ERROR: const n = o.getStatus(); if ($r("Connection", 'RPC "' + e + '" failed with status:', n, "response text:", o.getResponseText()), n > 0) { const e = o.getResponseJson().error; if (e && e.status && e.message) { const t = function (e) { const t = e.toLowerCase().replace(/_/g, "-"); return Object.values(Hr).indexOf(t) >= 0 ? t : Hr.UNKNOWN }(e.status); i(new Gr(t, e.message)) } else i(new Gr(Hr.UNKNOWN, "Server responded with status " + o.getStatus())) } else i(new Gr(Hr.UNAVAILABLE, "Connection failed.")); break; default: jr() } } finally { $r("Connection", 'RPC "' + e + '" completed.') } }); const a = JSON.stringify(r); o.send(t, "POST", a, n, 15) }) } co(e, t, n) { const r = [this.no, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], s = Sr(), i = Tr(), o = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }; this.useFetchStreams && (o.xmlHttpFactory = new Dr({})), this.oo(o.initMessageHeaders, t, n), (0, T.uI)() || (0, T.b$)() || (0, T.d)() || (0, T.w1)() || (0, T.Mn)() || (0, T.ru)() || (o.httpHeadersOverwriteParam = "$httpHeaders"); const a = r.join(""); $r("Connection", "Creating WebChannel: " + a, o); const c = s.createWebChannel(a, o); let l = !1, u = !1; const h = new bu({ Qr: e => { u ? $r("Connection", "Not sending because WebChannel is closed:", e) : (l || ($r("Connection", "Opening WebChannel transport."), c.open(), l = !0), $r("Connection", "WebChannel sending:", e), c.send(e)) }, jr: () => c.close() }), d = (e, t, n) => { e.listen(t, e => { try { n(e) } catch (e) { setTimeout(() => { throw e }, 0) } }) }; return d(c, Or.EventType.OPEN, () => { u || $r("Connection", "WebChannel transport opened.") }), d(c, Or.EventType.CLOSE, () => { u || (u = !0, $r("Connection", "WebChannel transport closed"), h.Zr()) }), d(c, Or.EventType.ERROR, e => { u || (u = !0, Vr("Connection", "WebChannel transport errored:", e), h.Zr(new Gr(Hr.UNAVAILABLE, "The operation could not be completed"))) }), d(c, Or.EventType.MESSAGE, e => { var t; if (!u) { const n = e.data[0]; qr(!!n); const r = n, s = r.error || (null === (t = r[0]) || void 0 === t ? void 0 : t.error); if (s) { $r("Connection", "WebChannel received error:", s); const e = s.status; let t = function (e) { const t = Co[e]; if (void 0 !== t) return Io(t) }(e), n = s.message; void 0 === t && (t = Hr.INTERNAL, n = "Unknown error status: " + e + " with message " + s.message), u = !0, h.Zr(new Gr(t, n)), c.close() } else $r("Connection", "WebChannel received:", n), h.eo(n) } }), d(i, Ar.STAT_EVENT, e => { e.stat === xr.PROXY ? $r("Connection", "Detected buffering proxy") : e.stat === xr.NOPROXY && $r("Connection", "Detected no buffering proxy") }), setTimeout(() => { h.Xr() }, 0), h } } function Eu() { return "undefined" != typeof window ? window : null } function Cu() { return "undefined" != typeof document ? document : null } function Su(e) { return new ta(e, !0) } class Tu { constructor(e, t, n = 1e3, r = 1.5, s = 6e4) { this.Hn = e, this.timerId = t, this.ho = n, this.lo = r, this.fo = s, this._o = 0, this.wo = null, this.mo = Date.now(), this.reset() } reset() { this._o = 0 } yo() { this._o = this.fo } po(e) { this.cancel(); const t = Math.floor(this._o + this.Io()), n = Math.max(0, Date.now() - this.mo), r = Math.max(0, t - n); r > 0 && $r("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this._o} ms, delay with jitter: ${t} ms, last attempt: ${n} ms ago)`), this.wo = this.Hn.enqueueAfterDelay(this.timerId, r, () => (this.mo = Date.now(), e())), this._o *= this.lo, this._o < this.ho && (this._o = this.ho), this._o > this.fo && (this._o = this.fo) } To() { null !== this.wo && (this.wo.skipDelay(), this.wo = null) } cancel() { null !== this.wo && (this.wo.cancel(), this.wo = null) } Io() { return (Math.random() - .5) * this._o } } class Iu { constructor(e, t, n, r, s, i, o, a) { this.Hn = e, this.Eo = n, this.Ao = r, this.Ro = s, this.authCredentialsProvider = i, this.appCheckCredentialsProvider = o, this.listener = a, this.state = 0, this.bo = 0, this.Po = null, this.Vo = null, this.stream = null, this.vo = new Tu(e, t) } So() { return 1 === this.state || 5 === this.state || this.Do() } Do() { return 2 === this.state || 3 === this.state } start() { 4 !== this.state ? this.auth() : this.Co() } async stop() { this.So() && await this.close(0) } xo() { this.state = 0, this.vo.reset() } No() { this.Do() && null === this.Po && (this.Po = this.Hn.enqueueAfterDelay(this.Eo, 6e4, () => this.ko())) } Mo(e) { this.Oo(), this.stream.send(e) } async ko() { if (this.Do()) return this.close(0) } Oo() { this.Po && (this.Po.cancel(), this.Po = null) } $o() { this.Vo && (this.Vo.cancel(), this.Vo = null) } async close(e, t) { this.Oo(), this.$o(), this.vo.cancel(), this.bo++, 4 !== e ? this.vo.reset() : t && t.code === Hr.RESOURCE_EXHAUSTED ? (Br(t.toString()), Br("Using maximum backoff delay to prevent overloading the backend."), this.vo.yo()) : t && t.code === Hr.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.Fo(), this.stream.close(), this.stream = null), this.state = e, await this.listener.Hr(t) } Fo() { } auth() { this.state = 1; const e = this.Bo(this.bo), t = this.bo; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([e, n]) => { this.bo === t && this.Lo(e, n) }, t => { e(() => { const e = new Gr(Hr.UNKNOWN, "Fetching auth token failed: " + t.message); return this.qo(e) }) }) } Lo(e, t) { const n = this.Bo(this.bo); this.stream = this.Uo(e, t), this.stream.Wr(() => { n(() => (this.state = 2, this.Vo = this.Hn.enqueueAfterDelay(this.Ao, 1e4, () => (this.Do() && (this.state = 3), Promise.resolve())), this.listener.Wr())) }), this.stream.Hr(e => { n(() => this.qo(e)) }), this.stream.onMessage(e => { n(() => this.onMessage(e)) }) } Co() { this.state = 5, this.vo.po(async () => { this.state = 0, this.start() }) } qo(e) { return $r("PersistentStream", `close with error: ${e}`), this.stream = null, this.close(4, e) } Bo(e) { return t => { this.Hn.enqueueAndForget(() => this.bo === e ? t() : ($r("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve())) } } } class ku extends Iu { constructor(e, t, n, r, s, i) { super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, n, r, i), this.M = s } Uo(e, t) { return this.Ro.co("Listen", e, t) } onMessage(e) { this.vo.reset(); const t = function (e, t) { let n; if ("targetChange" in t) { const r = function (e) { return "NO_CHANGE" === e ? 0 : "ADD" === e ? 1 : "REMOVE" === e ? 2 : "CURRENT" === e ? 3 : "RESET" === e ? 4 : jr() }(t.targetChange.targetChangeType || "NO_CHANGE"), s = t.targetChange.targetIds || [], i = function (e, t) { return e.N ? (qr(void 0 === t || "string" == typeof t), vs.fromBase64String(t || "")) : (qr(void 0 === t || t instanceof Uint8Array), vs.fromUint8Array(t || new Uint8Array)) }(e, t.targetChange.resumeToken), o = t.targetChange.cause, a = o && function (e) { const t = void 0 === e.code ? Hr.UNKNOWN : Io(e.code); return new Gr(t, e.message || "") }(o); n = new Yo(r, s, i, a || null) } else if ("documentChange" in t) { const r = t.documentChange, s = la(e, r.document.name), i = ia(r.document.updateTime), o = new Zs({ mapValue: { fields: r.document.fields } }), a = Js.newFoundDocument(s, i, o); n = new Go(r.targetIds || [], r.removedTargetIds || [], a.key, a) } else if ("documentDelete" in t) { const r = t.documentDelete, s = la(e, r.document), i = r.readTime ? ia(r.readTime) : ls.min(), o = Js.newNoDocument(s, i); n = new Go([], r.removedTargetIds || [], o.key, o) } else if ("documentRemove" in t) { const r = t.documentRemove, s = la(e, r.document); n = new Go([], r.removedTargetIds || [], s, null) } else { if (!("filter" in t)) return jr(); { const e = t.filter, r = new Eo(e.count || 0); n = new Wo(e.targetId, r) } } return n }(this.M, e), n = function (e) { if (!("targetChange" in e)) return ls.min(); const t = e.targetChange; return t.targetIds && t.targetIds.length ? ls.min() : t.readTime ? ia(t.readTime) : ls.min() }(e); return this.listener.Ko(t, n) } Go(e) { const t = {}; t.database = da(this.M), t.addTarget = function (e, t) { let n; const r = t.target; return n = ui(r) ? { documents: va(e, r) } : { query: wa(e, r) }, n.targetId = t.targetId, t.resumeToken.approximateByteSize() > 0 ? n.resumeToken = ra(e, t.resumeToken) : t.snapshotVersion.compareTo(ls.min()) > 0 && (n.readTime = na(e, t.snapshotVersion.toTimestamp())), n }(this.M, e); const n = function (e, t) { const n = function (e, t) { switch (t) { case 0: return null; case 1: return "existence-filter-mismatch"; case 2: return "limbo-document"; default: return jr() } }(0, t.purpose); return null == n ? null : { "goog-listen-tags": n } }(0, e); n && (t.labels = n), this.Mo(t) } Qo(e) { const t = {}; t.database = da(this.M), t.removeTarget = e, this.Mo(t) } } class Au extends Iu { constructor(e, t, n, r, s, i) { super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, n, r, i), this.M = s, this.jo = !1 } get Wo() { return this.jo } start() { this.jo = !1, this.lastStreamToken = void 0, super.start() } Fo() { this.jo && this.zo([]) } Uo(e, t) { return this.Ro.co("Write", e, t) } onMessage(e) { if (qr(!!e.streamToken), this.lastStreamToken = e.streamToken, this.jo) { this.vo.reset(); const t = function (e, t) { return e && e.length > 0 ? (qr(void 0 !== t), e.map(e => function (e, t) { let n = ia(e.updateTime ? e.updateTime : t); return n.isEqual(ls.min()) && (n = ia(t)), new io(n, e.transformResults || []) }(e, t))) : [] }(e.writeResults, e.commitTime), n = ia(e.commitTime); return this.listener.Ho(n, t) } return qr(!e.writeResults || 0 === e.writeResults.length), this.jo = !0, this.listener.Jo() } Yo() { const e = {}; e.database = da(this.M), this.Mo(e) } zo(e) { const t = { streamToken: this.lastStreamToken, writes: e.map(e => ga(this.M, e)) }; this.Mo(t) } } class xu extends class { }{ constructor(e, t, n, r) { super(), this.authCredentials = e, this.appCheckCredentials = t, this.Ro = n, this.M = r, this.Xo = !1 } Zo() { if (this.Xo) throw new Gr(Hr.FAILED_PRECONDITION, "The client has already been terminated.") } io(e, t, n) { return this.Zo(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([r, s]) => this.Ro.io(e, t, n, r, s)).catch(e => { throw "FirebaseError" === e.name ? (e.code === Hr.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e) : new Gr(Hr.UNKNOWN, e.toString()) }) } uo(e, t, n) { return this.Zo(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([r, s]) => this.Ro.uo(e, t, n, r, s)).catch(e => { throw "FirebaseError" === e.name ? (e.code === Hr.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), e) : new Gr(Hr.UNKNOWN, e.toString()) }) } terminate() { this.Xo = !0 } } class Du { constructor(e, t) { this.asyncQueue = e, this.onlineStateHandler = t, this.state = "Unknown", this.ta = 0, this.ea = null, this.na = !0 } sa() { 0 === this.ta && (this.ia("Unknown"), this.ea = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.ea = null, this.ra("Backend didn't respond within 10 seconds."), this.ia("Offline"), Promise.resolve()))) } oa(e) { "Online" === this.state ? this.ia("Unknown") : (this.ta++, this.ta >= 1 && (this.aa(), this.ra(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.ia("Offline"))) } set(e) { this.aa(), this.ta = 0, "Online" === e && (this.na = !1), this.ia(e) } ia(e) { e !== this.state && (this.state = e, this.onlineStateHandler(e)) } ra(e) { const t = `Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`; this.na ? (Br(t), this.na = !1) : $r("OnlineStateTracker", t) } aa() { null !== this.ea && (this.ea.cancel(), this.ea = null) } } class Ou { constructor(e, t, n, r, s) { this.localStore = e, this.datastore = t, this.asyncQueue = n, this.remoteSyncer = {}, this.ua = [], this.ca = new Map, this.ha = new Set, this.la = [], this.fa = s, this.fa.Fr(e => { n.enqueueAndForget(async () => { Vu(this) && ($r("RemoteStore", "Restarting streams for network reachability change."), await async function (e) { const t = zr(e); t.ha.add(4), await Nu(t), t.da.set("Unknown"), t.ha.delete(4), await Ru(t) }(this)) }) }), this.da = new Du(n, r) } } async function Ru(e) { if (Vu(e)) for (const t of e.la) await t(!0) } async function Nu(e) { for (const t of e.la) await t(!1) } function Pu(e, t) { const n = zr(e); n.ca.has(t.targetId) || (n.ca.set(t.targetId, t), Bu(n) ? $u(n) : sh(n).Do() && Lu(n, t)) } function Fu(e, t) { const n = zr(e), r = sh(n); n.ca.delete(t), r.Do() && Mu(n, t), 0 === n.ca.size && (r.Do() ? r.No() : Vu(n) && n.da.set("Unknown")) } function Lu(e, t) { e._a.Z(t.targetId), sh(e).Go(t) } function Mu(e, t) { e._a.Z(t), sh(e).Qo(t) } function $u(e) { e._a = new Xo({ getRemoteKeysForTarget: t => e.remoteSyncer.getRemoteKeysForTarget(t), Et: t => e.ca.get(t) || null }), sh(e).start(), e.da.sa() } function Bu(e) { return Vu(e) && !sh(e).So() && e.ca.size > 0 } function Vu(e) { return 0 === zr(e).ha.size } function Uu(e) { e._a = void 0 } async function ju(e) { e.ca.forEach((t, n) => { Lu(e, t) }) } async function qu(e, t) { Uu(e), Bu(e) ? (e.da.oa(t), $u(e)) : e.da.set("Unknown") } async function zu(e, t, n) { if (e.da.set("Online"), t instanceof Yo && 2 === t.state && t.cause) try { await async function (e, t) { const n = t.cause; for (const r of t.targetIds) e.ca.has(r) && (await e.remoteSyncer.rejectListen(r, n), e.ca.delete(r), e._a.removeTarget(r)) }(e, t) } catch (n) { $r("RemoteStore", "Failed to remove targets %s: %s ", t.targetIds.join(","), n), await Hu(e, n) } else if (t instanceof Go ? e._a.at(t) : t instanceof Wo ? e._a._t(t) : e._a.ht(t), !n.isEqual(ls.min())) try { const t = await Ul(e.localStore); n.compareTo(t) >= 0 && await function (e, t) { const n = e._a.yt(t); return n.targetChanges.forEach((n, r) => { if (n.resumeToken.approximateByteSize() > 0) { const s = e.ca.get(r); s && e.ca.set(r, s.withResumeToken(n.resumeToken, t)) } }), n.targetMismatches.forEach(t => { const n = e.ca.get(t); if (!n) return; e.ca.set(t, n.withResumeToken(vs.EMPTY_BYTE_STRING, n.snapshotVersion)), Mu(e, t); const r = new gc(n.target, t, 1, n.sequenceNumber); Lu(e, r) }), e.remoteSyncer.applyRemoteEvent(n) }(e, n) } catch (t) { $r("RemoteStore", "Failed to raise snapshot:", t), await Hu(e, t) } } async function Hu(e, t, n) { if (!oc(t)) throw t; e.ha.add(1), await Nu(e), e.da.set("Offline"), n || (n = () => Ul(e.localStore)), e.asyncQueue.enqueueRetryable(async () => { $r("RemoteStore", "Retrying IndexedDB access"), await n(), e.ha.delete(1), await Ru(e) }) } function Gu(e, t) { return t().catch(n => Hu(e, n, t)) } async function Wu(e) { const t = zr(e), n = ih(t); let r = t.ua.length > 0 ? t.ua[t.ua.length - 1].batchId : -1; for (; Yu(t);)try { const e = await ql(t.localStore, r); if (null === e) { 0 === t.ua.length && n.No(); break } r = e.batchId, Ku(t, e) } catch (e) { await Hu(t, e) } Xu(t) && Zu(t) } function Yu(e) { return Vu(e) && e.ua.length < 10 } function Ku(e, t) { e.ua.push(t); const n = ih(e); n.Do() && n.Wo && n.zo(t.mutations) } function Xu(e) { return Vu(e) && !ih(e).So() && e.ua.length > 0 } function Zu(e) { ih(e).start() } async function Qu(e) { ih(e).Yo() } async function Ju(e) { const t = ih(e); for (const n of e.ua) t.zo(n.mutations) } async function eh(e, t, n) { const r = e.ua.shift(), s = pc.from(r, t, n); await Gu(e, () => e.remoteSyncer.applySuccessfulWrite(s)), await Wu(e) } async function th(e, t) { t && ih(e).Wo && await async function (e, t) { if (To(n = t.code) && n !== Hr.ABORTED) { const n = e.ua.shift(); ih(e).xo(), await Gu(e, () => e.remoteSyncer.rejectFailedWrite(n.batchId, t)), await Wu(e) } var n }(e, t), Xu(e) && Zu(e) } async function nh(e, t) { const n = zr(e); n.asyncQueue.verifyOperationInProgress(), $r("RemoteStore", "RemoteStore received new credentials"); const r = Vu(n); n.ha.add(3), await Nu(n), r && n.da.set("Unknown"), await n.remoteSyncer.handleCredentialChange(t), n.ha.delete(3), await Ru(n) } async function rh(e, t) { const n = zr(e); t ? (n.ha.delete(2), await Ru(n)) : t || (n.ha.add(2), await Nu(n), n.da.set("Unknown")) } function sh(e) { return e.wa || (e.wa = function (e, t, n) { const r = zr(e); return r.Zo(), new ku(t, r.Ro, r.authCredentials, r.appCheckCredentials, r.M, n) }(e.datastore, e.asyncQueue, { Wr: ju.bind(null, e), Hr: qu.bind(null, e), Ko: zu.bind(null, e) }), e.la.push(async t => { t ? (e.wa.xo(), Bu(e) ? $u(e) : e.da.set("Unknown")) : (await e.wa.stop(), Uu(e)) })), e.wa } function ih(e) { return e.ma || (e.ma = function (e, t, n) { const r = zr(e); return r.Zo(), new Au(t, r.Ro, r.authCredentials, r.appCheckCredentials, r.M, n) }(e.datastore, e.asyncQueue, { Wr: Qu.bind(null, e), Hr: th.bind(null, e), Jo: Ju.bind(null, e), Ho: eh.bind(null, e) }), e.la.push(async t => { t ? (e.ma.xo(), await Wu(e)) : (await e.ma.stop(), e.ua.length > 0 && ($r("RemoteStore", `Stopping write stream with ${e.ua.length} pending writes`), e.ua = [])) })), e.ma } class oh { constructor(e, t, n, r, s) { this.asyncQueue = e, this.timerId = t, this.targetTimeMs = n, this.op = r, this.removalCallback = s, this.deferred = new Wr, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(e => { }) } static createAndSchedule(e, t, n, r, s) { const i = Date.now() + n, o = new oh(e, t, i, r, s); return o.start(n), o } start(e) { this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e) } skipDelay() { return this.handleDelayElapsed() } cancel(e) { null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new Gr(Hr.CANCELLED, "Operation cancelled" + (e ? ": " + e : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve()) } clearTimeout() { null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function ah(e, t) { if (Br("AsyncQueue", `${t}: ${e}`), oc(e)) return new Gr(Hr.UNAVAILABLE, `${t}: ${e}`); throw e } class ch { constructor(e) { this.comparator = e ? (t, n) => e(t, n) || Os.comparator(t.key, n.key) : (e, t) => Os.comparator(e.key, t.key), this.keyedMap = Mo(), this.sortedSet = new Ao(this.comparator) } static emptySet(e) { return new ch(e.comparator) } has(e) { return null != this.keyedMap.get(e) } get(e) { return this.keyedMap.get(e) } first() { return this.sortedSet.minKey() } last() { return this.sortedSet.maxKey() } isEmpty() { return this.sortedSet.isEmpty() } indexOf(e) { const t = this.keyedMap.get(e); return t ? this.sortedSet.indexOf(t) : -1 } get size() { return this.sortedSet.size } forEach(e) { this.sortedSet.inorderTraversal((t, n) => (e(t), !1)) } add(e) { const t = this.delete(e.key); return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null)) } delete(e) { const t = this.get(e); return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this } isEqual(e) { if (!(e instanceof ch)) return !1; if (this.size !== e.size) return !1; const t = this.sortedSet.getIterator(), n = e.sortedSet.getIterator(); for (; t.hasNext();) { const e = t.getNext().key, r = n.getNext().key; if (!e.isEqual(r)) return !1 } return !0 } toString() { const e = []; return this.forEach(t => { e.push(t.toString()) }), 0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)" } copy(e, t) { const n = new ch; return n.comparator = this.comparator, n.keyedMap = e, n.sortedSet = t, n } } class lh { constructor() { this.ga = new Ao(Os.comparator) } track(e) { const t = e.doc.key, n = this.ga.get(t); n ? 0 !== e.type && 3 === n.type ? this.ga = this.ga.insert(t, e) : 3 === e.type && 1 !== n.type ? this.ga = this.ga.insert(t, { type: n.type, doc: e.doc }) : 2 === e.type && 2 === n.type ? this.ga = this.ga.insert(t, { type: 2, doc: e.doc }) : 2 === e.type && 0 === n.type ? this.ga = this.ga.insert(t, { type: 0, doc: e.doc }) : 1 === e.type && 0 === n.type ? this.ga = this.ga.remove(t) : 1 === e.type && 2 === n.type ? this.ga = this.ga.insert(t, { type: 1, doc: n.doc }) : 0 === e.type && 1 === n.type ? this.ga = this.ga.insert(t, { type: 2, doc: e.doc }) : jr() : this.ga = this.ga.insert(t, e) } ya() { const e = []; return this.ga.inorderTraversal((t, n) => { e.push(n) }), e } } class uh { constructor(e, t, n, r, s, i, o, a) { this.query = e, this.docs = t, this.oldDocs = n, this.docChanges = r, this.mutatedKeys = s, this.fromCache = i, this.syncStateChanged = o, this.excludesMetadataChanges = a } static fromInitialDocuments(e, t, n, r) { const s = []; return t.forEach(e => { s.push({ type: 0, doc: e }) }), new uh(e, t, ch.emptySet(t), s, n, r, !0, !1) } get hasPendingWrites() { return !this.mutatedKeys.isEmpty() } isEqual(e) { if (!(this.fromCache === e.fromCache && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && Mi(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1; const t = this.docChanges, n = e.docChanges; if (t.length !== n.length) return !1; for (let r = 0; r < t.length; r++)if (t[r].type !== n[r].type || !t[r].doc.isEqual(n[r].doc)) return !1; return !0 } } class hh { constructor() { this.pa = void 0, this.listeners = [] } } class dh { constructor() { this.queries = new ko(e => $i(e), Mi), this.onlineState = "Unknown", this.Ia = new Set } } async function fh(e, t) { const n = zr(e), r = t.query; let s = !1, i = n.queries.get(r); if (i || (s = !0, i = new hh), s) try { i.pa = await n.onListen(r) } catch (e) { const n = ah(e, `Initialization of query '${Bi(t.query)}' failed`); return void t.onError(n) } n.queries.set(r, i), i.listeners.push(t), t.Ta(n.onlineState), i.pa && t.Ea(i.pa) && yh(n) } async function ph(e, t) { const n = zr(e), r = t.query; let s = !1; const i = n.queries.get(r); if (i) { const e = i.listeners.indexOf(t); e >= 0 && (i.listeners.splice(e, 1), s = 0 === i.listeners.length) } if (s) return n.queries.delete(r), n.onUnlisten(r) } function mh(e, t) { const n = zr(e); let r = !1; for (const s of t) { const e = n.queries.get(s.query); if (e) { for (const t of e.listeners) t.Ea(s) && (r = !0); e.pa = s } } r && yh(n) } function gh(e, t, n) { const r = zr(e), s = r.queries.get(t); if (s) for (const i of s.listeners) i.onError(n); r.queries.delete(t) } function yh(e) { e.Ia.forEach(e => { e.next() }) } class vh { constructor(e, t, n) { this.query = e, this.Aa = t, this.Ra = !1, this.ba = null, this.onlineState = "Unknown", this.options = n || {} } Ea(e) { if (!this.options.includeMetadataChanges) { const t = []; for (const n of e.docChanges) 3 !== n.type && t.push(n); e = new uh(e.query, e.docs, e.oldDocs, t, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0) } let t = !1; return this.Ra ? this.Pa(e) && (this.Aa.next(e), t = !0) : this.Va(e, this.onlineState) && (this.va(e), t = !0), this.ba = e, t } onError(e) { this.Aa.error(e) } Ta(e) { this.onlineState = e; let t = !1; return this.ba && !this.Ra && this.Va(this.ba, e) && (this.va(this.ba), t = !0), t } Va(e, t) { return !e.fromCache || !(this.options.Sa && "Offline" !== t || e.docs.isEmpty() && "Offline" !== t) } Pa(e) { return e.docChanges.length > 0 || !!(e.syncStateChanged || this.ba && this.ba.hasPendingWrites !== e.hasPendingWrites) && !0 === this.options.includeMetadataChanges } va(e) { e = uh.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache), this.Ra = !0, this.Aa.next(e) } } class wh { constructor(e, t) { this.payload = e, this.byteLength = t } Da() { return "metadata" in this.payload } } class bh { constructor(e) { this.M = e } li(e) { return la(this.M, e) } fi(e) { return e.metadata.exists ? ma(this.M, e.document, !1) : Js.newNoDocument(this.li(e.metadata.name), this.di(e.metadata.readTime)) } di(e) { return ia(e) } } class _h { constructor(e, t, n) { this.Ca = e, this.localStore = t, this.M = n, this.queries = [], this.documents = [], this.progress = Eh(e) } xa(e) { this.progress.bytesLoaded += e.byteLength; let t = this.progress.documentsLoaded; return e.payload.namedQuery ? this.queries.push(e.payload.namedQuery) : e.payload.documentMetadata ? (this.documents.push({ metadata: e.payload.documentMetadata }), e.payload.documentMetadata.exists || ++t) : e.payload.document && (this.documents[this.documents.length - 1].document = e.payload.document, ++t), t !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = t, Object.assign({}, this.progress)) : null } Na(e) { const t = new Map, n = new bh(this.M); for (const r of e) if (r.metadata.queries) { const e = n.li(r.metadata.name); for (const n of r.metadata.queries) { const r = (t.get(n) || Uo()).add(e); t.set(n, r) } } return t } async complete() { const e = await async function (e, t, n, r) { const s = zr(e); let i = Uo(), o = Fo(); for (const l of n) { const e = t.li(l.metadata.name); l.document && (i = i.add(e)); const n = t.fi(l); n.setReadTime(t.di(l.metadata.readTime)), o = o.insert(e, n) } const a = s.oi.newChangeBuffer({ trackRemovals: !0 }), c = await zl(s, function (e) { return Fi(Ai(ps.fromString(`__bundle__/docs/${e}`))) }(r)); return s.persistence.runTransaction("Apply bundle documents", "readwrite", e => jl(e, a, o).next(t => (a.apply(e), t)).next(t => s.hs.removeMatchingKeysForTargetId(e, c.targetId).next(() => s.hs.addMatchingKeys(e, i, c.targetId)).next(() => s.ui.Ks(e, t)).next(() => t))) }(this.localStore, new bh(this.M), this.documents, this.Ca.id), t = this.Na(this.documents); for (const n of this.queries) await Kl(this.localStore, n, t.get(n.name)); return this.progress.taskState = "Success", new Pl(Object.assign({}, this.progress), e) } } function Eh(e) { return { taskState: "Running", documentsLoaded: 0, bytesLoaded: 0, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes } } class Ch { constructor(e) { this.key = e } } class Sh { constructor(e) { this.key = e } } class Th { constructor(e, t) { this.query = e, this.ka = t, this.Ma = null, this.current = !1, this.Oa = Uo(), this.mutatedKeys = Uo(), this.$a = Ui(e), this.Fa = new ch(this.$a) } get Ba() { return this.ka } La(e, t) { const n = t ? t.qa : new lh, r = t ? t.Fa : this.Fa; let s = t ? t.mutatedKeys : this.mutatedKeys, i = r, o = !1; const a = xi(this.query) && r.size === this.query.limit ? r.last() : null, c = Di(this.query) && r.size === this.query.limit ? r.first() : null; if (e.inorderTraversal((e, t) => { const l = r.get(e), u = Vi(this.query, t) ? t : null, h = !!l && this.mutatedKeys.has(l.key), d = !!u && (u.hasLocalMutations || this.mutatedKeys.has(u.key) && u.hasCommittedMutations); let f = !1; l && u ? l.data.isEqual(u.data) ? h !== d && (n.track({ type: 3, doc: u }), f = !0) : this.Ua(l, u) || (n.track({ type: 2, doc: u }), f = !0, (a && this.$a(u, a) > 0 || c && this.$a(u, c) < 0) && (o = !0)) : !l && u ? (n.track({ type: 0, doc: u }), f = !0) : l && !u && (n.track({ type: 1, doc: l }), f = !0, (a || c) && (o = !0)), f && (u ? (i = i.add(u), s = d ? s.add(e) : s.delete(e)) : (i = i.delete(e), s = s.delete(e))) }), xi(this.query) || Di(this.query)) for (; i.size > this.query.limit;) { const e = xi(this.query) ? i.last() : i.first(); i = i.delete(e.key), s = s.delete(e.key), n.track({ type: 1, doc: e }) } return { Fa: i, qa: n, ei: o, mutatedKeys: s } } Ua(e, t) { return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations } applyChanges(e, t, n) { const r = this.Fa; this.Fa = e.Fa, this.mutatedKeys = e.mutatedKeys; const s = e.qa.ya(); s.sort((e, t) => function (e, t) { const n = e => { switch (e) { case 0: return 1; case 2: case 3: return 2; case 1: return 0; default: return jr() } }; return n(e) - n(t) }(e.type, t.type) || this.$a(e.doc, t.doc)), this.Ka(n); const i = t ? this.Ga() : [], o = 0 === this.Oa.size && this.current ? 1 : 0, a = o !== this.Ma; return this.Ma = o, 0 !== s.length || a ? { snapshot: new uh(this.query, e.Fa, r, s, e.mutatedKeys, 0 === o, a, !1), Qa: i } : { Qa: i } } Ta(e) { return this.current && "Offline" === e ? (this.current = !1, this.applyChanges({ Fa: this.Fa, qa: new lh, mutatedKeys: this.mutatedKeys, ei: !1 }, !1)) : { Qa: [] } } ja(e) { return !this.ka.has(e) && !!this.Fa.has(e) && !this.Fa.get(e).hasLocalMutations } Ka(e) { e && (e.addedDocuments.forEach(e => this.ka = this.ka.add(e)), e.modifiedDocuments.forEach(e => { }), e.removedDocuments.forEach(e => this.ka = this.ka.delete(e)), this.current = e.current) } Ga() { if (!this.current) return []; const e = this.Oa; this.Oa = Uo(), this.Fa.forEach(e => { this.ja(e.key) && (this.Oa = this.Oa.add(e.key)) }); const t = []; return e.forEach(e => { this.Oa.has(e) || t.push(new Sh(e)) }), this.Oa.forEach(n => { e.has(n) || t.push(new Ch(n)) }), t } Wa(e) { this.ka = e.hi, this.Oa = Uo(); const t = this.La(e.documents); return this.applyChanges(t, !0) } za() { return uh.fromInitialDocuments(this.query, this.Fa, this.mutatedKeys, 0 === this.Ma) } } class Ih { constructor(e, t, n) { this.query = e, this.targetId = t, this.view = n } } class kh { constructor(e) { this.key = e, this.Ha = !1 } } class Ah { constructor(e, t, n, r, s, i) { this.localStore = e, this.remoteStore = t, this.eventManager = n, this.sharedClientState = r, this.currentUser = s, this.maxConcurrentLimboResolutions = i, this.Ja = {}, this.Ya = new ko(e => $i(e), Mi), this.Xa = new Map, this.Za = new Set, this.tu = new Ao(Os.comparator), this.eu = new Map, this.nu = new Ql, this.su = {}, this.iu = new Map, this.ru = ll.gn(), this.onlineState = "Unknown", this.ou = void 0 } get isPrimaryClient() { return !0 === this.ou } } async function xh(e, t) { const n = td(e); let r, s; const i = n.Ya.get(t); if (i) r = i.targetId, n.sharedClientState.addLocalQueryTarget(r), s = i.view.za(); else { const e = await zl(n.localStore, Fi(t)); n.isPrimaryClient && Pu(n.remoteStore, e); const i = n.sharedClientState.addLocalQueryTarget(e.targetId); r = e.targetId, s = await Dh(n, t, r, "current" === i) } return s } async function Dh(e, t, n, r) { e.au = (t, n, r) => async function (e, t, n, r) { let s = t.view.La(n); s.ei && (s = await Gl(e.localStore, t.query, !1).then(({ documents: e }) => t.view.La(e, s))); const i = r && r.targetChanges.get(t.targetId), o = t.view.applyChanges(s, e.isPrimaryClient, i); return Uh(e, t.targetId, o.Qa), o.snapshot }(e, t, n, r); const s = await Gl(e.localStore, t, !0), i = new Th(t, s.hi), o = i.La(s.documents), a = Ho.createSynthesizedTargetChangeForCurrentChange(n, r && "Offline" !== e.onlineState), c = i.applyChanges(o, e.isPrimaryClient, a); Uh(e, n, c.Qa); const l = new Ih(t, n, i); return e.Ya.set(t, l), e.Xa.has(n) ? e.Xa.get(n).push(t) : e.Xa.set(n, [t]), c.snapshot } async function Oh(e, t) { const n = zr(e), r = n.Ya.get(t), s = n.Xa.get(r.targetId); if (s.length > 1) return n.Xa.set(r.targetId, s.filter(e => !Mi(e, t))), void n.Ya.delete(t); n.isPrimaryClient ? (n.sharedClientState.removeLocalQueryTarget(r.targetId), n.sharedClientState.isActiveQueryTarget(r.targetId) || await Hl(n.localStore, r.targetId, !1).then(() => { n.sharedClientState.clearQueryState(r.targetId), Fu(n.remoteStore, r.targetId), Bh(n, r.targetId) }).catch(pl)) : (Bh(n, r.targetId), await Hl(n.localStore, r.targetId, !0)) } async function Rh(e, t) { const n = zr(e); try { const e = await function (e, t) { const n = zr(e), r = t.snapshotVersion; let s = n.si; return n.persistence.runTransaction("Apply remote event", "readwrite-primary", e => { const i = n.oi.newChangeBuffer({ trackRemovals: !0 }); s = n.si; const o = []; t.targetChanges.forEach((i, a) => { const c = s.get(a); if (!c) return; o.push(n.hs.removeMatchingKeys(e, i.removedDocuments, a).next(() => n.hs.addMatchingKeys(e, i.addedDocuments, a))); let l = c.withSequenceNumber(e.currentSequenceNumber); t.targetMismatches.has(a) ? l = l.withResumeToken(vs.EMPTY_BYTE_STRING, ls.min()).withLastLimboFreeSnapshotVersion(ls.min()) : i.resumeToken.approximateByteSize() > 0 && (l = l.withResumeToken(i.resumeToken, r)), s = s.insert(a, l), function (e, t, n) { return 0 === e.resumeToken.approximateByteSize() || t.snapshotVersion.toMicroseconds() - e.snapshotVersion.toMicroseconds() >= 3e8 || n.addedDocuments.size + n.modifiedDocuments.size + n.removedDocuments.size > 0 }(c, l, i) && o.push(n.hs.updateTargetData(e, l)) }); let a = Fo(); if (t.documentUpdates.forEach(r => { t.resolvedLimboDocuments.has(r) && o.push(n.persistence.referenceDelegate.updateLimboDocument(e, r)) }), o.push(jl(e, i, t.documentUpdates).next(e => { a = e })), !r.isEqual(ls.min())) { const t = n.hs.getLastRemoteSnapshotVersion(e).next(t => n.hs.setTargetsMetadata(e, e.currentSequenceNumber, r)); o.push(t) } return tc.waitFor(o).next(() => i.apply(e)).next(() => n.ui.Ks(e, a)).next(() => a) }).then(e => (n.si = s, e)) }(n.localStore, t); t.targetChanges.forEach((e, t) => { const r = n.eu.get(t); r && (qr(e.addedDocuments.size + e.modifiedDocuments.size + e.removedDocuments.size <= 1), e.addedDocuments.size > 0 ? r.Ha = !0 : e.modifiedDocuments.size > 0 ? qr(r.Ha) : e.removedDocuments.size > 0 && (qr(r.Ha), r.Ha = !1)) }), await zh(n, e, t) } catch (e) { await pl(e) } } function Nh(e, t, n) { const r = zr(e); if (r.isPrimaryClient && 0 === n || !r.isPrimaryClient && 1 === n) { const e = []; r.Ya.forEach((n, r) => { const s = r.view.Ta(t); s.snapshot && e.push(s.snapshot) }), function (e, t) { const n = zr(e); n.onlineState = t; let r = !1; n.queries.forEach((e, n) => { for (const s of n.listeners) s.Ta(t) && (r = !0) }), r && yh(n) }(r.eventManager, t), e.length && r.Ja.Ko(e), r.onlineState = t, r.isPrimaryClient && r.sharedClientState.setOnlineState(t) } } async function Ph(e, t, n) { const r = zr(e); r.sharedClientState.updateQueryState(t, "rejected", n); const s = r.eu.get(t), i = s && s.key; if (i) { let e = new Ao(Os.comparator); e = e.insert(i, Js.newNoDocument(i, ls.min())); const n = Uo().add(i), s = new zo(ls.min(), new Map, new Oo(is), e, n); await Rh(r, s), r.tu = r.tu.remove(i), r.eu.delete(t), qh(r) } else await Hl(r.localStore, t, !1).then(() => Bh(r, t, n)).catch(pl) } async function Fh(e, t) { const n = zr(e), r = t.batch.batchId; try { const e = await function (e, t) { const n = zr(e); return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", e => { const r = t.batch.keys(), s = n.oi.newChangeBuffer({ trackRemovals: !0 }); return function (e, t, n, r) { const s = n.batch, i = s.keys(); let o = tc.resolve(); return i.forEach(e => { o = o.next(() => r.getEntry(t, e)).next(t => { const i = n.docVersions.get(e); qr(null !== i), t.version.compareTo(i) < 0 && (s.applyToRemoteDocument(t, n), t.isValidDocument() && (t.setReadTime(n.commitVersion), r.addEntry(t))) }) }), o.next(() => e.Fs.removeMutationBatch(t, s)) }(n, e, t, s).next(() => s.apply(e)).next(() => n.Fs.performConsistencyCheck(e)).next(() => n.ui.Us(e, r)) }) }(n.localStore, t); $h(n, r, null), Mh(n, r), n.sharedClientState.updateMutationState(r, "acknowledged"), await zh(n, e) } catch (e) { await pl(e) } } async function Lh(e, t, n) { const r = zr(e); try { const e = await function (e, t) { const n = zr(e); return n.persistence.runTransaction("Reject batch", "readwrite-primary", e => { let r; return n.Fs.lookupMutationBatch(e, t).next(t => (qr(null !== t), r = t.keys(), n.Fs.removeMutationBatch(e, t))).next(() => n.Fs.performConsistencyCheck(e)).next(() => n.ui.Us(e, r)) }) }(r.localStore, t); $h(r, t, n), Mh(r, t), r.sharedClientState.updateMutationState(t, "rejected", n), await zh(r, e) } catch (n) { await pl(n) } } function Mh(e, t) { (e.iu.get(t) || []).forEach(e => { e.resolve() }), e.iu.delete(t) } function $h(e, t, n) { const r = zr(e); let s = r.su[r.currentUser.toKey()]; if (s) { const e = s.get(t); e && (n ? e.reject(n) : e.resolve(), s = s.remove(t)), r.su[r.currentUser.toKey()] = s } } function Bh(e, t, n = null) { e.sharedClientState.removeLocalQueryTarget(t); for (const r of e.Xa.get(t)) e.Ya.delete(r), n && e.Ja.uu(r, n); e.Xa.delete(t), e.isPrimaryClient && e.nu.Ri(t).forEach(t => { e.nu.containsKey(t) || Vh(e, t) }) } function Vh(e, t) { e.Za.delete(t.path.canonicalString()); const n = e.tu.get(t); null !== n && (Fu(e.remoteStore, n), e.tu = e.tu.remove(t), e.eu.delete(n), qh(e)) } function Uh(e, t, n) { for (const r of n) r instanceof Ch ? (e.nu.addReference(r.key, t), jh(e, r)) : r instanceof Sh ? ($r("SyncEngine", "Document no longer in limbo: " + r.key), e.nu.removeReference(r.key, t), e.nu.containsKey(r.key) || Vh(e, r.key)) : jr() } function jh(e, t) { const n = t.key, r = n.path.canonicalString(); e.tu.get(n) || e.Za.has(r) || ($r("SyncEngine", "New document in limbo: " + n), e.Za.add(r), qh(e)) } function qh(e) { for (; e.Za.size > 0 && e.tu.size < e.maxConcurrentLimboResolutions;) { const t = e.Za.values().next().value; e.Za.delete(t); const n = new Os(ps.fromString(t)), r = e.ru.next(); e.eu.set(r, new kh(n)), e.tu = e.tu.insert(n, r), Pu(e.remoteStore, new gc(Fi(Ai(n.path)), r, 2, ns.A)) } } async function zh(e, t, n) { const r = zr(e), s = [], i = [], o = []; r.Ya.isEmpty() || (r.Ya.forEach((e, a) => { o.push(r.au(a, t, n).then(e => { if (e) { r.isPrimaryClient && r.sharedClientState.updateQueryState(a.targetId, e.fromCache ? "not-current" : "current"), s.push(e); const t = Ll.Js(a.targetId, e); i.push(t) } })) }), await Promise.all(o), r.Ja.Ko(s), await async function (e, t) { const n = zr(e); try { await n.persistence.runTransaction("notifyLocalViewChanges", "readwrite", e => tc.forEach(t, t => tc.forEach(t.zs, r => n.persistence.referenceDelegate.addReference(e, t.targetId, r)).next(() => tc.forEach(t.Hs, r => n.persistence.referenceDelegate.removeReference(e, t.targetId, r))))) } catch (e) { if (!oc(e)) throw e; $r("LocalStore", "Failed to update sequence numbers: " + e) } for (const r of t) { const e = r.targetId; if (!r.fromCache) { const t = n.si.get(e), r = t.withLastLimboFreeSnapshotVersion(t.snapshotVersion); n.si = n.si.insert(e, r) } } }(r.localStore, i)) } async function Hh(e, t) { const n = zr(e); if (!n.currentUser.isEqual(t)) { $r("SyncEngine", "User change. New user:", t.toKey()); const e = await Vl(n.localStore, t); n.currentUser = t, function (e, t) { e.iu.forEach(e => { e.forEach(e => { e.reject(new Gr(Hr.CANCELLED, "'waitForPendingWrites' promise is rejected due to a user change.")) }) }), e.iu.clear() }(n), n.sharedClientState.handleUserChange(t, e.removedBatchIds, e.addedBatchIds), await zh(n, e.ci) } } function Gh(e, t) { const n = zr(e), r = n.eu.get(t); if (r && r.Ha) return Uo().add(r.key); { let e = Uo(); const r = n.Xa.get(t); if (!r) return e; for (const t of r) { const r = n.Ya.get(t); e = e.unionWith(r.view.Ba) } return e } } async function Wh(e, t) { const n = zr(e), r = await Gl(n.localStore, t.query, !0), s = t.view.Wa(r); return n.isPrimaryClient && Uh(n, t.targetId, s.Qa), s } async function Yh(e) { const t = zr(e); return Yl(t.localStore).then(e => zh(t, e)) } async function Kh(e, t, n, r) { const s = zr(e), i = await function (e, t) { const n = zr(e), r = zr(n.Fs); return n.persistence.runTransaction("Lookup mutation documents", "readonly", e => r.ln(e, t).next(t => t ? n.ui.Us(e, t) : tc.resolve(null))) }(s.localStore, t); null !== i ? ("pending" === n ? await Wu(s.remoteStore) : "acknowledged" === n || "rejected" === n ? ($h(s, t, r || null), Mh(s, t), function (e, t) { zr(zr(e).Fs).dn(t) }(s.localStore, t)) : jr(), await zh(s, i)) : $r("SyncEngine", "Cannot apply mutation batch with id: " + t) } async function Xh(e, t, n) { const r = zr(e), s = [], i = []; for (const o of t) { let e; const t = r.Xa.get(o); if (t && 0 !== t.length) { e = await zl(r.localStore, Fi(t[0])); for (const e of t) { const t = r.Ya.get(e), n = await Wh(r, t); n.snapshot && i.push(n.snapshot) } } else { const t = await Wl(r.localStore, o); e = await zl(r.localStore, t), await Dh(r, Zh(t), o, !1) } s.push(e) } return r.Ja.Ko(i), s } function Zh(e) { return ki(e.path, e.collectionGroup, e.orderBy, e.filters, e.limit, "F", e.startAt, e.endAt) } function Qh(e) { const t = zr(e); return zr(zr(t.localStore).persistence).Ms() } async function Jh(e, t, n, r) { const s = zr(e); if (s.ou) $r("SyncEngine", "Ignoring unexpected query state notification."); else if (s.Xa.has(t)) switch (n) { case "current": case "not-current": { const e = await Yl(s.localStore), r = zo.createSynthesizedRemoteEventForCurrentChange(t, "current" === n); await zh(s, e, r); break } case "rejected": await Hl(s.localStore, t, !0), Bh(s, t, r); break; default: jr() } } async function ed(e, t, n) { const r = td(e); if (r.ou) { for (const e of t) { if (r.Xa.has(e)) { $r("SyncEngine", "Adding an already active target " + e); continue } const t = await Wl(r.localStore, e), n = await zl(r.localStore, t); await Dh(r, Zh(t), n.targetId, !1), Pu(r.remoteStore, n) } for (const e of n) r.Xa.has(e) && await Hl(r.localStore, e, !1).then(() => { Fu(r.remoteStore, e), Bh(r, e) }).catch(pl) } } function td(e) { const t = zr(e); return t.remoteStore.remoteSyncer.applyRemoteEvent = Rh.bind(null, t), t.remoteStore.remoteSyncer.getRemoteKeysForTarget = Gh.bind(null, t), t.remoteStore.remoteSyncer.rejectListen = Ph.bind(null, t), t.Ja.Ko = mh.bind(null, t.eventManager), t.Ja.uu = gh.bind(null, t.eventManager), t } function nd(e) { const t = zr(e); return t.remoteStore.remoteSyncer.applySuccessfulWrite = Fh.bind(null, t), t.remoteStore.remoteSyncer.rejectFailedWrite = Lh.bind(null, t), t } class rd { constructor() { this.synchronizeTabs = !1 } async initialize(e) { this.M = Su(e.databaseInfo.databaseId), this.sharedClientState = this.hu(e), this.persistence = this.lu(e), await this.persistence.start(), this.gcScheduler = this.fu(e), this.localStore = this.du(e) } fu(e) { return null } du(e) { return Bl(this.persistence, new Ml, e.initialUser, this.M) } lu(e) { return new su(ou.Wi, this.M) } hu(e) { return new gu } async terminate() { this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown() } } class sd extends rd { constructor(e, t, n) { super(), this._u = e, this.cacheSizeBytes = t, this.forceOwnership = n, this.synchronizeTabs = !1 } async initialize(e) { await super.initialize(e), await async function (e) { const t = zr(e); return t.persistence.runTransaction("Synchronize last document change read time", "readonly", e => function (e) { const t = Tl(e); let n = ls.min(); return t.Wt({ index: "readTimeIndex", reverse: !0 }, (e, t, r) => { t.readTime && (n = _c(t.readTime)), r.done() }).next(() => n) }(e)).then(e => { t.ri = e }) }(this.localStore), await this._u.initialize(this, e), await nd(this._u.syncEngine), await Wu(this._u.remoteStore), await this.persistence.ps(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve())) } du(e) { return Bl(this.persistence, new Ml, e.initialUser, this.M) } fu(e) { return new yl(this.persistence.referenceDelegate.garbageCollector, e.asyncQueue) } lu(e) { const t = Nl(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey), n = void 0 !== this.cacheSizeBytes ? tl.withCacheSize(this.cacheSizeBytes) : tl.DEFAULT; return new Dl(this.synchronizeTabs, t, e.clientId, n, e.asyncQueue, Eu(), Cu(), this.M, this.sharedClientState, !!this.forceOwnership) } hu(e) { return new gu } } class id extends sd { constructor(e, t) { super(e, t, !1), this._u = e, this.cacheSizeBytes = t, this.synchronizeTabs = !0 } async initialize(e) { await super.initialize(e); const t = this._u.syncEngine; this.sharedClientState instanceof mu && (this.sharedClientState.syncEngine = { Nr: Kh.bind(null, t), kr: Jh.bind(null, t), Mr: ed.bind(null, t), Ms: Qh.bind(null, t), Cr: Yh.bind(null, t) }, await this.sharedClientState.start()), await this.persistence.ps(async e => { await async function (e, t) { const n = zr(e); if (td(n), nd(n), !0 === t && !0 !== n.ou) { const e = n.sharedClientState.getAllActiveQueryTargets(), t = await Xh(n, e.toArray()); n.ou = !0, await rh(n.remoteStore, !0); for (const r of t) Pu(n.remoteStore, r) } else if (!1 === t && !1 !== n.ou) { const e = []; let t = Promise.resolve(); n.Xa.forEach((r, s) => { n.sharedClientState.isLocalQueryTarget(s) ? e.push(s) : t = t.then(() => (Bh(n, s), Hl(n.localStore, s, !0))), Fu(n.remoteStore, s) }), await t, await Xh(n, e), function (e) { const t = zr(e); t.eu.forEach((e, n) => { Fu(t.remoteStore, n) }), t.nu.bi(), t.eu = new Map, t.tu = new Ao(Os.comparator) }(n), n.ou = !1, await rh(n.remoteStore, !1) } }(this._u.syncEngine, e), this.gcScheduler && (e && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : e || this.gcScheduler.stop()) }) } hu(e) { const t = Eu(); if (!mu.vt(t)) throw new Gr(Hr.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage."); const n = Nl(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey); return new mu(t, e.asyncQueue, n, e.clientId, e.initialUser) } } class od { async initialize(e, t) { this.localStore || (this.localStore = e.localStore, this.sharedClientState = e.sharedClientState, this.datastore = this.createDatastore(t), this.remoteStore = this.createRemoteStore(t), this.eventManager = this.createEventManager(t), this.syncEngine = this.createSyncEngine(t, !e.synchronizeTabs), this.sharedClientState.onlineStateHandler = e => Nh(this.syncEngine, e, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Hh.bind(null, this.syncEngine), await rh(this.remoteStore, this.syncEngine.isPrimaryClient)) } createEventManager(e) { return new dh } createDatastore(e) { const t = Su(e.databaseInfo.databaseId), n = new _u(e.databaseInfo); return function (e, t, n, r) { return new xu(e, t, n, r) }(e.authCredentials, e.appCheckCredentials, n, t) } createRemoteStore(e) { return t = this.localStore, n = this.datastore, r = e.asyncQueue, s = e => Nh(this.syncEngine, e, 0), i = vu.vt() ? new vu : new yu, new Ou(t, n, r, s, i); var t, n, r, s, i } createSyncEngine(e, t) { return function (e, t, n, r, s, i, o) { const a = new Ah(e, t, n, r, s, i); return o && (a.ou = !0), a }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t) } terminate() { return async function (e) { const t = zr(e); $r("RemoteStore", "RemoteStore shutting down."), t.ha.add(5), await Nu(t), t.fa.shutdown(), t.da.set("Unknown") }(this.remoteStore) } } function ad(e, t = 10240) { let n = 0; return { async read() { if (n < e.byteLength) { const r = { value: e.slice(n, n + t), done: !1 }; return n += t, r } return { done: !0 } }, async cancel() { }, releaseLock() { }, closed: Promise.reject("unimplemented") } } class cd { constructor(e) { this.observer = e, this.muted = !1 } next(e) { this.observer.next && this.wu(this.observer.next, e) } error(e) { this.observer.error ? this.wu(this.observer.error, e) : console.error("Uncaught Error in snapshot listener:", e) } mu() { this.muted = !0 } wu(e, t) { this.muted || setTimeout(() => { this.muted || e(t) }, 0) } } class ld { constructor(e, t) { this.gu = e, this.M = t, this.metadata = new Wr, this.buffer = new Uint8Array, this.yu = new TextDecoder("utf-8"), this.pu().then(e => { e && e.Da() ? this.metadata.resolve(e.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(null == e ? void 0 : e.payload)}`)) }, e => this.metadata.reject(e)) } close() { return this.gu.cancel() } async getMetadata() { return this.metadata.promise } async cu() { return await this.getMetadata(), this.pu() } async pu() { const e = await this.Iu(); if (null === e) return null; const t = this.yu.decode(e), n = Number(t); isNaN(n) && this.Tu(`length string (${t}) is not valid number`); const r = await this.Eu(n); return new wh(JSON.parse(r), e.length + n) } Au() { return this.buffer.findIndex(e => e === "{".charCodeAt(0)) } async Iu() { for (; this.Au() < 0 && !(await this.Ru());); if (0 === this.buffer.length) return null; const e = this.Au(); e < 0 && this.Tu("Reached the end of bundle when a length string is expected."); const t = this.buffer.slice(0, e); return this.buffer = this.buffer.slice(e), t } async Eu(e) { for (; this.buffer.length < e;)await this.Ru() && this.Tu("Reached the end of bundle when more is expected."); const t = this.yu.decode(this.buffer.slice(0, e)); return this.buffer = this.buffer.slice(e), t } Tu(e) { throw this.gu.cancel(), new Error(`Invalid bundle format: ${e}`) } async Ru() { const e = await this.gu.read(); if (!e.done) { const t = new Uint8Array(this.buffer.length + e.value.length); t.set(this.buffer), t.set(e.value, this.buffer.length), this.buffer = t } return e.done } } class ud { constructor(e) { this.datastore = e, this.readVersions = new Map, this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = new Set } async lookup(e) { if (this.ensureCommitNotCalled(), this.mutations.length > 0) throw new Gr(Hr.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes."); const t = await async function (e, t) { const n = zr(e), r = da(n.M) + "/documents", s = { documents: t.map(e => ca(n.M, e)) }, i = await n.uo("BatchGetDocuments", r, s), o = new Map; i.forEach(e => { const t = function (e, t) { return "found" in t ? function (e, t) { qr(!!t.found); const n = la(e, t.found.name), r = ia(t.found.updateTime), s = new Zs({ mapValue: { fields: t.found.fields } }); return Js.newFoundDocument(n, r, s) }(e, t) : "missing" in t ? function (e, t) { qr(!!t.missing), qr(!!t.readTime); const n = la(e, t.missing), r = ia(t.readTime); return Js.newNoDocument(n, r) }(e, t) : jr() }(n.M, e); o.set(t.key.toString(), t) }); const a = []; return t.forEach(e => { const t = o.get(e.toString()); qr(!!t), a.push(t) }), a }(this.datastore, e); return t.forEach(e => this.recordVersion(e)), t } set(e, t) { this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } update(e, t) { try { this.write(t.toMutation(e, this.preconditionForUpdate(e))) } catch (e) { this.lastWriteError = e } this.writtenDocs.add(e.toString()) } delete(e) { this.write(new bo(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } async commit() { if (this.ensureCommitNotCalled(), this.lastWriteError) throw this.lastWriteError; const e = this.readVersions; this.mutations.forEach(t => { e.delete(t.key.toString()) }), e.forEach((e, t) => { const n = Os.fromPath(t); this.mutations.push(new _o(n, this.precondition(n))) }), await async function (e, t) { const n = zr(e), r = da(n.M) + "/documents", s = { writes: t.map(e => ga(n.M, e)) }; await n.io("Commit", r, s) }(this.datastore, this.mutations), this.committed = !0 } recordVersion(e) { let t; if (e.isFoundDocument()) t = e.version; else { if (!e.isNoDocument()) throw jr(); t = ls.min() } const n = this.readVersions.get(e.key.toString()); if (n) { if (!t.isEqual(n)) throw new Gr(Hr.ABORTED, "Document version changed between two reads.") } else this.readVersions.set(e.key.toString(), t) } precondition(e) { const t = this.readVersions.get(e.toString()); return !this.writtenDocs.has(e.toString()) && t ? oo.updateTime(t) : oo.none() } preconditionForUpdate(e) { const t = this.readVersions.get(e.toString()); if (!this.writtenDocs.has(e.toString()) && t) { if (t.isEqual(ls.min())) throw new Gr(Hr.INVALID_ARGUMENT, "Can't update a document that doesn't exist."); return oo.updateTime(t) } return oo.exists(!0) } write(e) { this.ensureCommitNotCalled(), this.mutations.push(e) } ensureCommitNotCalled() { } } class hd { constructor(e, t, n, r) { this.asyncQueue = e, this.datastore = t, this.updateFunction = n, this.deferred = r, this.bu = 5, this.vo = new Tu(this.asyncQueue, "transaction_retry") } run() { this.bu -= 1, this.Pu() } Pu() { this.vo.po(async () => { const e = new ud(this.datastore), t = this.Vu(e); t && t.then(t => { this.asyncQueue.enqueueAndForget(() => e.commit().then(() => { this.deferred.resolve(t) }).catch(e => { this.vu(e) })) }).catch(e => { this.vu(e) }) }) } Vu(e) { try { const t = this.updateFunction(e); return !As(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")), null) } catch (e) { return this.deferred.reject(e), null } } vu(e) { this.bu > 0 && this.Su(e) ? (this.bu -= 1, this.asyncQueue.enqueueAndForget(() => (this.Pu(), Promise.resolve()))) : this.deferred.reject(e) } Su(e) { if ("FirebaseError" === e.name) { const t = e.code; return "aborted" === t || "failed-precondition" === t || !To(t) } return !1 } } class dd { constructor(e, t, n, r) { this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = n, this.databaseInfo = r, this.user = Pr.UNAUTHENTICATED, this.clientId = ss.R(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async e => { $r("FirestoreClient", "Received user=", e.uid), await this.authCredentialListener(e), this.user = e }), this.appCheckCredentials.start(n, e => ($r("FirestoreClient", "Received new app check token=", e), this.appCheckCredentialListener(e, this.user))) } async getConfiguration() { return { asyncQueue: this.asyncQueue, databaseInfo: this.databaseInfo, clientId: this.clientId, authCredentials: this.authCredentials, appCheckCredentials: this.appCheckCredentials, initialUser: this.user, maxConcurrentLimboResolutions: 100 } } setCredentialChangeListener(e) { this.authCredentialListener = e } setAppCheckTokenChangeListener(e) { this.appCheckCredentialListener = e } verifyNotTerminated() { if (this.asyncQueue.isShuttingDown) throw new Gr(Hr.FAILED_PRECONDITION, "The client has already been terminated.") } terminate() { this.asyncQueue.enterRestrictedMode(); const e = new Wr; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => { try { this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), e.resolve() } catch (t) { const n = ah(t, "Failed to shutdown persistence"); e.reject(n) } }), e.promise } } async function fd(e, t) { e.asyncQueue.verifyOperationInProgress(), $r("FirestoreClient", "Initializing OfflineComponentProvider"); const n = await e.getConfiguration(); await t.initialize(n); let r = n.initialUser; e.setCredentialChangeListener(async e => { r.isEqual(e) || (await Vl(t.localStore, e), r = e) }), t.persistence.setDatabaseDeletedListener(() => e.terminate()), e.offlineComponents = t } async function pd(e, t) { e.asyncQueue.verifyOperationInProgress(); const n = await md(e); $r("FirestoreClient", "Initializing OnlineComponentProvider"); const r = await e.getConfiguration(); await t.initialize(n, r), e.setCredentialChangeListener(e => nh(t.remoteStore, e)), e.setAppCheckTokenChangeListener((e, n) => nh(t.remoteStore, n)), e.onlineComponents = t } async function md(e) { return e.offlineComponents || ($r("FirestoreClient", "Using default OfflineComponentProvider"), await fd(e, new rd)), e.offlineComponents } async function gd(e) { return e.onlineComponents || ($r("FirestoreClient", "Using default OnlineComponentProvider"), await pd(e, new od)), e.onlineComponents } function yd(e) { return md(e).then(e => e.persistence) } function vd(e) { return md(e).then(e => e.localStore) } function wd(e) { return gd(e).then(e => e.remoteStore) } function bd(e) { return gd(e).then(e => e.syncEngine) } async function _d(e) { const t = await gd(e), n = t.eventManager; return n.onListen = xh.bind(null, t.syncEngine), n.onUnlisten = Oh.bind(null, t.syncEngine), n } function Ed(e, t, n = {}) { const r = new Wr; return e.asyncQueue.enqueueAndForget(async () => function (e, t, n, r, s) { const i = new cd({ next: i => { t.enqueueAndForget(() => ph(e, o)); const a = i.docs.has(n); !a && i.fromCache ? s.reject(new Gr(Hr.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && i.fromCache && r && "server" === r.source ? s.reject(new Gr(Hr.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : s.resolve(i) }, error: e => s.reject(e) }), o = new vh(Ai(n.path), i, { includeMetadataChanges: !0, Sa: !0 }); return fh(e, o) }(await _d(e), e.asyncQueue, t, n, r)), r.promise } function Cd(e, t, n = {}) { const r = new Wr; return e.asyncQueue.enqueueAndForget(async () => function (e, t, n, r, s) { const i = new cd({ next: n => { t.enqueueAndForget(() => ph(e, o)), n.fromCache && "server" === r.source ? s.reject(new Gr(Hr.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : s.resolve(n) }, error: e => s.reject(e) }), o = new vh(n, i, { includeMetadataChanges: !0, Sa: !0 }); return fh(e, o) }(await _d(e), e.asyncQueue, t, n, r)), r.promise } const Sd = new Map; function Td(e, t, n) { if (!n) throw new Gr(Hr.INVALID_ARGUMENT, `Function ${e}() cannot be called with an empty ${t}.`) } function Id(e, t, n, r) { if (!0 === t && !0 === r) throw new Gr(Hr.INVALID_ARGUMENT, `${e} and ${n} cannot be used together.`) } function kd(e) { if (!Os.isDocumentKey(e)) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${e} has ${e.length}.`) } function Ad(e) { if (Os.isDocumentKey(e)) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${e} has ${e.length}.`) } function xd(e) { if (void 0 === e) return "undefined"; if (null === e) return "null"; if ("string" == typeof e) return e.length > 20 && (e = `${e.substring(0, 20)}...`), JSON.stringify(e); if ("number" == typeof e || "boolean" == typeof e) return "" + e; if ("object" == typeof e) { if (e instanceof Array) return "an array"; { const t = function (e) { return e.constructor ? e.constructor.name : null }(e); return t ? `a custom ${t} object` : "an object" } } return "function" == typeof e ? "a function" : jr() } function Dd(e, t) { if ("_delegate" in e && (e = e._delegate), !(e instanceof t)) { if (t.name === e.constructor.name) throw new Gr(Hr.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const n = xd(e); throw new Gr(Hr.INVALID_ARGUMENT, `Expected type '${t.name}', but it was: ${n}`) } } return e } function Od(e, t) { if (t <= 0) throw new Gr(Hr.INVALID_ARGUMENT, `Function ${e}() requires a positive number, but it was: ${t}.`) } class Rd { constructor(e) { var t; if (void 0 === e.host) { if (void 0 !== e.ssl) throw new Gr(Hr.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = "firestore.googleapis.com", this.ssl = !0 } else this.host = e.host, this.ssl = null === (t = e.ssl) || void 0 === t || t; if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, void 0 === e.cacheSizeBytes) this.cacheSizeBytes = 41943040; else { if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576) throw new Gr(Hr.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = e.cacheSizeBytes } this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.useFetchStreams = !!e.useFetchStreams, Id("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling) } isEqual(e) { return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams } } class Nd { constructor(e, t, n) { this._authCredentials = t, this._appCheckCredentials = n, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Rd({}), this._settingsFrozen = !1, e instanceof ks ? this._databaseId = e : (this._app = e, this._databaseId = function (e) { if (!Object.prototype.hasOwnProperty.apply(e.options, ["projectId"])) throw new Gr(Hr.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new ks(e.options.projectId) }(e)) } get app() { if (!this._app) throw new Gr(Hr.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return void 0 !== this._terminateTask } _setSettings(e) { if (this._settingsFrozen) throw new Gr(Hr.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new Rd(e), void 0 !== e.credentials && (this._authCredentials = function (e) { if (!e) return new Kr; switch (e.type) { case "gapi": const t = e.client; return qr(!("object" != typeof t || null === t || !t.auth || !t.auth.getAuthHeaderValueForFirstParty)), new Jr(t, e.sessionIndex || "0", e.iamToken || null); case "provider": return e.client; default: throw new Gr(Hr.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } }(e.credentials)) } _getSettings() { return this._settings } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return function (e) { const t = Sd.get(e); t && ($r("ComponentProvider", "Removing Datastore"), Sd.delete(e), t.terminate()) }(this), Promise.resolve() } } class Pd { constructor(e, t, n) { this.converter = t, this._key = n, this.type = "document", this.firestore = e } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new Ld(this.firestore, this.converter, this._key.path.popLast()) } withConverter(e) { return new Pd(this.firestore, e, this._key) } } class Fd { constructor(e, t, n) { this.converter = t, this._query = n, this.type = "query", this.firestore = e } withConverter(e) { return new Fd(this.firestore, e, this._query) } } class Ld extends Fd { constructor(e, t, n) { super(e, t, Ai(n)), this._path = n, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const e = this._path.popLast(); return e.isEmpty() ? null : new Pd(this.firestore, null, new Os(e)) } withConverter(e) { return new Ld(this.firestore, e, this._path) } } function Md(e, t, ...n) { if (e = (0, T.m9)(e), Td("collection", "path", t), e instanceof Nd) { const r = ps.fromString(t, ...n); return Ad(r), new Ld(e, null, r) } { if (!(e instanceof Pd || e instanceof Ld)) throw new Gr(Hr.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const r = e._path.child(ps.fromString(t, ...n)); return Ad(r), new Ld(e.firestore, null, r) } } function $d(e, t, ...n) { if (e = (0, T.m9)(e), 1 === arguments.length && (t = ss.R()), Td("doc", "path", t), e instanceof Nd) { const r = ps.fromString(t, ...n); return kd(r), new Pd(e, null, new Os(r)) } { if (!(e instanceof Pd || e instanceof Ld)) throw new Gr(Hr.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const r = e._path.child(ps.fromString(t, ...n)); return kd(r), new Pd(e.firestore, e instanceof Ld ? e.converter : null, new Os(r)) } } function Bd(e, t) { return e = (0, T.m9)(e), t = (0, T.m9)(t), (e instanceof Pd || e instanceof Ld) && (t instanceof Pd || t instanceof Ld) && e.firestore === t.firestore && e.path === t.path && e.converter === t.converter } function Vd(e, t) { return e = (0, T.m9)(e), t = (0, T.m9)(t), e instanceof Fd && t instanceof Fd && e.firestore === t.firestore && Mi(e._query, t._query) && e.converter === t.converter } class Ud { constructor() { this.Du = Promise.resolve(), this.Cu = [], this.xu = !1, this.Nu = [], this.ku = null, this.Mu = !1, this.Ou = !1, this.$u = [], this.vo = new Tu(this, "async_queue_retry"), this.Fu = () => { const e = Cu(); e && $r("AsyncQueue", "Visibility state changed to " + e.visibilityState), this.vo.To() }; const e = Cu(); e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.Fu) } get isShuttingDown() { return this.xu } enqueueAndForget(e) { this.enqueue(e) } enqueueAndForgetEvenWhileRestricted(e) { this.Bu(), this.Lu(e) } enterRestrictedMode(e) { if (!this.xu) { this.xu = !0, this.Ou = e || !1; const t = Cu(); t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.Fu) } } enqueue(e) { if (this.Bu(), this.xu) return new Promise(() => { }); const t = new Wr; return this.Lu(() => this.xu && this.Ou ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise) } enqueueRetryable(e) { this.enqueueAndForget(() => (this.Cu.push(e), this.qu())) } async qu() { if (0 !== this.Cu.length) { try { await this.Cu[0](), this.Cu.shift(), this.vo.reset() } catch (B) { if (!oc(B)) throw B; $r("AsyncQueue", "Operation failed with retryable error: " + B) } this.Cu.length > 0 && this.vo.po(() => this.qu()) } } Lu(e) { const t = this.Du.then(() => (this.Mu = !0, e().catch(e => { throw this.ku = e, this.Mu = !1, Br("INTERNAL UNHANDLED ERROR: ", function (e) { let t = e.message || ""; return e.stack && (t = e.stack.includes(e.message) ? e.stack : e.message + "\n" + e.stack), t }(e)), e }).then(e => (this.Mu = !1, e)))); return this.Du = t, t } enqueueAfterDelay(e, t, n) { this.Bu(), this.$u.indexOf(e) > -1 && (t = 0); const r = oh.createAndSchedule(this, e, t, n, e => this.Uu(e)); return this.Nu.push(r), r } Bu() { this.ku && jr() } verifyOperationInProgress() { } async Ku() { let e; do { e = this.Du, await e } while (e !== this.Du) } Gu(e) { for (const t of this.Nu) if (t.timerId === e) return !0; return !1 } Qu(e) { return this.Ku().then(() => { this.Nu.sort((e, t) => e.targetTimeMs - t.targetTimeMs); for (const t of this.Nu) if (t.skipDelay(), "all" !== e && t.timerId === e) break; return this.Ku() }) } ju(e) { this.$u.push(e) } Uu(e) { const t = this.Nu.indexOf(e); this.Nu.splice(t, 1) } } function jd(e) { return function (e, t) { if ("object" != typeof e || null === e) return !1; const n = e; for (const r of ["next", "error", "complete"]) if (r in n && "function" == typeof n[r]) return !0; return !1 }(e) } class qd { constructor() { this._progressObserver = {}, this._taskCompletionResolver = new Wr, this._lastProgress = { taskState: "Running", totalBytes: 0, totalDocuments: 0, bytesLoaded: 0, documentsLoaded: 0 } } onProgress(e, t, n) { this._progressObserver = { next: e, error: t, complete: n } } catch(e) { return this._taskCompletionResolver.promise.catch(e) } then(e, t) { return this._taskCompletionResolver.promise.then(e, t) } _completeWith(e) { this._updateProgress(e), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(e) } _failWith(e) { this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(e), this._taskCompletionResolver.reject(e) } _updateProgress(e) { this._lastProgress = e, this._progressObserver.next && this._progressObserver.next(e) } } class zd extends Nd { constructor(e, t, n) { super(e, t, n), this.type = "firestore", this._queue = new Ud, this._persistenceKey = "name" in e ? e.name : "[DEFAULT]" } _terminate() { return this._firestoreClient || Gd(this), this._firestoreClient.terminate() } } function Hd(e) { return e._firestoreClient || Gd(e), e._firestoreClient.verifyNotTerminated(), e._firestoreClient } function Gd(e) { var t; const n = e._freezeSettings(), r = function (e, t, n, r) { return new Is(e, t, n, r.host, r.ssl, r.experimentalForceLongPolling, r.experimentalAutoDetectLongPolling, r.useFetchStreams) }(e._databaseId, (null === (t = e._app) || void 0 === t ? void 0 : t.options.appId) || "", e._persistenceKey, n); e._firestoreClient = new dd(e._authCredentials, e._appCheckCredentials, e._queue, r) } function Wd(e, t, n) { const r = new Wr; return e.asyncQueue.enqueue(async () => { try { await fd(e, n), await pd(e, t), r.resolve() } catch (e) { if (!function (e) { return "FirebaseError" === e.name ? e.code === Hr.FAILED_PRECONDITION || e.code === Hr.UNIMPLEMENTED : !("undefined" != typeof DOMException && e instanceof DOMException) || 22 === e.code || 20 === e.code || 11 === e.code }(e)) throw e; console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + e), r.reject(e) } }).then(() => r.promise) } function Yd(e) { if (e._initialized || e._terminated) throw new Gr(Hr.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.") } class Kd { constructor(...e) { for (let t = 0; t < e.length; ++t)if (0 === e[t].length) throw new Gr(Hr.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new gs(e) } isEqual(e) { return this._internalPath.isEqual(e._internalPath) } } class Xd { constructor(e) { this._byteString = e } static fromBase64String(e) { try { return new Xd(vs.fromBase64String(e)) } catch (e) { throw new Gr(Hr.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + e) } } static fromUint8Array(e) { return new Xd(vs.fromUint8Array(e)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(e) { return this._byteString.isEqual(e._byteString) } } class Zd { constructor(e) { this._methodName = e } } class Qd { constructor(e, t) { if (!isFinite(e) || e < -90 || e > 90) throw new Gr(Hr.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e); if (!isFinite(t) || t < -180 || t > 180) throw new Gr(Hr.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t); this._lat = e, this._long = t } get latitude() { return this._lat } get longitude() { return this._long } isEqual(e) { return this._lat === e._lat && this._long === e._long } toJSON() { return { latitude: this._lat, longitude: this._long } } _compareTo(e) { return is(this._lat, e._lat) || is(this._long, e._long) } } const Jd = /^__.*__$/; class ef { constructor(e, t, n) { this.data = e, this.fieldMask = t, this.fieldTransforms = n } toMutation(e, t) { return null !== this.fieldMask ? new go(e, this.data, this.fieldMask, t, this.fieldTransforms) : new mo(e, this.data, t, this.fieldTransforms) } } class tf { constructor(e, t, n) { this.data = e, this.fieldMask = t, this.fieldTransforms = n } toMutation(e, t) { return new go(e, this.data, this.fieldMask, t, this.fieldTransforms) } } function nf(e) { switch (e) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw jr() } } class rf { constructor(e, t, n, r, s, i) { this.settings = e, this.databaseId = t, this.M = n, this.ignoreUndefinedProperties = r, void 0 === s && this.Wu(), this.fieldTransforms = s || [], this.fieldMask = i || [] } get path() { return this.settings.path } get zu() { return this.settings.zu } Hu(e) { return new rf(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.M, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } Ju(e) { var t; const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.Hu({ path: n, Yu: !1 }); return r.Xu(e), r } Zu(e) { var t; const n = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), r = this.Hu({ path: n, Yu: !1 }); return r.Wu(), r } tc(e) { return this.Hu({ path: void 0, Yu: !0 }) } ec(e) { return Sf(e, this.settings.methodName, this.settings.nc || !1, this.path, this.settings.sc) } contains(e) { return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field)) } Wu() { if (this.path) for (let e = 0; e < this.path.length; e++)this.Xu(this.path.get(e)) } Xu(e) { if (0 === e.length) throw this.ec("Document fields must not be empty"); if (nf(this.zu) && Jd.test(e)) throw this.ec('Document fields cannot begin and end with "__"') } } class sf { constructor(e, t, n) { this.databaseId = e, this.ignoreUndefinedProperties = t, this.M = n || Su(e) } ic(e, t, n, r = !1) { return new rf({ zu: e, methodName: t, sc: n, path: gs.emptyPath(), Yu: !1, nc: r }, this.databaseId, this.M, this.ignoreUndefinedProperties) } } function of(e) { const t = e._freezeSettings(), n = Su(e._databaseId); return new sf(e._databaseId, !!t.ignoreUndefinedProperties, n) } function af(e, t, n, r, s, i = {}) { const o = e.ic(i.merge || i.mergeFields ? 2 : 0, t, n, s); bf("Data must be an object, but it was:", o, r); const a = vf(r, o); let c, l; if (i.merge) c = new ys(o.fieldMask), l = o.fieldTransforms; else if (i.mergeFields) { const e = []; for (const r of i.mergeFields) { const s = _f(t, r, n); if (!o.contains(s)) throw new Gr(Hr.INVALID_ARGUMENT, `Field '${s}' is specified in your field mask but missing from your input data.`); Tf(e, s) || e.push(s) } c = new ys(e), l = o.fieldTransforms.filter(e => c.covers(e.field)) } else c = null, l = o.fieldTransforms; return new ef(new Zs(a), c, l) } class cf extends Zd { _toFieldTransform(e) { if (2 !== e.zu) throw e.ec(1 === e.zu ? `${this._methodName}() can only appear at the top level of your update data` : `${this._methodName}() cannot be used with set() unless you pass {merge:true}`); return e.fieldMask.push(e.path), null } isEqual(e) { return e instanceof cf } } function lf(e, t, n) { return new rf({ zu: 3, sc: t.settings.sc, methodName: e._methodName, Yu: n }, t.databaseId, t.M, t.ignoreUndefinedProperties) } class uf extends Zd { _toFieldTransform(e) { return new so(e.path, new Xi) } isEqual(e) { return e instanceof uf } } class hf extends Zd { constructor(e, t) { super(e), this.rc = t } _toFieldTransform(e) { const t = lf(this, e, !0), n = this.rc.map(e => yf(e, t)), r = new Zi(n); return new so(e.path, r) } isEqual(e) { return this === e } } class df extends Zd { constructor(e, t) { super(e), this.rc = t } _toFieldTransform(e) { const t = lf(this, e, !0), n = this.rc.map(e => yf(e, t)), r = new Ji(n); return new so(e.path, r) } isEqual(e) { return this === e } } class ff extends Zd { constructor(e, t) { super(e), this.oc = t } _toFieldTransform(e) { const t = new to(e.M, Hi(e.M, this.oc)); return new so(e.path, t) } isEqual(e) { return this === e } } function pf(e, t, n, r) { const s = e.ic(1, t, n); bf("Data must be an object, but it was:", s, r); const i = [], o = Zs.empty(); hs(r, (e, r) => { const a = Cf(t, e, n); r = (0, T.m9)(r); const c = s.Zu(a); if (r instanceof cf) i.push(a); else { const e = yf(r, c); null != e && (i.push(a), o.set(a, e)) } }); const a = new ys(i); return new tf(o, a, s.fieldTransforms) } function mf(e, t, n, r, s, i) { const o = e.ic(1, t, n), a = [_f(t, r, n)], c = [s]; if (i.length % 2 != 0) throw new Gr(Hr.INVALID_ARGUMENT, `Function ${t}() needs to be called with an even number of arguments that alternate between field names and values.`); for (let d = 0; d < i.length; d += 2)a.push(_f(t, i[d])), c.push(i[d + 1]); const l = [], u = Zs.empty(); for (let d = a.length - 1; d >= 0; --d)if (!Tf(l, a[d])) { const e = a[d]; let t = c[d]; t = (0, T.m9)(t); const n = o.Zu(e); if (t instanceof cf) l.push(e); else { const r = yf(t, n); null != r && (l.push(e), u.set(e, r)) } } const h = new ys(l); return new tf(u, h, o.fieldTransforms) } function gf(e, t, n, r = !1) { return yf(n, e.ic(r ? 4 : 3, t)) } function yf(e, t) { if (wf(e = (0, T.m9)(e))) return bf("Unsupported field value:", t, e), vf(e, t); if (e instanceof Zd) return function (e, t) { if (!nf(t.zu)) throw t.ec(`${e._methodName}() can only be used with update() and set()`); if (!t.path) throw t.ec(`${e._methodName}() is not currently supported inside arrays`); const n = e._toFieldTransform(t); n && t.fieldTransforms.push(n) }(e, t), null; if (void 0 === e && t.ignoreUndefinedProperties) return null; if (t.path && t.fieldMask.push(t.path), e instanceof Array) { if (t.settings.Yu && 4 !== t.zu) throw t.ec("Nested arrays are not supported"); return function (e, t) { const n = []; let r = 0; for (const s of e) { let e = yf(s, t.tc(r)); null == e && (e = { nullValue: "NULL_VALUE" }), n.push(e), r++ } return { arrayValue: { values: n } } }(e, t) } return function (e, t) { if (null === (e = (0, T.m9)(e))) return { nullValue: "NULL_VALUE" }; if ("number" == typeof e) return Hi(t.M, e); if ("boolean" == typeof e) return { booleanValue: e }; if ("string" == typeof e) return { stringValue: e }; if (e instanceof Date) { const n = cs.fromDate(e); return { timestampValue: na(t.M, n) } } if (e instanceof cs) { const n = new cs(e.seconds, 1e3 * Math.floor(e.nanoseconds / 1e3)); return { timestampValue: na(t.M, n) } } if (e instanceof Qd) return { geoPointValue: { latitude: e.latitude, longitude: e.longitude } }; if (e instanceof Xd) return { bytesValue: ra(t.M, e._byteString) }; if (e instanceof Pd) { const n = t.databaseId, r = e.firestore._databaseId; if (!r.isEqual(n)) throw t.ec(`Document reference is for database ${r.projectId}/${r.database} but should be for database ${n.projectId}/${n.database}`); return { referenceValue: oa(e.firestore._databaseId || t.databaseId, e._key.path) } } throw t.ec(`Unsupported field value: ${xd(e)}`) }(e, t) } function vf(e, t) { const n = {}; return ds(e) ? t.path && t.path.length > 0 && t.fieldMask.push(t.path) : hs(e, (e, r) => { const s = yf(r, t.Ju(e)); null != s && (n[e] = s) }), { mapValue: { fields: n } } } function wf(e) { return !("object" != typeof e || null === e || e instanceof Array || e instanceof Date || e instanceof cs || e instanceof Qd || e instanceof Xd || e instanceof Pd || e instanceof Zd) } function bf(e, t, n) { if (!wf(n) || !function (e) { return "object" == typeof e && null !== e && (Object.getPrototypeOf(e) === Object.prototype || null === Object.getPrototypeOf(e)) }(n)) { const r = xd(n); throw t.ec("an object" === r ? e + " a custom object" : e + " " + r) } } function _f(e, t, n) { if ((t = (0, T.m9)(t)) instanceof Kd) return t._internalPath; if ("string" == typeof t) return Cf(e, t); throw Sf("Field path arguments must be of type string or ", e, !1, void 0, n) } const Ef = new RegExp("[~\\*/\\[\\]]"); function Cf(e, t, n) { if (t.search(Ef) >= 0) throw Sf(`Invalid field path (${t}). Paths must not contain '~', '*', '/', '[', or ']'`, e, !1, void 0, n); try { return new Kd(...t.split("."))._internalPath } catch (r) { throw Sf(`Invalid field path (${t}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, e, !1, void 0, n) } } function Sf(e, t, n, r, s) { const i = r && !r.isEmpty(), o = void 0 !== s; let a = `Function ${t}() called with invalid data`; n && (a += " (via `toFirestore()`)"), a += ". "; let c = ""; return (i || o) && (c += " (found", i && (c += ` in field ${r}`), o && (c += ` in document ${s}`), c += ")"), new Gr(Hr.INVALID_ARGUMENT, a + e + c) } function Tf(e, t) { return e.some(e => e.isEqual(t)) } class If { constructor(e, t, n, r, s) { this._firestore = e, this._userDataWriter = t, this._key = n, this._document = r, this._converter = s } get id() { return this._key.path.lastSegment() } get ref() { return new Pd(this._firestore, this._converter, this._key) } exists() { return null !== this._document } data() { if (this._document) { if (this._converter) { const e = new kf(this._firestore, this._userDataWriter, this._key, this._document, null); return this._converter.fromFirestore(e) } return this._userDataWriter.convertValue(this._document.data.value) } } get(e) { if (this._document) { const t = this._document.data.field(Af("DocumentSnapshot.get", e)); if (null !== t) return this._userDataWriter.convertValue(t) } } } class kf extends If { data() { return super.data() } } function Af(e, t) { return "string" == typeof t ? Cf(e, t) : t instanceof Kd ? t._internalPath : t._delegate._internalPath } class xf { constructor(e, t) { this.hasPendingWrites = e, this.fromCache = t } isEqual(e) { return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache } } class Df extends If { constructor(e, t, n, r, s, i) { super(e, t, n, r, i), this._firestore = e, this._firestoreImpl = e, this.metadata = s } exists() { return super.exists() } data(e = {}) { if (this._document) { if (this._converter) { const t = new Of(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null); return this._converter.fromFirestore(t, e) } return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps) } } get(e, t = {}) { if (this._document) { const n = this._document.data.field(Af("DocumentSnapshot.get", e)); if (null !== n) return this._userDataWriter.convertValue(n, t.serverTimestamps) } } } class Of extends Df { data(e = {}) { return super.data(e) } } class Rf { constructor(e, t, n, r) { this._firestore = e, this._userDataWriter = t, this._snapshot = r, this.metadata = new xf(r.hasPendingWrites, r.fromCache), this.query = n } get docs() { const e = []; return this.forEach(t => e.push(t)), e } get size() { return this._snapshot.docs.size } get empty() { return 0 === this.size } forEach(e, t) { this._snapshot.docs.forEach(n => { e.call(t, new Of(this._firestore, this._userDataWriter, n.key, n, new xf(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter)) }) } docChanges(e = {}) { const t = !!e.includeMetadataChanges; if (t && this._snapshot.excludesMetadataChanges) throw new Gr(Hr.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot()."); return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t || (this._cachedChanges = function (e, t) { if (e._snapshot.oldDocs.isEmpty()) { let t = 0; return e._snapshot.docChanges.map(n => ({ type: "added", doc: new Of(e._firestore, e._userDataWriter, n.doc.key, n.doc, new xf(e._snapshot.mutatedKeys.has(n.doc.key), e._snapshot.fromCache), e.query.converter), oldIndex: -1, newIndex: t++ })) } { let n = e._snapshot.oldDocs; return e._snapshot.docChanges.filter(e => t || 3 !== e.type).map(t => { const r = new Of(e._firestore, e._userDataWriter, t.doc.key, t.doc, new xf(e._snapshot.mutatedKeys.has(t.doc.key), e._snapshot.fromCache), e.query.converter); let s = -1, i = -1; return 0 !== t.type && (s = n.indexOf(t.doc.key), n = n.delete(t.doc.key)), 1 !== t.type && (n = n.add(t.doc), i = n.indexOf(t.doc.key)), { type: Nf(t.type), doc: r, oldIndex: s, newIndex: i } }) } }(this, t), this._cachedChangesIncludeMetadataChanges = t), this._cachedChanges } } function Nf(e) { switch (e) { case 0: return "added"; case 2: case 3: return "modified"; case 1: return "removed"; default: return jr() } } function Pf(e, t) { return e instanceof Df && t instanceof Df ? e._firestore === t._firestore && e._key.isEqual(t._key) && (null === e._document ? null === t._document : e._document.isEqual(t._document)) && e._converter === t._converter : e instanceof Rf && t instanceof Rf && e._firestore === t._firestore && Vd(e.query, t.query) && e.metadata.isEqual(t.metadata) && e._snapshot.isEqual(t._snapshot) } function Ff(e) { if (Di(e) && 0 === e.explicitOrderBy.length) throw new Gr(Hr.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause") } class Lf { } function Mf(e, ...t) { for (const n of t) e = n._apply(e); return e } class $f extends Lf { constructor(e, t, n) { super(), this.ac = e, this.uc = t, this.cc = n, this.type = "where" } _apply(e) { const t = of(e.firestore), n = function (e, t, n, r, s, i, o) { let a; if (s.isKeyField()) { if ("array-contains" === i || "array-contains-any" === i) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid Query. You can't perform '${i}' queries on documentId().`); if ("in" === i || "not-in" === i) { Hf(o, i); const t = []; for (const n of o) t.push(zf(r, e, n)); a = { arrayValue: { values: t } } } else a = zf(r, e, o) } else "in" !== i && "not-in" !== i && "array-contains-any" !== i || Hf(o, i), a = gf(n, "where", o, "in" === i || "not-in" === i); const c = di.create(s, i, a); return function (e, t) { if (t.S()) { const n = Ri(e); if (null !== n && !n.isEqual(t.field)) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n.toString()}' and '${t.field.toString()}'`); const r = Oi(e); null !== r && Gf(0, t.field, r) } const n = function (e, t) { for (const n of e.filters) if (t.indexOf(n.op) >= 0) return n.op; return null }(e, function (e) { switch (e) { case "!=": return ["!=", "not-in"]; case "array-contains": return ["array-contains", "array-contains-any", "not-in"]; case "in": return ["array-contains-any", "in", "not-in"]; case "array-contains-any": return ["array-contains", "array-contains-any", "in", "not-in"]; case "not-in": return ["array-contains", "array-contains-any", "in", "not-in", "!="]; default: return [] } }(t.op)); if (null !== n) throw new Gr(Hr.INVALID_ARGUMENT, n === t.op ? `Invalid query. You cannot use more than one '${t.op.toString()}' filter.` : `Invalid query. You cannot use '${t.op.toString()}' filters with '${n.toString()}' filters.`) }(e, c), c }(e._query, 0, t, e.firestore._databaseId, this.ac, this.uc, this.cc); return new Fd(e.firestore, e.converter, function (e, t) { const n = e.filters.concat([t]); return new Ii(e.path, e.collectionGroup, e.explicitOrderBy.slice(), n, e.limit, e.limitType, e.startAt, e.endAt) }(e._query, n)) } } class Bf extends Lf { constructor(e, t) { super(), this.ac = e, this.hc = t, this.type = "orderBy" } _apply(e) { const t = function (e, t, n) { if (null !== e.startAt) throw new Gr(Hr.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy()."); if (null !== e.endAt) throw new Gr(Hr.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy()."); const r = new Ei(t, n); return function (e, t) { if (null === Oi(e)) { const n = Ri(e); null !== n && Gf(0, n, t.field) } }(e, r), r }(e._query, this.ac, this.hc); return new Fd(e.firestore, e.converter, function (e, t) { const n = e.explicitOrderBy.concat([t]); return new Ii(e.path, e.collectionGroup, n, e.filters.slice(), e.limit, e.limitType, e.startAt, e.endAt) }(e._query, t)) } } class Vf extends Lf { constructor(e, t, n) { super(), this.type = e, this.lc = t, this.fc = n } _apply(e) { return new Fd(e.firestore, e.converter, Li(e._query, this.lc, this.fc)) } } class Uf extends Lf { constructor(e, t, n) { super(), this.type = e, this.dc = t, this._c = n } _apply(e) { const t = qf(e, this.type, this.dc, this._c); return new Fd(e.firestore, e.converter, function (e, t) { return new Ii(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, t, e.endAt) }(e._query, t)) } } class jf extends Lf { constructor(e, t, n) { super(), this.type = e, this.dc = t, this._c = n } _apply(e) { const t = qf(e, this.type, this.dc, this._c); return new Fd(e.firestore, e.converter, function (e, t) { return new Ii(e.path, e.collectionGroup, e.explicitOrderBy.slice(), e.filters.slice(), e.limit, e.limitType, e.startAt, t) }(e._query, t)) } } function qf(e, t, n, r) { if (n[0] = (0, T.m9)(n[0]), n[0] instanceof If) return function (e, t, n, r, s) { if (!r) throw new Gr(Hr.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n}().`); const i = []; for (const o of Pi(e)) if (o.field.isKeyField()) i.push(Us(t, r.key)); else { const e = r.data.field(o.field); if (Cs(e)) throw new Gr(Hr.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + o.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'); if (null === e) { const e = o.field.canonicalString(); throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${e}' (used as the orderBy) does not exist.`) } i.push(e) } return new _i(i, s) }(e._query, e.firestore._databaseId, t, n[0]._document, r); { const s = of(e.firestore); return function (e, t, n, r, s, i) { const o = e.explicitOrderBy; if (s.length > o.length) throw new Gr(Hr.INVALID_ARGUMENT, `Too many arguments provided to ${r}(). The number of arguments must be less than or equal to the number of orderBy() clauses`); const a = []; for (let c = 0; c < s.length; c++) { const i = s[c]; if (o[c].field.isKeyField()) { if ("string" != typeof i) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${r}(), but got a ${typeof i}`); if (!Ni(e) && -1 !== i.indexOf("/")) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${r}() must be a plain document ID, but '${i}' contains a slash.`); const n = e.path.child(ps.fromString(i)); if (!Os.isDocumentKey(n)) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${r}() must result in a valid document path, but '${n}' is not because it contains an odd number of segments.`); const s = new Os(n); a.push(Us(t, s)) } else { const e = gf(n, r, i); a.push(e) } } return new _i(a, i) }(e._query, e.firestore._databaseId, s, t, n, r) } } function zf(e, t, n) { if ("string" == typeof (n = (0, T.m9)(n))) { if ("" === n) throw new Gr(Hr.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string."); if (!Ni(t) && -1 !== n.indexOf("/")) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`); const r = t.path.child(ps.fromString(n)); if (!Os.isDocumentKey(r)) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`); return Us(e, new Os(r)) } if (n instanceof Pd) return Us(e, n._key); throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${xd(n)}.`) } function Hf(e, t) { if (!Array.isArray(e) || 0 === e.length) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${t.toString()}' filters.`); if (e.length > 10) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid Query. '${t.toString()}' filters support a maximum of 10 elements in the value array.`) } function Gf(e, t, n) { if (!n.isEqual(t)) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${t.toString()}' and so you must also use '${t.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`) } class Wf { convertValue(e, t = "none") { switch (Ps(e)) { case 0: return null; case 1: return e.booleanValue; case 2: return _s(e.integerValue || e.doubleValue); case 3: return this.convertTimestamp(e.timestampValue); case 4: return this.convertServerTimestamp(e, t); case 5: return e.stringValue; case 6: return this.convertBytes(Es(e.bytesValue)); case 7: return this.convertReference(e.referenceValue); case 8: return this.convertGeoPoint(e.geoPointValue); case 9: return this.convertArray(e.arrayValue, t); case 10: return this.convertObject(e.mapValue, t); default: throw jr() } } convertObject(e, t) { const n = {}; return hs(e.fields, (e, r) => { n[e] = this.convertValue(r, t) }), n } convertGeoPoint(e) { return new Qd(_s(e.latitude), _s(e.longitude)) } convertArray(e, t) { return (e.values || []).map(e => this.convertValue(e, t)) } convertServerTimestamp(e, t) { switch (t) { case "previous": const n = Ss(e); return null == n ? null : this.convertValue(n, t); case "estimate": return this.convertTimestamp(Ts(e)); default: return null } } convertTimestamp(e) { const t = bs(e); return new cs(t.seconds, t.nanos) } convertDocumentKey(e, t) { const n = ps.fromString(e); qr(xa(n)); const r = new ks(n.get(1), n.get(3)), s = new Os(n.popFirst(5)); return r.isEqual(t) || Br(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), s } } function Yf(e, t, n) { let r; return r = e ? n && (n.merge || n.mergeFields) ? e.toFirestore(t, n) : e.toFirestore(t) : t, r } class Kf extends Wf { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new Xd(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new Pd(this.firestore, null, t) } } class Xf { constructor(e, t) { this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = of(e) } set(e, t, n) { this._verifyNotCommitted(); const r = Zf(e, this._firestore), s = Yf(r.converter, t, n), i = af(this._dataReader, "WriteBatch.set", r._key, s, null !== r.converter, n); return this._mutations.push(i.toMutation(r._key, oo.none())), this } update(e, t, n, ...r) { this._verifyNotCommitted(); const s = Zf(e, this._firestore); let i; return i = "string" == typeof (t = (0, T.m9)(t)) || t instanceof Kd ? mf(this._dataReader, "WriteBatch.update", s._key, t, n, r) : pf(this._dataReader, "WriteBatch.update", s._key, t), this._mutations.push(i.toMutation(s._key, oo.exists(!0))), this } delete(e) { this._verifyNotCommitted(); const t = Zf(e, this._firestore); return this._mutations = this._mutations.concat(new bo(t._key, oo.none())), this } commit() { return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve() } _verifyNotCommitted() { if (this._committed) throw new Gr(Hr.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.") } } function Zf(e, t) { if ((e = (0, T.m9)(e)).firestore !== t) throw new Gr(Hr.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance."); return e } class Qf extends Wf { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new Xd(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new Pd(this.firestore, null, t) } } function Jf(e, t, n) { e = Dd(e, Pd); const r = Dd(e.firestore, zd), s = Yf(e.converter, t, n); return np(r, [af(of(r), "setDoc", e._key, s, null !== e.converter, n).toMutation(e._key, oo.none())]) } function ep(e, t, n, ...r) { e = Dd(e, Pd); const s = Dd(e.firestore, zd), i = of(s); let o; return o = "string" == typeof (t = (0, T.m9)(t)) || t instanceof Kd ? mf(i, "updateDoc", e._key, t, n, r) : pf(i, "updateDoc", e._key, t), np(s, [o.toMutation(e._key, oo.exists(!0))]) } function tp(e, ...t) { var n, r, s; e = (0, T.m9)(e); let i = { includeMetadataChanges: !1 }, o = 0; "object" != typeof t[o] || jd(t[o]) || (i = t[o], o++); const a = { includeMetadataChanges: i.includeMetadataChanges }; if (jd(t[o])) { const e = t[o]; t[o] = null === (n = e.next) || void 0 === n ? void 0 : n.bind(e), t[o + 1] = null === (r = e.error) || void 0 === r ? void 0 : r.bind(e), t[o + 2] = null === (s = e.complete) || void 0 === s ? void 0 : s.bind(e) } let c, l, u; if (e instanceof Pd) l = Dd(e.firestore, zd), u = Ai(e._key.path), c = { next: n => { t[o] && t[o](rp(l, e, n)) }, error: t[o + 1], complete: t[o + 2] }; else { const n = Dd(e, Fd); l = Dd(n.firestore, zd), u = n._query; const r = new Qf(l); c = { next: e => { t[o] && t[o](new Rf(l, r, n, e)) }, error: t[o + 1], complete: t[o + 2] }, Ff(e._query) } return function (e, t, n, r) { const s = new cd(r), i = new vh(t, s, n); return e.asyncQueue.enqueueAndForget(async () => fh(await _d(e), i)), () => { s.mu(), e.asyncQueue.enqueueAndForget(async () => ph(await _d(e), i)) } }(Hd(l), u, a, c) } function np(e, t) { return function (e, t) { const n = new Wr; return e.asyncQueue.enqueueAndForget(async () => async function (e, t, n) { const r = nd(e); try { const e = await function (e, t) { const n = zr(e), r = cs.now(), s = t.reduce((e, t) => e.add(t.key), Uo()); let i; return n.persistence.runTransaction("Locally write mutations", "readwrite", e => n.ui.Us(e, s).next(s => { i = s; const o = []; for (const e of t) { const t = ho(e, i.get(e.key)); null != t && o.push(new go(e.key, t, Qs(t.value.mapValue), oo.exists(!0))) } return n.Fs.addMutationBatch(e, r, o, t) })).then(e => (e.applyToLocalDocumentSet(i), { batchId: e.batchId, changes: i })) }(r.localStore, t); r.sharedClientState.addPendingMutation(e.batchId), function (e, t, n) { let r = e.su[e.currentUser.toKey()]; r || (r = new Ao(is)), r = r.insert(t, n), e.su[e.currentUser.toKey()] = r }(r, e.batchId, n), await zh(r, e.changes), await Wu(r.remoteStore) } catch (e) { const t = ah(e, "Failed to persist write"); n.reject(t) } }(await bd(e), t, n)), n.promise }(Hd(e), t) } function rp(e, t, n) { const r = n.docs.get(t._key), s = new Qf(e); return new Df(e, s, t._key, r, new xf(n.hasPendingWrites, n.fromCache), t.converter) } class sp extends class { constructor(e, t) { this._firestore = e, this._transaction = t, this._dataReader = of(e) } get(e) { const t = Zf(e, this._firestore), n = new Kf(this._firestore); return this._transaction.lookup([t._key]).then(e => { if (!e || 1 !== e.length) return jr(); const r = e[0]; if (r.isFoundDocument()) return new If(this._firestore, n, r.key, r, t.converter); if (r.isNoDocument()) return new If(this._firestore, n, t._key, null, t.converter); throw jr() }) } set(e, t, n) { const r = Zf(e, this._firestore), s = Yf(r.converter, t, n), i = af(this._dataReader, "Transaction.set", r._key, s, null !== r.converter, n); return this._transaction.set(r._key, i), this } update(e, t, n, ...r) { const s = Zf(e, this._firestore); let i; return i = "string" == typeof (t = (0, T.m9)(t)) || t instanceof Kd ? mf(this._dataReader, "Transaction.update", s._key, t, n, r) : pf(this._dataReader, "Transaction.update", s._key, t), this._transaction.update(s._key, i), this } delete(e) { const t = Zf(e, this._firestore); return this._transaction.delete(t._key), this } }{ constructor(e, t) { super(e, t), this._firestore = e } get(e) { const t = Zf(e, this._firestore), n = new Qf(this._firestore); return super.get(e).then(e => new Df(this._firestore, n, t._key, e._document, new xf(!1, !1), t.converter)) } } function ip(e, t) { if (void 0 === t) return { merge: !1 }; if (void 0 !== t.mergeFields && void 0 !== t.merge) throw new Gr("invalid-argument", `Invalid options passed to function ${e}(): You cannot specify both "merge" and "mergeFields".`); return t } function op() { if ("undefined" == typeof Uint8Array) throw new Gr("unimplemented", "Uint8Arrays are not available in this environment.") } function ap() { if ("undefined" == typeof atob) throw new Gr("unimplemented", "Blobs are unavailable in Firestore in this environment.") } !function (e, t = !0) { !function (e) { Fr = e }(E.SDK_VERSION), (0, E._registerComponent)(new C.wA("firestore", (e, { options: n }) => { const r = e.getProvider("app").getImmediate(), s = new zd(r, new Zr(e.getProvider("auth-internal")), new ts(e.getProvider("app-check-internal"))); return n = Object.assign({ useFetchStreams: t }, n), s._setSettings(n), s }, "PUBLIC")), (0, E.registerVersion)(Nr, "3.4.6", e), (0, E.registerVersion)(Nr, "3.4.6", "esm2017") }(); class cp { constructor(e) { this._delegate = e } static fromBase64String(e) { return ap(), new cp(Xd.fromBase64String(e)) } static fromUint8Array(e) { return op(), new cp(Xd.fromUint8Array(e)) } toBase64() { return ap(), this._delegate.toBase64() } toUint8Array() { return op(), this._delegate.toUint8Array() } isEqual(e) { return this._delegate.isEqual(e._delegate) } toString() { return "Blob(base64: " + this.toBase64() + ")" } } function lp(e) { return function (e, t) { if ("object" != typeof e || null === e) return !1; const n = e; for (const r of ["next", "error", "complete"]) if (r in n && "function" == typeof n[r]) return !0; return !1 }(e) } class up { enableIndexedDbPersistence(e, t) { return function (e, t) { Yd(e = Dd(e, zd)); const n = Hd(e), r = e._freezeSettings(), s = new od; return Wd(n, s, new sd(s, r.cacheSizeBytes, null == t ? void 0 : t.forceOwnership)) }(e._delegate, { forceOwnership: t }) } enableMultiTabIndexedDbPersistence(e) { return function (e) { Yd(e = Dd(e, zd)); const t = Hd(e), n = e._freezeSettings(), r = new od; return Wd(t, r, new id(r, n.cacheSizeBytes)) }(e._delegate) } clearIndexedDbPersistence(e) { return function (e) { if (e._initialized && !e._terminated) throw new Gr(Hr.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated."); const t = new Wr; return e._queue.enqueueAndForgetEvenWhileRestricted(async () => { try { await async function (e) { if (!rc.vt()) return Promise.resolve(); const t = e + "main"; await rc.delete(t) }(Nl(e._databaseId, e._persistenceKey)), t.resolve() } catch (e) { t.reject(e) } }), t.promise }(e._delegate) } } class hp { constructor(e, t, n) { this._delegate = t, this._persistenceProvider = n, this.INTERNAL = { delete: () => this.terminate() }, e instanceof ks || (this._appCompat = e) } get _databaseId() { return this._delegate._databaseId } settings(e) { const t = this._delegate._getSettings(); e.merge || t.host === e.host || Vr("You are overriding the original host. If you did not intend to override your settings, use {merge: true}."), e.merge && delete (e = Object.assign(Object.assign({}, t), e)).merge, this._delegate._setSettings(e) } useEmulator(e, t, n = {}) { !function (e, t, n, r = {}) { var s; const i = (e = Dd(e, Nd))._getSettings(); if ("firestore.googleapis.com" !== i.host && i.host !== t && Vr("Host has been set in both settings() and useEmulator(), emulator host will be used"), e._setSettings(Object.assign(Object.assign({}, i), { host: `${t}:${n}`, ssl: !1 })), r.mockUserToken) { let t, n; if ("string" == typeof r.mockUserToken) t = r.mockUserToken, n = Pr.MOCK_USER; else { t = (0, T.Sg)(r.mockUserToken, null === (s = e._app) || void 0 === s ? void 0 : s.options.projectId); const i = r.mockUserToken.sub || r.mockUserToken.user_id; if (!i) throw new Gr(Hr.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); n = new Pr(i) } e._authCredentials = new Xr(new Yr(t, n)) } }(this._delegate, e, t, n) } enableNetwork() { return function (e) { return function (e) { return e.asyncQueue.enqueue(async () => { const t = await yd(e), n = await wd(e); return t.setNetworkEnabled(!0), function (e) { const t = zr(e); return t.ha.delete(0), Ru(t) }(n) }) }(Hd(e = Dd(e, zd))) }(this._delegate) } disableNetwork() { return function (e) { return function (e) { return e.asyncQueue.enqueue(async () => { const t = await yd(e), n = await wd(e); return t.setNetworkEnabled(!1), async function (e) { const t = zr(e); t.ha.add(0), await Nu(t), t.da.set("Offline") }(n) }) }(Hd(e = Dd(e, zd))) }(this._delegate) } enablePersistence(e) { let t = !1, n = !1; return e && (t = !!e.synchronizeTabs, n = !!e.experimentalForceOwningTab, Id("synchronizeTabs", t, "experimentalForceOwningTab", n)), t ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, n) } clearPersistence() { return this._persistenceProvider.clearIndexedDbPersistence(this) } terminate() { return this._appCompat && (this._appCompat._removeServiceInstance("firestore-compat"), this._appCompat._removeServiceInstance("firestore")), this._delegate._delete() } waitForPendingWrites() { return function (e) { return function (e) { const t = new Wr; return e.asyncQueue.enqueueAndForget(async () => async function (e, t) { const n = zr(e); Vu(n.remoteStore) || $r("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled."); try { const e = await function (e) { const t = zr(e); return t.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", e => t.Fs.getHighestUnacknowledgedBatchId(e)) }(n.localStore); if (-1 === e) return void t.resolve(); const r = n.iu.get(e) || []; r.push(t), n.iu.set(e, r) } catch (e) { const n = ah(e, "Initialization of waitForPendingWrites() operation failed"); t.reject(n) } }(await bd(e), t)), t.promise }(Hd(e = Dd(e, zd))) }(this._delegate) } onSnapshotsInSync(e) { return function (e, t) { return function (e, t) { const n = new cd(t); return e.asyncQueue.enqueueAndForget(async () => function (e, t) { zr(e).Ia.add(t), t.next() }(await _d(e), n)), () => { n.mu(), e.asyncQueue.enqueueAndForget(async () => function (e, t) { zr(e).Ia.delete(t) }(await _d(e), n)) } }(Hd(e = Dd(e, zd)), jd(t) ? t : { next: t }) }(this._delegate, e) } get app() { if (!this._appCompat) throw new Gr("failed-precondition", "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._appCompat } collection(e) { try { return new Tp(this, Md(this._delegate, e)) } catch (t) { throw yp(t, "collection()", "Firestore.collection()") } } doc(e) { try { return new gp(this, $d(this._delegate, e)) } catch (t) { throw yp(t, "doc()", "Firestore.doc()") } } collectionGroup(e) { try { return new Ep(this, function (e, t) { if (e = Dd(e, Nd), Td("collectionGroup", "collection id", t), t.indexOf("/") >= 0) throw new Gr(Hr.INVALID_ARGUMENT, `Invalid collection ID '${t}' passed to function collectionGroup(). Collection IDs must not contain '/'.`); return new Fd(e, null, function (e) { return new Ii(ps.emptyPath(), e) }(t)) }(this._delegate, e)) } catch (t) { throw yp(t, "collectionGroup()", "Firestore.collectionGroup()") } } runTransaction(e) { return function (e, t) { return function (e, t) { const n = new Wr; return e.asyncQueue.enqueueAndForget(async () => { const r = await function (e) { return gd(e).then(e => e.datastore) }(e); new hd(e.asyncQueue, r, t, n).run() }), n.promise }(Hd(e = Dd(e, zd)), n => t(new sp(e, n))) }(this._delegate, t => e(new fp(this, t))) } batch() { return Hd(this._delegate), new pp(new Xf(this._delegate, e => np(this._delegate, e))) } loadBundle(e) { return function (e, t) { const n = Hd(e = Dd(e, zd)), r = new qd; return function (e, t, n, r) { const s = function (e, t) { let n; return n = "string" == typeof e ? (new TextEncoder).encode(e) : e, function (e, t) { return new ld(e, t) }(function (e, t) { if (e instanceof Uint8Array) return ad(e, t); if (e instanceof ArrayBuffer) return ad(new Uint8Array(e), t); if (e instanceof ReadableStream) return e.getReader(); throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream") }(n), t) }(n, Su(t)); e.asyncQueue.enqueueAndForget(async () => { !function (e, t, n) { const r = zr(e); (async function (e, t, n) { try { const r = await t.getMetadata(); if (await function (e, t) { const n = zr(e), r = ia(t.createTime); return n.persistence.runTransaction("hasNewerBundle", "readonly", e => n.fs.getBundleMetadata(e, t.id)).then(e => !!e && e.createTime.compareTo(r) >= 0) }(e.localStore, r)) return await t.close(), void n._completeWith(function (e) { return { taskState: "Success", documentsLoaded: e.totalDocuments, bytesLoaded: e.totalBytes, totalDocuments: e.totalDocuments, totalBytes: e.totalBytes } }(r)); n._updateProgress(Eh(r)); const s = new _h(r, e.localStore, t.M); let i = await t.cu(); for (; i;) { const e = await s.xa(i); e && n._updateProgress(e), i = await t.cu() } const o = await s.complete(); await zh(e, o.$s, void 0), await function (e, t) { const n = zr(e); return n.persistence.runTransaction("Save bundle", "readwrite", e => n.fs.saveBundleMetadata(e, t)) }(e.localStore, r), n._completeWith(o.progress) } catch (e) { Vr("SyncEngine", `Loading bundle failed with ${e}`), n._failWith(e) } })(r, t, n).then(() => { r.sharedClientState.notifyBundleLoaded() }) }(await bd(e), s, r) }) }(n, e._databaseId, t, r), r }(this._delegate, e) } namedQuery(e) { return function (e, t) { return function (e, t) { return e.asyncQueue.enqueue(async () => function (e, t) { const n = zr(e); return n.persistence.runTransaction("Get named query", "readonly", e => n.fs.getNamedQuery(e, t)) }(await vd(e), t)) }(Hd(e = Dd(e, zd)), t).then(t => t ? new Fd(e, null, t.query) : null) }(this._delegate, e).then(e => e ? new Ep(this, e) : null) } } class dp extends Wf { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new cp(new Xd(e)) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return gp.forKey(t, this.firestore, null) } } class fp { constructor(e, t) { this._firestore = e, this._delegate = t, this._userDataWriter = new dp(e) } get(e) { const t = Ip(e); return this._delegate.get(t).then(e => new bp(this._firestore, new Df(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, t.converter))) } set(e, t, n) { const r = Ip(e); return n ? (ip("Transaction.set", n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this } update(e, t, n, ...r) { const s = Ip(e); return 2 === arguments.length ? this._delegate.update(s, t) : this._delegate.update(s, t, n, ...r), this } delete(e) { const t = Ip(e); return this._delegate.delete(t), this } } class pp { constructor(e) { this._delegate = e } set(e, t, n) { const r = Ip(e); return n ? (ip("WriteBatch.set", n), this._delegate.set(r, t, n)) : this._delegate.set(r, t), this } update(e, t, n, ...r) { const s = Ip(e); return 2 === arguments.length ? this._delegate.update(s, t) : this._delegate.update(s, t, n, ...r), this } delete(e) { const t = Ip(e); return this._delegate.delete(t), this } commit() { return this._delegate.commit() } } class mp { constructor(e, t, n) { this._firestore = e, this._userDataWriter = t, this._delegate = n } fromFirestore(e, t) { const n = new Of(this._firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, null); return this._delegate.fromFirestore(new _p(this._firestore, n), null != t ? t : {}) } toFirestore(e, t) { return t ? this._delegate.toFirestore(e, t) : this._delegate.toFirestore(e) } static getInstance(e, t) { const n = mp.INSTANCES; let r = n.get(e); r || (r = new WeakMap, n.set(e, r)); let s = r.get(t); return s || (s = new mp(e, new dp(e), t), r.set(t, s)), s } } mp.INSTANCES = new WeakMap; class gp { constructor(e, t) { this.firestore = e, this._delegate = t, this._userDataWriter = new dp(e) } static forPath(e, t, n) { if (e.length % 2 != 0) throw new Gr("invalid-argument", `Invalid document reference. Document references must have an even number of segments, but ${e.canonicalString()} has ${e.length}`); return new gp(t, new Pd(t._delegate, n, new Os(e))) } static forKey(e, t, n) { return new gp(t, new Pd(t._delegate, n, e)) } get id() { return this._delegate.id } get parent() { return new Tp(this.firestore, this._delegate.parent) } get path() { return this._delegate.path } collection(e) { try { return new Tp(this.firestore, Md(this._delegate, e)) } catch (t) { throw yp(t, "collection()", "DocumentReference.collection()") } } isEqual(e) { return (e = (0, T.m9)(e)) instanceof Pd && Bd(this._delegate, e) } set(e, t) { t = ip("DocumentReference.set", t); try { return t ? Jf(this._delegate, e, t) : Jf(this._delegate, e) } catch (n) { throw yp(n, "setDoc()", "DocumentReference.set()") } } update(e, t, ...n) { try { return 1 === arguments.length ? ep(this._delegate, e) : ep(this._delegate, e, t, ...n) } catch (r) { throw yp(r, "updateDoc()", "DocumentReference.update()") } } delete() { return function (e) { return np(Dd(e.firestore, zd), [new bo(e._key, oo.none())]) }(this._delegate) } onSnapshot(...e) { const t = vp(e), n = wp(e, e => new bp(this.firestore, new Df(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter))); return tp(this._delegate, t, n) } get(e) { let t; return t = "cache" === (null == e ? void 0 : e.source) ? function (e) { e = Dd(e, Pd); const t = Dd(e.firestore, zd), n = Hd(t), r = new Qf(t); return function (e, t) { const n = new Wr; return e.asyncQueue.enqueueAndForget(async () => async function (e, t, n) { try { const r = await function (e, t) { const n = zr(e); return n.persistence.runTransaction("read document", "readonly", e => n.ui.Bs(e, t)) }(e, t); r.isFoundDocument() ? n.resolve(r) : r.isNoDocument() ? n.resolve(null) : n.reject(new Gr(Hr.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)")) } catch (e) { const r = ah(e, `Failed to get document '${t} from cache`); n.reject(r) } }(await vd(e), t, n)), n.promise }(n, e._key).then(n => new Df(t, r, e._key, n, new xf(null !== n && n.hasLocalMutations, !0), e.converter)) }(this._delegate) : "server" === (null == e ? void 0 : e.source) ? function (e) { e = Dd(e, Pd); const t = Dd(e.firestore, zd); return Ed(Hd(t), e._key, { source: "server" }).then(n => rp(t, e, n)) }(this._delegate) : function (e) { e = Dd(e, Pd); const t = Dd(e.firestore, zd); return Ed(Hd(t), e._key).then(n => rp(t, e, n)) }(this._delegate), t.then(e => new bp(this.firestore, new Df(this.firestore._delegate, this._userDataWriter, e._key, e._document, e.metadata, this._delegate.converter))) } withConverter(e) { return new gp(this.firestore, this._delegate.withConverter(e ? mp.getInstance(this.firestore, e) : null)) } } function yp(e, t, n) { return e.message = e.message.replace(t, n), e } function vp(e) { for (const t of e) if ("object" == typeof t && !lp(t)) return t; return {} } function wp(e, t) { var n, r; let s; return s = lp(e[0]) ? e[0] : lp(e[1]) ? e[1] : "function" == typeof e[0] ? { next: e[0], error: e[1], complete: e[2] } : { next: e[1], error: e[2], complete: e[3] }, { next: e => { s.next && s.next(t(e)) }, error: null === (n = s.error) || void 0 === n ? void 0 : n.bind(s), complete: null === (r = s.complete) || void 0 === r ? void 0 : r.bind(s) } } class bp { constructor(e, t) { this._firestore = e, this._delegate = t } get ref() { return new gp(this._firestore, this._delegate.ref) } get id() { return this._delegate.id } get metadata() { return this._delegate.metadata } get exists() { return this._delegate.exists() } data(e) { return this._delegate.data(e) } get(e, t) { return this._delegate.get(e, t) } isEqual(e) { return Pf(this._delegate, e._delegate) } } class _p extends bp { data(e) { const t = this._delegate.data(e); return function (e, t) { e || jr() }(void 0 !== t), t } } class Ep { constructor(e, t) { this.firestore = e, this._delegate = t, this._userDataWriter = new dp(e) } where(e, t, n) { try { return new Ep(this.firestore, Mf(this._delegate, function (e, t, n) { const r = t, s = Af("where", e); return new $f(s, r, n) }(e, t, n))) } catch (r) { throw yp(r, /(orderBy|where)\(\)/, "Query.$1()") } } orderBy(e, t) { try { return new Ep(this.firestore, Mf(this._delegate, function (e, t = "asc") { const n = t, r = Af("orderBy", e); return new Bf(r, n) }(e, t))) } catch (n) { throw yp(n, /(orderBy|where)\(\)/, "Query.$1()") } } limit(e) { try { return new Ep(this.firestore, Mf(this._delegate, function (e) { return Od("limit", e), new Vf("limit", e, "F") }(e))) } catch (t) { throw yp(t, "limit()", "Query.limit()") } } limitToLast(e) { try { return new Ep(this.firestore, Mf(this._delegate, function (e) { return Od("limitToLast", e), new Vf("limitToLast", e, "L") }(e))) } catch (t) { throw yp(t, "limitToLast()", "Query.limitToLast()") } } startAt(...e) { try { return new Ep(this.firestore, Mf(this._delegate, function (...e) { return new Uf("startAt", e, !0) }(...e))) } catch (t) { throw yp(t, "startAt()", "Query.startAt()") } } startAfter(...e) { try { return new Ep(this.firestore, Mf(this._delegate, function (...e) { return new Uf("startAfter", e, !1) }(...e))) } catch (t) { throw yp(t, "startAfter()", "Query.startAfter()") } } endBefore(...e) { try { return new Ep(this.firestore, Mf(this._delegate, function (...e) { return new jf("endBefore", e, !1) }(...e))) } catch (t) { throw yp(t, "endBefore()", "Query.endBefore()") } } endAt(...e) { try { return new Ep(this.firestore, Mf(this._delegate, function (...e) { return new jf("endAt", e, !0) }(...e))) } catch (t) { throw yp(t, "endAt()", "Query.endAt()") } } isEqual(e) { return Vd(this._delegate, e._delegate) } get(e) { let t; return t = "cache" === (null == e ? void 0 : e.source) ? function (e) { e = Dd(e, Fd); const t = Dd(e.firestore, zd), n = Hd(t), r = new Qf(t); return function (e, t) { const n = new Wr; return e.asyncQueue.enqueueAndForget(async () => async function (e, t, n) { try { const r = await Gl(e, t, !0), s = new Th(t, r.hi), i = s.La(r.documents), o = s.applyChanges(i, !1); n.resolve(o.snapshot) } catch (e) { const r = ah(e, `Failed to execute query '${t} against cache`); n.reject(r) } }(await vd(e), t, n)), n.promise }(n, e._query).then(n => new Rf(t, r, e, n)) }(this._delegate) : "server" === (null == e ? void 0 : e.source) ? function (e) { e = Dd(e, Fd); const t = Dd(e.firestore, zd), n = Hd(t), r = new Qf(t); return Cd(n, e._query, { source: "server" }).then(n => new Rf(t, r, e, n)) }(this._delegate) : function (e) { e = Dd(e, Fd); const t = Dd(e.firestore, zd), n = Hd(t), r = new Qf(t); return Ff(e._query), Cd(n, e._query).then(n => new Rf(t, r, e, n)) }(this._delegate), t.then(e => new Sp(this.firestore, new Rf(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot))) } onSnapshot(...e) { const t = vp(e), n = wp(e, e => new Sp(this.firestore, new Rf(this.firestore._delegate, this._userDataWriter, this._delegate, e._snapshot))); return tp(this._delegate, t, n) } withConverter(e) { return new Ep(this.firestore, this._delegate.withConverter(e ? mp.getInstance(this.firestore, e) : null)) } } class Cp { constructor(e, t) { this._firestore = e, this._delegate = t } get type() { return this._delegate.type } get doc() { return new _p(this._firestore, this._delegate.doc) } get oldIndex() { return this._delegate.oldIndex } get newIndex() { return this._delegate.newIndex } } class Sp { constructor(e, t) { this._firestore = e, this._delegate = t } get query() { return new Ep(this._firestore, this._delegate.query) } get metadata() { return this._delegate.metadata } get size() { return this._delegate.size } get empty() { return this._delegate.empty } get docs() { return this._delegate.docs.map(e => new _p(this._firestore, e)) } docChanges(e) { return this._delegate.docChanges(e).map(e => new Cp(this._firestore, e)) } forEach(e, t) { this._delegate.forEach(n => { e.call(t, new _p(this._firestore, n)) }) } isEqual(e) { return Pf(this._delegate, e._delegate) } } class Tp extends Ep { constructor(e, t) { super(e, t), this.firestore = e, this._delegate = t } get id() { return this._delegate.id } get path() { return this._delegate.path } get parent() { const e = this._delegate.parent; return e ? new gp(this.firestore, e) : null } doc(e) { try { return new gp(this.firestore, void 0 === e ? $d(this._delegate) : $d(this._delegate, e)) } catch (t) { throw yp(t, "doc()", "CollectionReference.doc()") } } add(e) { return function (e, t) { const n = Dd(e.firestore, zd), r = $d(e), s = Yf(e.converter, t); return np(n, [af(of(e.firestore), "addDoc", r._key, s, null !== e.converter, {}).toMutation(r._key, oo.exists(!1))]).then(() => r) }(this._delegate, e).then(e => new gp(this.firestore, e)) } isEqual(e) { return Bd(this._delegate, e._delegate) } withConverter(e) { return new Tp(this.firestore, this._delegate.withConverter(e ? mp.getInstance(this.firestore, e) : null)) } } function Ip(e) { return Dd(e, Pd) } class kp { constructor(...e) { this._delegate = new Kd(...e) } static documentId() { return new kp(gs.keyField().canonicalString()) } isEqual(e) { return (e = (0, T.m9)(e)) instanceof Kd && this._delegate._internalPath.isEqual(e._internalPath) } } class Ap { constructor(e) { this._delegate = e } static serverTimestamp() { const e = new uf("serverTimestamp"); return e._methodName = "FieldValue.serverTimestamp", new Ap(e) } static delete() { const e = new cf("deleteField"); return e._methodName = "FieldValue.delete", new Ap(e) } static arrayUnion(...e) { const t = function (...e) { return new hf("arrayUnion", e) }(...e); return t._methodName = "FieldValue.arrayUnion", new Ap(t) } static arrayRemove(...e) { const t = function (...e) { return new df("arrayRemove", e) }(...e); return t._methodName = "FieldValue.arrayRemove", new Ap(t) } static increment(e) { const t = function (e) { return new ff("increment", e) }(e); return t._methodName = "FieldValue.increment", new Ap(t) } isEqual(e) { return this._delegate.isEqual(e._delegate) } } const xp = { Firestore: hp, GeoPoint: Qd, Timestamp: cs, Blob: cp, Transaction: fp, WriteBatch: pp, DocumentReference: gp, DocumentSnapshot: bp, Query: Ep, QueryDocumentSnapshot: _p, QuerySnapshot: Sp, CollectionReference: Tp, FieldPath: kp, FieldValue: Ap, setLogLevel: function (e) { !function (e) { Lr.setLogLevel(e) }(e) }, CACHE_SIZE_UNLIMITED: -1 }; var Dp; (Dp = _.Z).INTERNAL.registerComponent(new C.wA("firestore-compat", e => { return t = e.getProvider("app-compat").getImmediate(), n = e.getProvider("firestore").getImmediate(), new hp(t, n, new up); var t, n }, "PUBLIC").setServiceProps(Object.assign({}, xp))), Dp.registerVersion("@firebase/firestore-compat", "0.1.15"); var Op = n(8006), Rp = n(5355), Np = n(7841); function Pp(e, t) { return function (e, t = s.z) { return new i.y(n => { let r; return null != t ? t.schedule(() => { r = e.onSnapshot({ includeMetadataChanges: !0 }, n) }) : r = e.onSnapshot({ includeMetadataChanges: !0 }, n), () => { null != r && r() } }) }(e, t) } function Fp(e, t) { return Pp(e, t).pipe((0, m.U)(e => ({ payload: e, type: "query" }))) } function Lp(e, t) { return Fp(e, t).pipe((0, p.O)(void 0), u(), (0, m.U)(([e, t]) => { const n = t.payload.docChanges(), r = n.map(e => ({ type: e.type, payload: e })); return e && JSON.stringify(e.payload.metadata) !== JSON.stringify(t.payload.metadata) && t.payload.docs.forEach((t, s) => { const i = n.find(e => e.doc.ref.isEqual(t.ref)), o = null == e ? void 0 : e.payload.docs.find(e => e.ref.isEqual(t.ref)); i && JSON.stringify(i.doc.metadata) === JSON.stringify(t.metadata) || !i && o && JSON.stringify(o.metadata) === JSON.stringify(t.metadata) || r.push({ type: "modified", payload: { oldIndex: s, newIndex: s, type: "modified", doc: t } }) }), r })) } function Mp(e, t, n) { return Lp(e, n).pipe((0, g.R)((e, n) => function (e, t, n) { return t.forEach(t => { n.indexOf(t.type) > -1 && (e = function (e, t) { switch (t.type) { case "added": if (!e[t.newIndex] || !e[t.newIndex].doc.ref.isEqual(t.doc.ref)) return $p(e, t.newIndex, 0, t); break; case "modified": if (null == e[t.oldIndex] || e[t.oldIndex].doc.ref.isEqual(t.doc.ref)) { if (t.oldIndex !== t.newIndex) { const n = e.slice(); return n.splice(t.oldIndex, 1), n.splice(t.newIndex, 0, t), n } return $p(e, t.newIndex, 1, t) } break; case "removed": if (e[t.oldIndex] && e[t.oldIndex].doc.ref.isEqual(t.doc.ref)) return $p(e, t.oldIndex, 1) }return e }(e, t)) }), e }(e, n.map(e => e.payload), t), []), (0, y.x)(), (0, m.U)(e => e.map(e => ({ type: e.type, payload: e })))) } function $p(e, t, n, ...r) { const s = e.slice(); return s.splice(t, n, ...r), s } function Bp(e) { return e && 0 !== e.length || (e = ["added", "removed", "modified"]), e } class Vp { constructor(e, t, n) { this.ref = e, this.query = t, this.afs = n } stateChanges(e) { let t = Lp(this.query, this.afs.schedulers.outsideAngular); return e && e.length > 0 && (t = t.pipe((0, m.U)(t => t.filter(t => e.indexOf(t.type) > -1)))), t.pipe((0, p.O)(void 0), u(), (0, v.h)(([e, t]) => t.length > 0 || !e), (0, m.U)(([e, t]) => t), c.iC) } auditTrail(e) { return this.stateChanges(e).pipe((0, g.R)((e, t) => [...e, ...t], [])) } snapshotChanges(e) { const t = Bp(e); return Mp(this.query, t, this.afs.schedulers.outsideAngular).pipe(c.iC) } valueChanges(e = {}) { return Fp(this.query, this.afs.schedulers.outsideAngular).pipe((0, m.U)(t => t.payload.docs.map(t => e.idField ? Object.assign(Object.assign({}, t.data()), { [e.idField]: t.id }) : t.data())), c.iC) } get(e) { return (0, o.D)(this.query.get(e)).pipe(c.iC) } add(e) { return this.ref.add(e) } doc(e) { return new Up(this.ref.doc(e), this.afs) } } class Up { constructor(e, t) { this.ref = e, this.afs = t } set(e, t) { return this.ref.set(e, t) } update(e) { return this.ref.update(e) } delete() { return this.ref.delete() } collection(e, t) { const n = this.ref.collection(e), { ref: r, query: s } = Wp(n, t); return new Vp(r, s, this.afs) } snapshotChanges() { return Pp(this.ref, this.afs.schedulers.outsideAngular).pipe((0, p.O)(void 0), u(), (0, m.U)(([e, t]) => t.exists ? (null == e ? void 0 : e.exists) ? { payload: t, type: "modified" } : { payload: t, type: "added" } : { payload: t, type: "removed" })).pipe(c.iC) } valueChanges(e = {}) { return this.snapshotChanges().pipe((0, m.U)(({ payload: t }) => e.idField ? Object.assign(Object.assign({}, t.data()), { [e.idField]: t.id }) : t.data())) } get(e) { return (0, o.D)(this.ref.get(e)).pipe(c.iC) } } class jp { constructor(e, t) { this.query = e, this.afs = t } stateChanges(e) { return e && 0 !== e.length ? Lp(this.query, this.afs.schedulers.outsideAngular).pipe((0, m.U)(t => t.filter(t => e.indexOf(t.type) > -1)), (0, v.h)(e => e.length > 0), c.iC) : Lp(this.query, this.afs.schedulers.outsideAngular).pipe(c.iC) } auditTrail(e) { return this.stateChanges(e).pipe((0, g.R)((e, t) => [...e, ...t], [])) } snapshotChanges(e) { const t = Bp(e); return Mp(this.query, t, this.afs.schedulers.outsideAngular).pipe(c.iC) } valueChanges(e = {}) { return Fp(this.query, this.afs.schedulers.outsideAngular).pipe((0, m.U)(t => t.payload.docs.map(t => e.idField ? Object.assign({ [e.idField]: t.id }, t.data()) : t.data())), c.iC) } get(e) { return (0, o.D)(this.query.get(e)).pipe(c.iC) } } const qp = new r.OlP("angularfire2.enableFirestorePersistence"), zp = new r.OlP("angularfire2.firestore.persistenceSettings"), Hp = new r.OlP("angularfire2.firestore.settings"), Gp = new r.OlP("angularfire2.firestore.use-emulator"); function Wp(e, t = (e => e)) { return { query: t(e), ref: e } } let Yp = (() => { class e { constructor(e, t, n, r, s, i, c, l, u, h, d, f, p, m, g, y, v) { this.schedulers = c; const _ = (0, w.on)(e, i, t), E = u; h && (0, Op.nw)(_, i, d, p, m, g, f, y), [this.firestore, this.persistenceEnabled$] = (0, w.cc)(`${_.name}.firestore`, "AngularFirestore", _.name, () => { const e = i.runOutsideAngular(() => _.firestore()); if (r && e.settings(r), E && e.useEmulator(...E), n && !(0, b.PM)(s)) { const t = () => { try { return (0, o.D)(e.enablePersistence(l || void 0).then(() => !0, () => !1)) } catch (t) { return "undefined" != typeof console && console.warn(t), (0, a.of)(!1) } }; return [e, i.runOutsideAngular(t)] } return [e, (0, a.of)(!1)] }, [r, E, n]) } collection(e, t) { let n; n = "string" == typeof e ? this.firestore.collection(e) : e; const { ref: r, query: s } = Wp(n, t), i = this.schedulers.ngZone.run(() => r); return new Vp(i, s, this) } collectionGroup(e, t) { const n = t || (e => e), r = this.firestore.collectionGroup(e); return new jp(n(r), this) } doc(e) { let t; t = "string" == typeof e ? this.firestore.doc(e) : e; const n = this.schedulers.ngZone.run(() => t); return new Up(n, this) } createId() { return this.firestore.collection("_").doc().id } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(w.Dh), r.LFG(w.xv, 8), r.LFG(qp, 8), r.LFG(Hp, 8), r.LFG(r.Lbi), r.LFG(r.R0b), r.LFG(c.HU), r.LFG(zp, 8), r.LFG(Gp, 8), r.LFG(Op.zQ, 8), r.LFG(Op.Qv, 8), r.LFG(Op.L6, 8), r.LFG(Op._Q, 8), r.LFG(Op.rT, 8), r.LFG(Op.lh, 8), r.LFG(Op.f7, 8), r.LFG(Rp.nm, 8)) }, e.\u0275prov = r.Yz7({ token: e, factory: e.\u0275fac, providedIn: "any" }), e })(), Kp = (() => { class e { constructor() { Np.Z.registerVersion("angularfire", c.q4.full, "fst-compat") } static enablePersistence(t) { return { ngModule: e, providers: [{ provide: qp, useValue: !0 }, { provide: zp, useValue: t }] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ providers: [Yp] }), e })() }, 8534: (e, t, n) => { "use strict"; n.d(t, { Q1: () => Xe, TE: () => Qe }); var r = n(8891), s = n(5917), i = n(4402), o = n(7393), a = n(3637); class c { constructor(e, t) { this.dueTime = e, this.scheduler = t } call(e, t) { return t.subscribe(new l(e, this.dueTime, this.scheduler)) } } class l extends o.L { constructor(e, t, n) { super(e), this.dueTime = t, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(e) { this.clearDebounce(), this.lastValue = e, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(u, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: e } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(e) } } clearDebounce() { const e = this.debouncedSubscription; null !== e && (this.remove(e), e.unsubscribe(), this.debouncedSubscription = null) } } function u(e) { e.debouncedNext() } var h = n(8002), d = n(3190), f = n(4459), p = n(8720), m = n(8939), g = n(156), y = n(279), v = n(3854), w = n(8604); const b = "firebasestorage.googleapis.com"; class _ extends v.ZR { constructor(e, t) { super(E(e), `Firebase Storage: ${t} (${E(e)})`), this.customData = { serverResponse: null }, this._baseMessage = this.message, Object.setPrototypeOf(this, _.prototype) } _codeEquals(e) { return E(e) === this.code } get serverResponse() { return this.customData.serverResponse } set serverResponse(e) { this.customData.serverResponse = e, this.message = this.customData.serverResponse ? `${this._baseMessage}\n${this.customData.serverResponse}` : this._baseMessage } } function E(e) { return "storage/" + e } function C() { return new _("unknown", "An unknown error occurred, please check the error payload for server response.") } function S() { return new _("canceled", "User canceled the upload/download.") } function T() { return new _("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.") } function I(e) { return new _("invalid-argument", e) } function k() { return new _("app-deleted", "The Firebase app was deleted.") } function A(e) { return new _("invalid-root-operation", "The operation '" + e + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').") } function x(e, t) { return new _("invalid-format", "String does not match format '" + e + "': " + t) } function D(e) { throw new _("internal-error", "Internal error: " + e) } class O { constructor(e, t) { this.bucket = e, this.path_ = t } get path() { return this.path_ } get isRoot() { return 0 === this.path.length } fullServerUrl() { const e = encodeURIComponent; return "/b/" + e(this.bucket) + "/o/" + e(this.path) } bucketOnlyServerUrl() { return "/b/" + encodeURIComponent(this.bucket) + "/o" } static makeFromBucketSpec(e, t) { let n; try { n = O.makeFromUrl(e, t) } catch (r) { return new O(e, "") } if ("" === n.path) return n; throw new _("invalid-default-bucket", "Invalid default bucket '" + e + "'.") } static makeFromUrl(e, t) { let n = null; const r = "([A-Za-z0-9.\\-_]+)", s = new RegExp("^gs://" + r + "(/(.*))?$", "i"); function i(e) { e.path_ = decodeURIComponent(e.path) } const o = t.replace(/[.]/g, "\\."), a = [{ regex: s, indices: { bucket: 1, path: 3 }, postModify: function (e) { "/" === e.path.charAt(e.path.length - 1) && (e.path_ = e.path_.slice(0, -1)) } }, { regex: new RegExp(`^https?://${o}/v[A-Za-z0-9_]+/b/${r}/o(/([^?#]*).*)?$`, "i"), indices: { bucket: 1, path: 3 }, postModify: i }, { regex: new RegExp(`^https?://${t === b ? "(?:storage.googleapis.com|storage.cloud.google.com)" : t}/${r}/([^?#]*)`, "i"), indices: { bucket: 1, path: 2 }, postModify: i }]; for (let c = 0; c < a.length; c++) { const t = a[c], r = t.regex.exec(e); if (r) { let e = r[t.indices.path]; e || (e = ""), n = new O(r[t.indices.bucket], e), t.postModify(n); break } } if (null == n) throw function (e) { return new _("invalid-url", "Invalid URL '" + e + "'.") }(e); return n } } class R { constructor(e) { this.promise_ = Promise.reject(e) } getPromise() { return this.promise_ } cancel(e = !1) { } } function N(e) { return "string" == typeof e || e instanceof String } function P(e) { return F() && e instanceof Blob } function F() { return "undefined" != typeof Blob } function L(e, t, n, r) { if (r < t) throw I(`Invalid value for '${e}'. Expected ${t} or greater.`); if (r > n) throw I(`Invalid value for '${e}'. Expected ${n} or less.`) } function M(e, t, n) { let r = t; return null == n && (r = `https://${t}`), `${n}://${r}/v0${e}` } function $(e) { const t = encodeURIComponent; let n = "?"; for (const r in e) e.hasOwnProperty(r) && (n = n + (t(r) + "=") + t(e[r]) + "&"); return n = n.slice(0, -1), n } var B = (() => (function (e) { e[e.NO_ERROR = 0] = "NO_ERROR", e[e.NETWORK_ERROR = 1] = "NETWORK_ERROR", e[e.ABORT = 2] = "ABORT" }(B || (B = {})), B))(); class V { constructor(e, t, n, r, s, i, o, a, c, l, u) { this.url_ = e, this.method_ = t, this.headers_ = n, this.body_ = r, this.successCodes_ = s, this.additionalRetryCodes_ = i, this.callback_ = o, this.errorCallback_ = a, this.timeout_ = c, this.progressCallback_ = l, this.connectionFactory_ = u, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = !1, this.appDelete_ = !1, this.promise_ = new Promise((e, t) => { this.resolve_ = e, this.reject_ = t, this.start_() }) } start_() { const e = (e, t) => { const n = this.resolve_, r = this.reject_, s = t.connection; if (t.wasSuccessCode) try { const e = this.callback_(s, s.getResponse()); void 0 !== e ? n(e) : n() } catch (i) { r(i) } else if (null !== s) { const e = C(); e.serverResponse = s.getErrorText(), r(this.errorCallback_ ? this.errorCallback_(s, e) : e) } else r(t.canceled ? this.appDelete_ ? k() : S() : new _("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.")) }; this.canceled_ ? e(0, new U(!1, null, !0)) : this.backoffId_ = function (e, t, n) { let r = 1, s = null, i = null, o = !1, a = 0; function c() { return 2 === a } let l = !1; function u(...e) { l || (l = !0, t.apply(null, e)) } function h(t) { s = setTimeout(() => { s = null, e(f, c()) }, t) } function d() { i && clearTimeout(i) } function f(e, ...t) { if (l) return void d(); if (e) return d(), void u.call(null, e, ...t); if (c() || o) return d(), void u.call(null, e, ...t); let n; r < 64 && (r *= 2), 1 === a ? (a = 2, n = 0) : n = 1e3 * (r + Math.random()), h(n) } let p = !1; function m(e) { p || (p = !0, d(), l || (null !== s ? (e || (a = 2), clearTimeout(s), h(0)) : e || (a = 1))) } return h(0), i = setTimeout(() => { o = !0, m(!0) }, n), m }((e, t) => { if (t) return void e(!1, new U(!1, null, !0)); const n = this.connectionFactory_(); this.pendingConnection_ = n; const r = e => { null !== this.progressCallback_ && this.progressCallback_(e.loaded, e.lengthComputable ? e.total : -1) }; null !== this.progressCallback_ && n.addUploadProgressListener(r), n.send(this.url_, this.method_, this.body_, this.headers_).then(() => { null !== this.progressCallback_ && n.removeUploadProgressListener(r), this.pendingConnection_ = null; const t = n.getErrorCode() === B.NO_ERROR, s = n.getStatus(); if (!t || this.isRetryStatusCode_(s)) { const t = n.getErrorCode() === B.ABORT; return void e(!1, new U(!1, null, t)) } const i = -1 !== this.successCodes_.indexOf(s); e(!0, new U(i, n)) }) }, e, this.timeout_) } getPromise() { return this.promise_ } cancel(e) { this.canceled_ = !0, this.appDelete_ = e || !1, null !== this.backoffId_ && (0, this.backoffId_)(!1), null !== this.pendingConnection_ && this.pendingConnection_.abort() } isRetryStatusCode_(e) { const t = e >= 500 && e < 600, n = -1 !== [408, 429].indexOf(e), r = -1 !== this.additionalRetryCodes_.indexOf(e); return t || n || r } } class U { constructor(e, t, n) { this.wasSuccessCode = e, this.connection = t, this.canceled = !!n } } function j() { return "undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof WebKitBlobBuilder ? WebKitBlobBuilder : void 0 } function q(...e) { const t = j(); if (void 0 !== t) { const n = new t; for (let t = 0; t < e.length; t++)n.append(e[t]); return n.getBlob() } if (F()) return new Blob(e); throw new _("unsupported-environment", "This browser doesn't seem to support creating Blobs") } const z = { RAW: "raw", BASE64: "base64", BASE64URL: "base64url", DATA_URL: "data_url" }; class H { constructor(e, t) { this.data = e, this.contentType = t || null } } function G(e, t) { switch (e) { case z.RAW: return new H(W(t)); case z.BASE64: case z.BASE64URL: return new H(Y(e, t)); case z.DATA_URL: return new H(function (e) { const t = new K(e); return t.base64 ? Y(z.BASE64, t.rest) : function (e) { let t; try { t = decodeURIComponent(e) } catch (n) { throw x(z.DATA_URL, "Malformed data URL.") } return W(t) }(t.rest) }(t), new K(t).contentType) }throw C() } function W(e) { const t = []; for (let n = 0; n < e.length; n++) { let r = e.charCodeAt(n); r <= 127 ? t.push(r) : r <= 2047 ? t.push(192 | r >> 6, 128 | 63 & r) : 55296 == (64512 & r) ? n < e.length - 1 && 56320 == (64512 & e.charCodeAt(n + 1)) ? (r = 65536 | (1023 & r) << 10 | 1023 & e.charCodeAt(++n), t.push(240 | r >> 18, 128 | r >> 12 & 63, 128 | r >> 6 & 63, 128 | 63 & r)) : t.push(239, 191, 189) : 56320 == (64512 & r) ? t.push(239, 191, 189) : t.push(224 | r >> 12, 128 | r >> 6 & 63, 128 | 63 & r) } return new Uint8Array(t) } function Y(e, t) { switch (e) { case z.BASE64: { const n = -1 !== t.indexOf("-"), r = -1 !== t.indexOf("_"); if (n || r) throw x(e, "Invalid character '" + (n ? "-" : "_") + "' found: is it base64url encoded?"); break } case z.BASE64URL: { const n = -1 !== t.indexOf("+"), r = -1 !== t.indexOf("/"); if (n || r) throw x(e, "Invalid character '" + (n ? "+" : "/") + "' found: is it base64 encoded?"); t = t.replace(/-/g, "+").replace(/_/g, "/"); break } }let n; try { n = atob(t) } catch (s) { throw x(e, "Invalid character found") } const r = new Uint8Array(n.length); for (let i = 0; i < n.length; i++)r[i] = n.charCodeAt(i); return r } class K { constructor(e) { this.base64 = !1, this.contentType = null; const t = e.match(/^data:([^,]+)?,/); if (null === t) throw x(z.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>"); const n = t[1] || null; var r, s; null != n && (this.base64 = (r = n).length >= (s = ";base64").length && r.substring(r.length - s.length) === s, this.contentType = this.base64 ? n.substring(0, n.length - ";base64".length) : n), this.rest = e.substring(e.indexOf(",") + 1) } } class X { constructor(e, t) { let n = 0, r = ""; P(e) ? (this.data_ = e, n = e.size, r = e.type) : e instanceof ArrayBuffer ? (t ? this.data_ = new Uint8Array(e) : (this.data_ = new Uint8Array(e.byteLength), this.data_.set(new Uint8Array(e))), n = this.data_.length) : e instanceof Uint8Array && (t ? this.data_ = e : (this.data_ = new Uint8Array(e.length), this.data_.set(e)), n = e.length), this.size_ = n, this.type_ = r } size() { return this.size_ } type() { return this.type_ } slice(e, t) { if (P(this.data_)) { const i = (r = e, s = t, (n = this.data_).webkitSlice ? n.webkitSlice(r, s) : n.mozSlice ? n.mozSlice(r, s) : n.slice ? n.slice(r, s) : null); return null === i ? null : new X(i) } var n, r, s; { const n = new Uint8Array(this.data_.buffer, e, t - e); return new X(n, !0) } } static getBlob(...e) { if (F()) { const t = e.map(e => e instanceof X ? e.data_ : e); return new X(q.apply(null, t)) } { const t = e.map(e => N(e) ? G(z.RAW, e).data : e.data_); let n = 0; t.forEach(e => { n += e.byteLength }); const r = new Uint8Array(n); let s = 0; return t.forEach(e => { for (let t = 0; t < e.length; t++)r[s++] = e[t] }), new X(r, !0) } } uploadData() { return this.data_ } } function Z(e) { let t; try { t = JSON.parse(e) } catch (r) { return null } return "object" != typeof (n = t) || Array.isArray(n) ? null : t; var n } function Q(e) { const t = e.lastIndexOf("/", e.length - 2); return -1 === t ? e : e.slice(t + 1) } function J(e, t) { return t } class ee { constructor(e, t, n, r) { this.server = e, this.local = t || e, this.writable = !!n, this.xform = r || J } } let te = null; function ne() { if (te) return te; const e = []; e.push(new ee("bucket")), e.push(new ee("generation")), e.push(new ee("metageneration")), e.push(new ee("name", "fullPath", !0)); const t = new ee("name"); t.xform = function (e, t) { return function (e) { return !N(e) || e.length < 2 ? e : Q(e) }(t) }, e.push(t); const n = new ee("size"); return n.xform = function (e, t) { return void 0 !== t ? Number(t) : t }, e.push(n), e.push(new ee("timeCreated")), e.push(new ee("updated")), e.push(new ee("md5Hash", null, !0)), e.push(new ee("cacheControl", null, !0)), e.push(new ee("contentDisposition", null, !0)), e.push(new ee("contentEncoding", null, !0)), e.push(new ee("contentLanguage", null, !0)), e.push(new ee("contentType", null, !0)), e.push(new ee("metadata", "customMetadata", !0)), te = e, te } function re(e, t, n) { const r = Z(t); return null === r ? null : function (e, t, n) { const r = { type: "file" }, s = n.length; for (let i = 0; i < s; i++) { const e = n[i]; r[e.local] = e.xform(r, t[e.server]) } return function (e, t) { Object.defineProperty(e, "ref", { get: function () { const n = new O(e.bucket, e.fullPath); return t._makeStorageReference(n) } }) }(r, e), r }(e, r, n) } function se(e, t) { const n = {}, r = t.length; for (let s = 0; s < r; s++) { const r = t[s]; r.writable && (n[r.server] = e[r.local]) } return JSON.stringify(n) } class ie { constructor(e, t, n, r) { this.url = e, this.method = t, this.handler = n, this.timeout = r, this.urlParams = {}, this.headers = {}, this.body = null, this.errorHandler = null, this.progressCallback = null, this.successCodes = [200], this.additionalRetryCodes = [] } } function oe(e) { if (!e) throw C() } function ae(e, t) { return function (n, r) { const s = re(e, r, t); return oe(null !== s), s } } function ce(e) { return function (t, n) { let r; return r = 401 === t.getStatus() ? t.getErrorText().includes("Firebase App Check token is invalid") ? new _("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.") : new _("unauthenticated", "User is not authenticated, please authenticate using Firebase Authentication and try again.") : 402 === t.getStatus() ? new _("quota-exceeded", "Quota for bucket '" + e.bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.") : 403 === t.getStatus() ? new _("unauthorized", "User does not have permission to access '" + e.path + "'.") : n, r.serverResponse = n.serverResponse, r } } function le(e) { const t = ce(e); return function (n, r) { let s = t(n, r); return 404 === n.getStatus() && (s = new _("object-not-found", "Object '" + e.path + "' does not exist.")), s.serverResponse = r.serverResponse, s } } function ue(e, t, n) { const r = M(t.fullServerUrl(), e.host, e._protocol), s = e.maxOperationRetryTime, i = new ie(r, "GET", ae(e, n), s); return i.errorHandler = le(t), i } function he(e, t, n) { const r = Object.assign({}, n); return r.fullPath = e.path, r.size = t.size(), r.contentType || (r.contentType = function (e, t) { return t && t.type() || "application/octet-stream" }(0, t)), r } class de { constructor(e, t, n, r) { this.current = e, this.total = t, this.finalized = !!n, this.metadata = r || null } } function fe(e, t) { let n = null; try { n = e.getResponseHeader("X-Goog-Upload-Status") } catch (r) { oe(!1) } return oe(!!n && -1 !== (t || ["active"]).indexOf(n)), n } const pe = 262144, me = { STATE_CHANGED: "state_changed" }, ge = { RUNNING: "running", PAUSED: "paused", SUCCESS: "success", CANCELED: "canceled", ERROR: "error" }; function ye(e) { switch (e) { case "running": case "pausing": case "canceling": return ge.RUNNING; case "paused": return ge.PAUSED; case "success": return ge.SUCCESS; case "canceled": return ge.CANCELED; case "error": default: return ge.ERROR } } class ve { constructor(e, t, n) { if ("function" == typeof e || null != t || null != n) this.next = e, this.error = null != t ? t : void 0, this.complete = null != n ? n : void 0; else { const t = e; this.next = t.next, this.error = t.error, this.complete = t.complete } } } function we(e) { return (...t) => { Promise.resolve().then(() => e(...t)) } } class be extends class { constructor() { this.sent_ = !1, this.xhr_ = new XMLHttpRequest, this.initXhr(), this.errorCode_ = B.NO_ERROR, this.sendPromise_ = new Promise(e => { this.xhr_.addEventListener("abort", () => { this.errorCode_ = B.ABORT, e() }), this.xhr_.addEventListener("error", () => { this.errorCode_ = B.NETWORK_ERROR, e() }), this.xhr_.addEventListener("load", () => { e() }) }) } send(e, t, n, r) { if (this.sent_) throw D("cannot .send() more than once"); if (this.sent_ = !0, this.xhr_.open(t, e, !0), void 0 !== r) for (const s in r) r.hasOwnProperty(s) && this.xhr_.setRequestHeader(s, r[s].toString()); return void 0 !== n ? this.xhr_.send(n) : this.xhr_.send(), this.sendPromise_ } getErrorCode() { if (!this.sent_) throw D("cannot .getErrorCode() before sending"); return this.errorCode_ } getStatus() { if (!this.sent_) throw D("cannot .getStatus() before sending"); try { return this.xhr_.status } catch (e) { return -1 } } getResponse() { if (!this.sent_) throw D("cannot .getResponse() before sending"); return this.xhr_.response } getErrorText() { if (!this.sent_) throw D("cannot .getErrorText() before sending"); return this.xhr_.statusText } abort() { this.xhr_.abort() } getResponseHeader(e) { return this.xhr_.getResponseHeader(e) } addUploadProgressListener(e) { null != this.xhr_.upload && this.xhr_.upload.addEventListener("progress", e) } removeUploadProgressListener(e) { null != this.xhr_.upload && this.xhr_.upload.removeEventListener("progress", e) } }{ initXhr() { this.xhr_.responseType = "text" } } function _e() { return new be } class Ee { constructor(e, t, n = null) { this._transferred = 0, this._needToFetchStatus = !1, this._needToFetchMetadata = !1, this._observers = [], this._error = void 0, this._uploadUrl = void 0, this._request = void 0, this._chunkMultiplier = 1, this._resolve = void 0, this._reject = void 0, this._ref = e, this._blob = t, this._metadata = n, this._mappings = ne(), this._resumable = this._shouldDoResumable(this._blob), this._state = "running", this._errorHandler = e => { this._request = void 0, this._chunkMultiplier = 1, e._codeEquals("canceled") ? (this._needToFetchStatus = !0, this.completeTransitions_()) : (this._error = e, this._transition("error")) }, this._metadataErrorHandler = e => { this._request = void 0, e._codeEquals("canceled") ? this.completeTransitions_() : (this._error = e, this._transition("error")) }, this._promise = new Promise((e, t) => { this._resolve = e, this._reject = t, this._start() }), this._promise.then(null, () => { }) } _makeProgressCallback() { const e = this._transferred; return t => this._updateProgress(e + t) } _shouldDoResumable(e) { return e.size() > 262144 } _start() { "running" === this._state && void 0 === this._request && (this._resumable ? void 0 === this._uploadUrl ? this._createResumable() : this._needToFetchStatus ? this._fetchStatus() : this._needToFetchMetadata ? this._fetchMetadata() : this._continueUpload() : this._oneShotUpload()) } _resolveToken(e) { Promise.all([this._ref.storage._getAuthToken(), this._ref.storage._getAppCheckToken()]).then(([t, n]) => { switch (this._state) { case "running": e(t, n); break; case "canceling": this._transition("canceled"); break; case "pausing": this._transition("paused") } }) } _createResumable() { this._resolveToken((e, t) => { const n = function (e, t, n, r, s) { const i = t.bucketOnlyServerUrl(), o = he(t, r, s), a = { name: o.fullPath }, c = M(i, e.host, e._protocol), l = { "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${r.size()}`, "X-Goog-Upload-Header-Content-Type": o.contentType, "Content-Type": "application/json; charset=utf-8" }, u = se(o, n), h = new ie(c, "POST", function (e) { let t; fe(e); try { t = e.getResponseHeader("X-Goog-Upload-URL") } catch (n) { oe(!1) } return oe(N(t)), t }, e.maxUploadRetryTime); return h.urlParams = a, h.headers = l, h.body = u, h.errorHandler = ce(t), h }(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata), r = this._ref.storage._makeRequest(n, _e, e, t); this._request = r, r.getPromise().then(e => { this._request = void 0, this._uploadUrl = e, this._needToFetchStatus = !1, this.completeTransitions_() }, this._errorHandler) }) } _fetchStatus() { const e = this._uploadUrl; this._resolveToken((t, n) => { const r = function (e, t, n, r) { const s = new ie(n, "POST", function (e) { const t = fe(e, ["active", "final"]); let n = null; try { n = e.getResponseHeader("X-Goog-Upload-Size-Received") } catch (i) { oe(!1) } n || oe(!1); const s = Number(n); return oe(!isNaN(s)), new de(s, r.size(), "final" === t) }, e.maxUploadRetryTime); return s.headers = { "X-Goog-Upload-Command": "query" }, s.errorHandler = ce(t), s }(this._ref.storage, this._ref._location, e, this._blob), s = this._ref.storage._makeRequest(r, _e, t, n); this._request = s, s.getPromise().then(e => { e = e, this._request = void 0, this._updateProgress(e.current), this._needToFetchStatus = !1, e.finalized && (this._needToFetchMetadata = !0), this.completeTransitions_() }, this._errorHandler) }) } _continueUpload() { const e = pe * this._chunkMultiplier, t = new de(this._transferred, this._blob.size()), n = this._uploadUrl; this._resolveToken((r, s) => { let i; try { i = function (e, t, n, r, s, i, o, a) { const c = new de(0, 0); if (o ? (c.current = o.current, c.total = o.total) : (c.current = 0, c.total = r.size()), r.size() !== c.total) throw new _("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload."); const l = c.total - c.current; let u = l; s > 0 && (u = Math.min(u, s)); const h = c.current, d = { "X-Goog-Upload-Command": u === l ? "upload, finalize" : "upload", "X-Goog-Upload-Offset": `${c.current}` }, f = r.slice(h, h + u); if (null === f) throw T(); const p = new ie(n, "POST", function (e, n) { const s = fe(e, ["active", "final"]), o = c.current + u, a = r.size(); let l; return l = "final" === s ? ae(t, i)(e, n) : null, new de(o, a, "final" === s, l) }, t.maxUploadRetryTime); return p.headers = d, p.body = f.uploadData(), p.progressCallback = a || null, p.errorHandler = ce(e), p }(this._ref._location, this._ref.storage, n, this._blob, e, this._mappings, t, this._makeProgressCallback()) } catch (a) { return this._error = a, void this._transition("error") } const o = this._ref.storage._makeRequest(i, _e, r, s); this._request = o, o.getPromise().then(e => { this._increaseMultiplier(), this._request = void 0, this._updateProgress(e.current), e.finalized ? (this._metadata = e.metadata, this._transition("success")) : this.completeTransitions_() }, this._errorHandler) }) } _increaseMultiplier() { pe * this._chunkMultiplier < 33554432 && (this._chunkMultiplier *= 2) } _fetchMetadata() { this._resolveToken((e, t) => { const n = ue(this._ref.storage, this._ref._location, this._mappings), r = this._ref.storage._makeRequest(n, _e, e, t); this._request = r, r.getPromise().then(e => { this._request = void 0, this._metadata = e, this._transition("success") }, this._metadataErrorHandler) }) } _oneShotUpload() { this._resolveToken((e, t) => { const n = function (e, t, n, r, s) { const i = t.bucketOnlyServerUrl(), o = { "X-Goog-Upload-Protocol": "multipart" }, a = function () { let e = ""; for (let t = 0; t < 2; t++)e += Math.random().toString().slice(2); return e }(); o["Content-Type"] = "multipart/related; boundary=" + a; const c = he(t, r, s), l = se(c, n), u = X.getBlob("--" + a + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + l + "\r\n--" + a + "\r\nContent-Type: " + c.contentType + "\r\n\r\n", r, "\r\n--" + a + "--"); if (null === u) throw T(); const h = { name: c.fullPath }, d = M(i, e.host, e._protocol), f = e.maxUploadRetryTime, p = new ie(d, "POST", ae(e, n), f); return p.urlParams = h, p.headers = o, p.body = u.uploadData(), p.errorHandler = ce(t), p }(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata), r = this._ref.storage._makeRequest(n, _e, e, t); this._request = r, r.getPromise().then(e => { this._request = void 0, this._metadata = e, this._updateProgress(this._blob.size()), this._transition("success") }, this._errorHandler) }) } _updateProgress(e) { const t = this._transferred; this._transferred = e, this._transferred !== t && this._notifyObservers() } _transition(e) { if (this._state !== e) switch (e) { case "canceling": case "pausing": this._state = e, void 0 !== this._request && this._request.cancel(); break; case "running": const t = "paused" === this._state; this._state = e, t && (this._notifyObservers(), this._start()); break; case "paused": this._state = e, this._notifyObservers(); break; case "canceled": this._error = S(), this._state = e, this._notifyObservers(); break; case "error": case "success": this._state = e, this._notifyObservers() } } completeTransitions_() { switch (this._state) { case "pausing": this._transition("paused"); break; case "canceling": this._transition("canceled"); break; case "running": this._start() } } get snapshot() { const e = ye(this._state); return { bytesTransferred: this._transferred, totalBytes: this._blob.size(), state: e, metadata: this._metadata, task: this, ref: this._ref } } on(e, t, n, r) { const s = new ve(t || void 0, n || void 0, r || void 0); return this._addObserver(s), () => { this._removeObserver(s) } } then(e, t) { return this._promise.then(e, t) } catch(e) { return this.then(null, e) } _addObserver(e) { this._observers.push(e), this._notifyObserver(e) } _removeObserver(e) { const t = this._observers.indexOf(e); -1 !== t && this._observers.splice(t, 1) } _notifyObservers() { this._finishPromise(), this._observers.slice().forEach(e => { this._notifyObserver(e) }) } _finishPromise() { if (void 0 !== this._resolve) { let e = !0; switch (ye(this._state)) { case ge.SUCCESS: we(this._resolve.bind(null, this.snapshot))(); break; case ge.CANCELED: case ge.ERROR: we(this._reject.bind(null, this._error))(); break; default: e = !1 }e && (this._resolve = void 0, this._reject = void 0) } } _notifyObserver(e) { switch (ye(this._state)) { case ge.RUNNING: case ge.PAUSED: e.next && we(e.next.bind(e, this.snapshot))(); break; case ge.SUCCESS: e.complete && we(e.complete.bind(e))(); break; case ge.CANCELED: case ge.ERROR: e.error && we(e.error.bind(e, this._error))(); break; default: e.error && we(e.error.bind(e, this._error))() } } resume() { const e = "paused" === this._state || "pausing" === this._state; return e && this._transition("running"), e } pause() { const e = "running" === this._state; return e && this._transition("pausing"), e } cancel() { const e = "running" === this._state || "pausing" === this._state; return e && this._transition("canceling"), e } } class Ce { constructor(e, t) { this._service = e, this._location = t instanceof O ? t : O.makeFromUrl(t, e.host) } toString() { return "gs://" + this._location.bucket + "/" + this._location.path } _newRef(e, t) { return new Ce(e, t) } get root() { const e = new O(this._location.bucket, ""); return this._newRef(this._service, e) } get bucket() { return this._location.bucket } get fullPath() { return this._location.path } get name() { return Q(this._location.path) } get storage() { return this._service } get parent() { const e = function (e) { if (0 === e.length) return null; const t = e.lastIndexOf("/"); return -1 === t ? "" : e.slice(0, t) }(this._location.path); if (null === e) return null; const t = new O(this._location.bucket, e); return new Ce(this._service, t) } _throwIfRoot(e) { if ("" === this._location.path) throw A(e) } } function Se(e) { const t = { prefixes: [], items: [] }; return Te(e, t).then(() => t) } async function Te(e, t, n) { const r = { pageToken: n }, s = await Ie(e, r); t.prefixes.push(...s.prefixes), t.items.push(...s.items), null != s.nextPageToken && await Te(e, t, s.nextPageToken) } function Ie(e, t) { null != t && "number" == typeof t.maxResults && L("options.maxResults", 1, 1e3, t.maxResults); const n = t || {}, r = function (e, t, n, r, s) { const i = {}; i.prefix = t.isRoot ? "" : t.path + "/", n && n.length > 0 && (i.delimiter = n), r && (i.pageToken = r), s && (i.maxResults = s); const o = M(t.bucketOnlyServerUrl(), e.host, e._protocol), a = e.maxOperationRetryTime, c = new ie(o, "GET", function (e, t) { return function (n, r) { const s = function (e, t, n) { const r = Z(n); return null === r ? null : function (e, t, n) { const r = { prefixes: [], items: [], nextPageToken: n.nextPageToken }; if (n.prefixes) for (const s of n.prefixes) { const n = s.replace(/\/$/, ""), i = e._makeStorageReference(new O(t, n)); r.prefixes.push(i) } if (n.items) for (const s of n.items) { const n = e._makeStorageReference(new O(t, s.name)); r.items.push(n) } return r }(e, t, r) }(e, t, r); return oe(null !== s), s } }(e, t.bucket), a); return c.urlParams = i, c.errorHandler = ce(t), c }(e.storage, e._location, "/", n.pageToken, n.maxResults); return e.storage.makeRequestWithTokens(r, _e) } function ke(e, t) { const n = function (e, t) { const n = t.split("/").filter(e => e.length > 0).join("/"); return 0 === e.length ? n : e + "/" + n }(e._location.path, t), r = new O(e._location.bucket, n); return new Ce(e.storage, r) } function Ae(e, t) { if (e instanceof Oe) { const n = e; if (null == n._bucket) throw new _("no-default-bucket", "No default bucket found. Did you set the 'storageBucket' property when initializing the app?"); const r = new Ce(n, n._bucket); return null != t ? Ae(r, t) : r } return void 0 !== t ? ke(e, t) : e } function xe(e, t) { if (t && /^[A-Za-z]+:\/\//.test(t)) { if (e instanceof Oe) return new Ce(e, t); throw I("To use ref(service, url), the first argument must be a Storage instance.") } return Ae(e, t) } function De(e, t) { const n = null == t ? void 0 : t.storageBucket; return null == n ? null : O.makeFromBucketSpec(n, e) } class Oe { constructor(e, t, n, r, s) { this.app = e, this._authProvider = t, this._appCheckProvider = n, this._url = r, this._firebaseVersion = s, this._bucket = null, this._host = b, this._protocol = "https", this._appId = null, this._deleted = !1, this._maxOperationRetryTime = 12e4, this._maxUploadRetryTime = 6e5, this._requests = new Set, this._bucket = null != r ? O.makeFromBucketSpec(r, this._host) : De(this._host, this.app.options) } get host() { return this._host } set host(e) { this._host = e, this._bucket = null != this._url ? O.makeFromBucketSpec(this._url, e) : De(e, this.app.options) } get maxUploadRetryTime() { return this._maxUploadRetryTime } set maxUploadRetryTime(e) { L("time", 0, Number.POSITIVE_INFINITY, e), this._maxUploadRetryTime = e } get maxOperationRetryTime() { return this._maxOperationRetryTime } set maxOperationRetryTime(e) { L("time", 0, Number.POSITIVE_INFINITY, e), this._maxOperationRetryTime = e } async _getAuthToken() { if (this._overrideAuthToken) return this._overrideAuthToken; const e = this._authProvider.getImmediate({ optional: !0 }); if (e) { const t = await e.getToken(); if (null !== t) return t.accessToken } return null } async _getAppCheckToken() { const e = this._appCheckProvider.getImmediate({ optional: !0 }); return e ? (await e.getToken()).token : null } _delete() { return this._deleted || (this._deleted = !0, this._requests.forEach(e => e.cancel()), this._requests.clear()), Promise.resolve() } _makeStorageReference(e) { return new Ce(this, e) } _makeRequest(e, t, n, r) { if (this._deleted) return new R(k()); { const s = function (e, t, n, r, s, i) { const o = $(e.urlParams), a = e.url + o, c = Object.assign({}, e.headers); return function (e, t) { t && (e["X-Firebase-GMPID"] = t) }(c, t), function (e, t) { null !== t && t.length > 0 && (e.Authorization = "Firebase " + t) }(c, n), function (e, t) { e["X-Firebase-Storage-Version"] = "webjs/" + (null != t ? t : "AppManager") }(c, i), function (e, t) { null !== t && (e["X-Firebase-AppCheck"] = t) }(c, r), new V(a, e.method, c, e.body, e.successCodes, e.additionalRetryCodes, e.handler, e.errorHandler, e.timeout, e.progressCallback, s) }(e, this._appId, n, r, t, this._firebaseVersion); return this._requests.add(s), s.getPromise().then(() => this._requests.delete(s), () => this._requests.delete(s)), s } } async makeRequestWithTokens(e, t) { const [n, r] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]); return this._makeRequest(e, t, n, r).getPromise() } } const Re = "@firebase/storage", Ne = "0.9.3"; function Pe(e, t) { return xe(e = (0, v.m9)(e), t) } (0, y._registerComponent)(new w.wA("storage", function (e, { instanceIdentifier: t }) { const n = e.getProvider("app").getImmediate(), r = e.getProvider("auth-internal"), s = e.getProvider("app-check-internal"); return new Oe(n, r, s, t, y.SDK_VERSION) }, "PUBLIC").setMultipleInstances(!0)), (0, y.registerVersion)(Re, Ne, ""), (0, y.registerVersion)(Re, Ne, "esm2017"); class Fe { constructor(e, t, n) { this._delegate = e, this.task = t, this.ref = n } get bytesTransferred() { return this._delegate.bytesTransferred } get metadata() { return this._delegate.metadata } get state() { return this._delegate.state } get totalBytes() { return this._delegate.totalBytes } } class Le { constructor(e, t) { this._delegate = e, this._ref = t, this.cancel = this._delegate.cancel.bind(this._delegate), this.catch = this._delegate.catch.bind(this._delegate), this.pause = this._delegate.pause.bind(this._delegate), this.resume = this._delegate.resume.bind(this._delegate) } get snapshot() { return new Fe(this._delegate.snapshot, this, this._ref) } then(e, t) { return this._delegate.then(t => { if (e) return e(new Fe(t, this, this._ref)) }, t) } on(e, t, n, r) { let s; return t && (s = "function" == typeof t ? e => t(new Fe(e, this, this._ref)) : { next: t.next ? e => t.next(new Fe(e, this, this._ref)) : void 0, complete: t.complete || void 0, error: t.error || void 0 }), this._delegate.on(e, s, n || void 0, r || void 0) } } class Me { constructor(e, t) { this._delegate = e, this._service = t } get prefixes() { return this._delegate.prefixes.map(e => new $e(e, this._service)) } get items() { return this._delegate.items.map(e => new $e(e, this._service)) } get nextPageToken() { return this._delegate.nextPageToken || null } } class $e { constructor(e, t) { this._delegate = e, this.storage = t } get name() { return this._delegate.name } get bucket() { return this._delegate.bucket } get fullPath() { return this._delegate.fullPath } toString() { return this._delegate.toString() } child(e) { const t = function (e, t) { return ke(e, t) }(this._delegate, e); return new $e(t, this.storage) } get root() { return new $e(this._delegate.root, this.storage) } get parent() { const e = this._delegate.parent; return null == e ? null : new $e(e, this.storage) } put(e, t) { return this._throwIfRoot("put"), new Le(function (e, t, n) { return function (e, t, n) { return e._throwIfRoot("uploadBytesResumable"), new Ee(e, new X(t), n) }(e = (0, v.m9)(e), t, n) }(this._delegate, e, t), this) } putString(e, t = z.RAW, n) { this._throwIfRoot("putString"); const r = G(t, e), s = Object.assign({}, n); return null == s.contentType && null != r.contentType && (s.contentType = r.contentType), new Le(new Ee(this._delegate, new X(r.data, !0), s), this) } listAll() { return function (e) { return Se(e = (0, v.m9)(e)) }(this._delegate).then(e => new Me(e, this.storage)) } list(e) { return function (e, t) { return Ie(e = (0, v.m9)(e), t) }(this._delegate, e || void 0).then(e => new Me(e, this.storage)) } getMetadata() { return function (e) { return function (e) { e._throwIfRoot("getMetadata"); const t = ue(e.storage, e._location, ne()); return e.storage.makeRequestWithTokens(t, _e) }(e = (0, v.m9)(e)) }(this._delegate) } updateMetadata(e) { return function (e, t) { return function (e, t) { e._throwIfRoot("updateMetadata"); const n = function (e, t, n, r) { const s = M(t.fullServerUrl(), e.host, e._protocol), i = se(n, r), o = e.maxOperationRetryTime, a = new ie(s, "PATCH", ae(e, r), o); return a.headers = { "Content-Type": "application/json; charset=utf-8" }, a.body = i, a.errorHandler = le(t), a }(e.storage, e._location, t, ne()); return e.storage.makeRequestWithTokens(n, _e) }(e = (0, v.m9)(e), t) }(this._delegate, e) } getDownloadURL() { return function (e) { return function (e) { e._throwIfRoot("getDownloadURL"); const t = function (e, t, n) { const r = M(t.fullServerUrl(), e.host, e._protocol), s = e.maxOperationRetryTime, i = new ie(r, "GET", function (e, t) { return function (n, r) { const s = re(e, r, t); return oe(null !== s), function (e, t, n, r) { const s = Z(t); if (null === s) return null; if (!N(s.downloadTokens)) return null; const i = s.downloadTokens; if (0 === i.length) return null; const o = encodeURIComponent; return i.split(",").map(t => { const s = e.fullPath; return M("/b/" + o(e.bucket) + "/o/" + o(s), n, r) + $({ alt: "media", token: t }) })[0] }(s, r, e.host, e._protocol) } }(e, n), s); return i.errorHandler = le(t), i }(e.storage, e._location, ne()); return e.storage.makeRequestWithTokens(t, _e).then(e => { if (null === e) throw new _("no-download-url", "The given file does not have any download URLs."); return e }) }(e = (0, v.m9)(e)) }(this._delegate) } delete() { return this._throwIfRoot("delete"), function (e) { return function (e) { e._throwIfRoot("deleteObject"); const t = function (e, t) { const n = M(t.fullServerUrl(), e.host, e._protocol), r = new ie(n, "DELETE", function (e, t) { }, e.maxOperationRetryTime); return r.successCodes = [200, 204], r.errorHandler = le(t), r }(e.storage, e._location); return e.storage.makeRequestWithTokens(t, _e) }(e = (0, v.m9)(e)) }(this._delegate) } _throwIfRoot(e) { if ("" === this._delegate._location.path) throw A(e) } } class Be { constructor(e, t) { this.app = e, this._delegate = t } get maxOperationRetryTime() { return this._delegate.maxOperationRetryTime } get maxUploadRetryTime() { return this._delegate.maxUploadRetryTime } ref(e) { if (Ve(e)) throw I("ref() expected a child path but got a URL, use refFromURL instead."); return new $e(Pe(this._delegate, e), this) } refFromURL(e) { if (!Ve(e)) throw I("refFromURL() expected a full URL but got a child path, use ref() instead."); try { O.makeFromUrl(e, this._delegate.host) } catch (t) { throw I("refFromUrl() expected a valid full URL but got an invalid one.") } return new $e(Pe(this._delegate, e), this) } setMaxUploadRetryTime(e) { this._delegate.maxUploadRetryTime = e } setMaxOperationRetryTime(e) { this._delegate.maxOperationRetryTime = e } useEmulator(e, t, n = {}) { !function (e, t, n, r = {}) { !function (e, t, n, r = {}) { e.host = `${t}:${n}`, e._protocol = "http"; const { mockUserToken: s } = r; s && (e._overrideAuthToken = "string" == typeof s ? s : (0, v.Sg)(s, e.app.options.projectId)) }(e, t, n, r) }(this._delegate, e, t, n) } } function Ve(e) { return /^[A-Za-z]+:\/\//.test(e) } function Ue(e, { instanceIdentifier: t }) { const n = e.getProvider("app-compat").getImmediate(), r = e.getProvider("storage").getImmediate({ identifier: t }); return new Be(n, r) } !function (e) { const t = { TaskState: ge, TaskEvent: me, StringFormat: z, Storage: Be, Reference: $e }; e.INTERNAL.registerComponent(new w.wA("storage-compat", Ue, "PUBLIC").setServiceProps(t).setMultipleInstances(!0)), e.registerVersion("@firebase/storage-compat", "0.1.11") }(g.Z); var je = n(5355), qe = n(7841); function ze(e) { const t = function (e) { return new r.y(t => { const n = e => t.next(e); n(e.snapshot); const r = e.on("state_changed", n); return e.then(e => { n(e), t.complete() }, r => { n(e.snapshot), (e => { t.error(e) })(r) }), function () { r() } }).pipe(function (e, t = a.P) { return n => n.lift(new c(e, t)) }(0)) }(e); return { task: e, then: e.then.bind(e), catch: e.catch.bind(e), pause: e.pause.bind(e), cancel: e.cancel.bind(e), resume: e.resume.bind(e), snapshotChanges: () => t, percentageChanges: () => t.pipe((0, h.U)(e => e.bytesTransferred / e.totalBytes * 100)) } } function He(e) { return { getDownloadURL: () => (0, s.of)(void 0).pipe(f.fc, (0, d.w)(() => e.getDownloadURL()), f.iC), getMetadata: () => (0, s.of)(void 0).pipe(f.fc, (0, d.w)(() => e.getMetadata()), f.iC), delete: () => (0, i.D)(e.delete()), child: t => He(e.child(t)), updateMetadata: t => (0, i.D)(e.updateMetadata(t)), put: (t, n) => ze(e.put(t, n)), putString: (t, n, r) => ze(e.putString(t, n, r)), list: t => (0, i.D)(e.list(t)), listAll: () => (0, i.D)(e.listAll()) } } const Ge = new p.OlP("angularfire2.storageBucket"), We = new p.OlP("angularfire2.storage.maxUploadRetryTime"), Ye = new p.OlP("angularfire2.storage.maxOperationRetryTime"), Ke = new p.OlP("angularfire2.storage.use-emulator"); let Xe = (() => { class e { constructor(e, t, n, r, s, i, o, a, c, l) { const u = (0, m.on)(e, s, t); this.storage = (0, m.cc)(`${u.name}.storage.${n}`, "AngularFireStorage", u.name, () => { const e = s.runOutsideAngular(() => u.storage(n || void 0)), t = c; return t && e.useEmulator(...t), o && e.setMaxUploadRetryTime(o), a && e.setMaxOperationRetryTime(a), e }, [o, a]) } ref(e) { return He(this.storage.ref(e)) } refFromURL(e) { return He(this.storage.refFromURL(e)) } upload(e, t, n) { return He(this.storage.ref(e)).put(t, n) } } return e.\u0275fac = function (t) { return new (t || e)(p.LFG(m.Dh), p.LFG(m.xv, 8), p.LFG(Ge, 8), p.LFG(p.Lbi), p.LFG(p.R0b), p.LFG(f.HU), p.LFG(We, 8), p.LFG(Ye, 8), p.LFG(Ke, 8), p.LFG(je.nm, 8)) }, e.\u0275prov = p.Yz7({ token: e, factory: e.\u0275fac, providedIn: "any" }), e })(), Ze = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = p.oAB({ type: e }), e.\u0275inj = p.cJS({}), e })(), Qe = (() => { class e { constructor() { qe.Z.registerVersion("angularfire", f.q4.full, "gcs-compat") } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = p.oAB({ type: e }), e.\u0275inj = p.cJS({ providers: [Xe], imports: [Ze] }), e })() }, 8939: (e, t, n) => { "use strict"; n.d(t, { hO: () => m, xv: () => h, Dh: () => u, GT: () => c, cc: () => g, on: () => d, pX: () => a }); var r = n(8720), s = n(7841), i = n(4459); e = n.hmd(e); const o = ["ngOnDestroy"], a = (e, t, n, r = {}) => new Proxy(e, { get: (s, i) => n.runOutsideAngular(() => { var s; if (e[i]) return (null === (s = null == r ? void 0 : r.spy) || void 0 === s ? void 0 : s.get) && r.spy.get(i, e[i]), e[i]; if (o.indexOf(i) > -1) return () => { }; const a = t.toPromise().then(e => { const t = e && e[i]; return "function" == typeof t ? t.bind(e) : t && t.then ? t.then(e => n.run(() => e)) : n.run(() => t) }); return new Proxy(() => { }, { get: (e, t) => a[t], apply: (e, t, n) => a.then(e => { var t; const s = e && e(...n); return (null === (t = null == r ? void 0 : r.spy) || void 0 === t ? void 0 : t.apply) && r.spy.apply(i, n, s), s }) }) }) }), c = (e, t) => { t.forEach(t => { Object.getOwnPropertyNames(t.prototype || t).forEach(n => { Object.defineProperty(e.prototype, n, Object.getOwnPropertyDescriptor(t.prototype || t, n)) }) }) }; class l { constructor(e) { return e } } const u = new r.OlP("angularfire2.app.options"), h = new r.OlP("angularfire2.app.name"); function d(t, n, r) { const i = "object" == typeof r && r || {}; i.name = i.name || "string" == typeof r && r || "[DEFAULT]"; const o = s.Z.apps.filter(e => e && e.name === i.name)[0] || n.runOutsideAngular(() => s.Z.initializeApp(t, i)); try { JSON.stringify(t) !== JSON.stringify(o.options) && f("error", `${o.name} Firebase App already initialized with different options${e.hot ? ", you may need to reload as Firebase is not HMR aware." : "."}`) } catch (a) { } return new l(o) } const f = (e, ...t) => { (0, r.X6Q)() && "undefined" != typeof console && console[e](...t) }, p = { provide: l, useFactory: d, deps: [u, r.R0b, [new r.FiY, h]] }; let m = (() => { class e { constructor(e) { s.Z.registerVersion("angularfire", i.q4.full, "core"), s.Z.registerVersion("angularfire", i.q4.full, "app-compat"), s.Z.registerVersion("angular", r.q4F.full, e.toString()) } static initializeApp(t, n) { return { ngModule: e, providers: [{ provide: u, useValue: t }, { provide: h, useValue: n }] } } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(r.Lbi)) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ providers: [p] }), e })(); function g(e, t, n, r, s) { const [, i, o] = globalThis.\u0275AngularfireInstanceCache.find(t => t[0] === e) || []; if (i) return function (e, t) { try { return e.toString() === t.toString() } catch (n) { return e === t } }(s, o) || (v("error", `${t} was already initialized on the ${n} Firebase App with different settings.${y ? " You may need to reload as Firebase is not HMR aware." : ""}`), v("warn", { is: s, was: o })), i; { const t = r(); return globalThis.\u0275AngularfireInstanceCache.push([e, t, s]), t } } const y = !!e.hot, v = (e, ...t) => { (0, r.X6Q)() && "undefined" != typeof console && console[e](...t) }; globalThis.\u0275AngularfireInstanceCache || (globalThis.\u0275AngularfireInstanceCache = []) }, 4459: (e, t, n) => { "use strict"; n.d(t, { q4: () => Qe, iC: () => ut, fc: () => lt, HU: () => at, vb: () => rt, JM: () => nt }); var r = n(8720), s = n(2329), i = n(279), o = n(3854), a = n(8604), c = n(9306); const l = "@firebase/installations", u = "0.5.6", h = "w:0.5.6", d = new o.LL("installations", "Installations", { "missing-app-config-values": 'Missing App configuration value: "{$valueName}"', "not-registered": "Firebase Installation is not registered.", "installation-not-found": "Firebase Installation not found.", "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', "app-offline": "Could not process request. Application offline.", "delete-pending-registration": "Can't delete installation while there is a pending registration request." }); function f(e) { return e instanceof o.ZR && e.code.includes("request-failed") } function p({ projectId: e }) { return `https://firebaseinstallations.googleapis.com/v1/projects/${e}/installations` } function m(e) { return { token: e.token, requestStatus: 2, expiresIn: (t = e.expiresIn, Number(t.replace("s", "000"))), creationTime: Date.now() }; var t } async function g(e, t) { const n = (await t.json()).error; return d.create("request-failed", { requestName: e, serverCode: n.code, serverMessage: n.message, serverStatus: n.status }) } function y({ apiKey: e }) { return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": e }) } async function v(e) { const t = await e(); return t.status >= 500 && t.status < 600 ? e() : t } function w(e) { return new Promise(t => { setTimeout(t, e) }) } const b = /^[cdef][\w-]{21}$/; function _() { try { const e = new Uint8Array(17); (self.crypto || self.msCrypto).getRandomValues(e), e[0] = 112 + e[0] % 16; const t = function (e) { return (t = e, btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_")).substr(0, 22); var t }(e); return b.test(t) ? t : "" } catch (e) { return "" } } function E(e) { return `${e.appName}!${e.appId}` } const C = new Map; function S(e, t) { const n = E(e); T(n, t), function (e, t) { const n = (!I && "BroadcastChannel" in self && (I = new BroadcastChannel("[Firebase] FID Change"), I.onmessage = e => { T(e.data.key, e.data.fid) }), I); n && n.postMessage({ key: e, fid: t }), 0 === C.size && I && (I.close(), I = null) }(n, t) } function T(e, t) { const n = C.get(e); if (n) for (const r of n) r(t) } let I = null; const k = "firebase-installations-store"; let A = null; function x() { return A || (A = (0, o.X3)("firebase-installations-database", 1, (e, t) => { switch (t) { case 0: e.createObjectStore(k) } })), A } async function D(e, t) { const n = E(e), r = (await x()).transaction(k, "readwrite"), s = r.objectStore(k), i = await s.get(n); return await s.put(t, n), await r.complete, i && i.fid === t.fid || S(e, t.fid), t } async function O(e) { const t = E(e), n = (await x()).transaction(k, "readwrite"); await n.objectStore(k).delete(t), await n.complete } async function R(e, t) { const n = E(e), r = (await x()).transaction(k, "readwrite"), s = r.objectStore(k), i = await s.get(n), o = t(i); return void 0 === o ? await s.delete(n) : await s.put(o, n), await r.complete, !o || i && i.fid === o.fid || S(e, o.fid), o } async function N(e) { let t; const n = await R(e.appConfig, n => { const r = function (e) { return L(e || { fid: _(), registrationStatus: 0 }) }(n), s = function (e, t) { if (0 === t.registrationStatus) { if (!navigator.onLine) return { installationEntry: t, registrationPromise: Promise.reject(d.create("app-offline")) }; const n = { fid: t.fid, registrationStatus: 1, registrationTime: Date.now() }; return { installationEntry: n, registrationPromise: async function (e, t) { try { const n = await async function ({ appConfig: e, heartbeatServiceProvider: t }, { fid: n }) { const r = p(e), s = y(e), i = t.getImmediate({ optional: !0 }); if (i) { const e = await i.getHeartbeatsHeader(); e && s.append("x-firebase-client", e) } const o = { method: "POST", headers: s, body: JSON.stringify({ fid: n, authVersion: "FIS_v2", appId: e.appId, sdkVersion: h }) }, a = await v(() => fetch(r, o)); if (a.ok) { const e = await a.json(); return { fid: e.fid || n, registrationStatus: 2, refreshToken: e.refreshToken, authToken: m(e.authToken) } } throw await g("Create Installation", a) }(e, t); return D(e.appConfig, n) } catch (n) { throw f(n) && 409 === n.customData.serverCode ? await O(e.appConfig) : await D(e.appConfig, { fid: t.fid, registrationStatus: 0 }), n } }(e, n) } } return 1 === t.registrationStatus ? { installationEntry: t, registrationPromise: P(e) } : { installationEntry: t } }(e, r); return t = s.registrationPromise, s.installationEntry }); return "" === n.fid ? { installationEntry: await t } : { installationEntry: n, registrationPromise: t } } async function P(e) { let t = await F(e.appConfig); for (; 1 === t.registrationStatus;)await w(100), t = await F(e.appConfig); if (0 === t.registrationStatus) { const { installationEntry: t, registrationPromise: n } = await N(e); return n || t } return t } function F(e) { return R(e, e => { if (!e) throw d.create("installation-not-found"); return L(e) }) } function L(e) { return 1 === (t = e).registrationStatus && t.registrationTime + 1e4 < Date.now() ? { fid: e.fid, registrationStatus: 0 } : e; var t } async function M(e, t = !1) { let n; const r = await R(e.appConfig, r => { if (!B(r)) throw d.create("not-registered"); const s = r.authToken; if (!t && 2 === (i = s).requestStatus && !function (e) { const t = Date.now(); return t < e.creationTime || e.creationTime + e.expiresIn < t + 36e5 }(i)) return r; var i; if (1 === s.requestStatus) return n = async function (e, t) { let n = await $(e.appConfig); for (; 1 === n.authToken.requestStatus;)await w(100), n = await $(e.appConfig); const r = n.authToken; return 0 === r.requestStatus ? M(e, t) : r }(e, t), r; { if (!navigator.onLine) throw d.create("app-offline"); const t = function (e) { const t = { requestStatus: 1, requestTime: Date.now() }; return Object.assign(Object.assign({}, e), { authToken: t }) }(r); return n = async function (e, t) { try { const n = await async function ({ appConfig: e, heartbeatServiceProvider: t }, n) { const r = function (e, { fid: t }) { return `${p(e)}/${t}/authTokens:generate` }(e, n), s = function (e, { refreshToken: t }) { const n = y(e); return n.append("Authorization", function (e) { return `FIS_v2 ${e}` }(t)), n }(e, n), i = t.getImmediate({ optional: !0 }); if (i) { const e = await i.getHeartbeatsHeader(); e && s.append("x-firebase-client", e) } const o = { method: "POST", headers: s, body: JSON.stringify({ installation: { sdkVersion: h, appId: e.appId } }) }, a = await v(() => fetch(r, o)); if (a.ok) return m(await a.json()); throw await g("Generate Auth Token", a) }(e, t), r = Object.assign(Object.assign({}, t), { authToken: n }); return await D(e.appConfig, r), n } catch (n) { if (!f(n) || 401 !== n.customData.serverCode && 404 !== n.customData.serverCode) { const n = Object.assign(Object.assign({}, t), { authToken: { requestStatus: 0 } }); await D(e.appConfig, n) } else await O(e.appConfig); throw n } }(e, t), t } }); return n ? await n : r.authToken } function $(e) { return R(e, e => { if (!B(e)) throw d.create("not-registered"); return 1 === (t = e.authToken).requestStatus && t.requestTime + 1e4 < Date.now() ? Object.assign(Object.assign({}, e), { authToken: { requestStatus: 0 } }) : e; var t }) } function B(e) { return void 0 !== e && 2 === e.registrationStatus } function V(e) { return d.create("missing-app-config-values", { valueName: e }) } const U = "installations"; (0, i._registerComponent)(new a.wA(U, e => { const t = e.getProvider("app").getImmediate(); return { app: t, appConfig: function (e) { if (!e || !e.options) throw V("App Configuration"); if (!e.name) throw V("App Name"); const t = ["projectId", "apiKey", "appId"]; for (const n of t) if (!e.options[n]) throw V(n); return { appName: e.name, projectId: e.options.projectId, apiKey: e.options.apiKey, appId: e.options.appId } }(t), heartbeatServiceProvider: (0, i._getProvider)(t, "heartbeat"), _delete: () => Promise.resolve() } }, "PUBLIC")), (0, i._registerComponent)(new a.wA("installations-internal", e => { const t = e.getProvider("app").getImmediate(), n = (0, i._getProvider)(t, U).getImmediate(); return { getId: () => async function (e) { const t = e, { installationEntry: n, registrationPromise: r } = await N(t); return r ? r.catch(console.error) : M(t).catch(console.error), n.fid }(n), getToken: e => async function (e, t = !1) { const n = e; return await async function (e) { const { registrationPromise: t } = await N(e); t && await t }(n), (await M(n, t)).token }(n, e) } }, "PRIVATE")), (0, i.registerVersion)(l, u), (0, i.registerVersion)(l, u, "esm2017"); const j = "@firebase/remote-config", q = "0.3.5", z = new o.LL("remoteconfig", "Remote Config", { "registration-window": "Undefined window object. This SDK only supports usage in a browser environment.", "registration-project-id": "Undefined project identifier. Check Firebase app initialization.", "registration-api-key": "Undefined API key. Check Firebase app initialization.", "registration-app-id": "Undefined app identifier. Check Firebase app initialization.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "storage-delete": "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.", "fetch-client-network": "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", "fetch-timeout": 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.', "fetch-throttle": 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.', "fetch-client-parse": "Fetch client could not parse response. Original error: {$originalErrorMessage}.", "fetch-status": "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", "indexed-db-unavailable": "Indexed DB is not supported by current browser" }); class H { constructor(e, t, n, r) { this.client = e, this.storage = t, this.storageCache = n, this.logger = r } isCachedDataFresh(e, t) { if (!t) return this.logger.debug("Config fetch cache check. Cache unpopulated."), !1; const n = Date.now() - t, r = n <= e; return this.logger.debug(`Config fetch cache check. Cache age millis: ${n}. Cache max age millis (minimumFetchIntervalMillis setting): ${e}. Is cache hit: ${r}.`), r } async fetch(e) { const [t, n] = await Promise.all([this.storage.getLastSuccessfulFetchTimestampMillis(), this.storage.getLastSuccessfulFetchResponse()]); if (n && this.isCachedDataFresh(e.cacheMaxAgeMillis, t)) return n; e.eTag = n && n.eTag; const r = await this.client.fetch(e), s = [this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())]; return 200 === r.status && s.push(this.storage.setLastSuccessfulFetchResponse(r)), await Promise.all(s), r } } function G(e = navigator) { return e.languages && e.languages[0] || e.language } class W { constructor(e, t, n, r, s, i) { this.firebaseInstallations = e, this.sdkVersion = t, this.namespace = n, this.projectId = r, this.apiKey = s, this.appId = i } async fetch(e) { const [t, n] = await Promise.all([this.firebaseInstallations.getId(), this.firebaseInstallations.getToken()]), r = `${window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com"}/v1/projects/${this.projectId}/namespaces/${this.namespace}:fetch?key=${this.apiKey}`, s = { "Content-Type": "application/json", "Content-Encoding": "gzip", "If-None-Match": e.eTag || "*" }, i = { sdk_version: this.sdkVersion, app_instance_id: t, app_instance_id_token: n, app_id: this.appId, language_code: G() }, o = { method: "POST", headers: s, body: JSON.stringify(i) }, a = fetch(r, o), c = new Promise((t, n) => { e.signal.addEventListener(() => { const e = new Error("The operation was aborted."); e.name = "AbortError", n(e) }) }); let l; try { await Promise.race([a, c]), l = await a } catch (p) { let e = "fetch-client-network"; throw "AbortError" === p.name && (e = "fetch-timeout"), z.create(e, { originalErrorMessage: p.message }) } let u = l.status; const h = l.headers.get("ETag") || void 0; let d, f; if (200 === l.status) { let e; try { e = await l.json() } catch (p) { throw z.create("fetch-client-parse", { originalErrorMessage: p.message }) } d = e.entries, f = e.state } if ("INSTANCE_STATE_UNSPECIFIED" === f ? u = 500 : "NO_CHANGE" === f ? u = 304 : "NO_TEMPLATE" !== f && "EMPTY_CONFIG" !== f || (d = {}), 304 !== u && 200 !== u) throw z.create("fetch-status", { httpStatus: u }); return { status: u, eTag: h, config: d } } } class Y { constructor(e, t) { this.client = e, this.storage = t } async fetch(e) { const t = await this.storage.getThrottleMetadata() || { backoffCount: 0, throttleEndTimeMillis: Date.now() }; return this.attemptFetch(e, t) } async attemptFetch(e, { throttleEndTimeMillis: t, backoffCount: n }) { await function (e, t) { return new Promise((n, r) => { const s = Math.max(t - Date.now(), 0), i = setTimeout(n, s); e.addEventListener(() => { clearTimeout(i), r(z.create("fetch-throttle", { throttleEndTimeMillis: t })) }) }) }(e.signal, t); try { const t = await this.client.fetch(e); return await this.storage.deleteThrottleMetadata(), t } catch (r) { if (!function (e) { if (!(e instanceof o.ZR && e.customData)) return !1; const t = Number(e.customData.httpStatus); return 429 === t || 500 === t || 503 === t || 504 === t }(r)) throw r; const t = { throttleEndTimeMillis: Date.now() + (0, o.$s)(n), backoffCount: n + 1 }; return await this.storage.setThrottleMetadata(t), this.attemptFetch(e, t) } } } class K { constructor(e, t, n, r, s) { this.app = e, this._client = t, this._storageCache = n, this._storage = r, this._logger = s, this._isInitializationComplete = !1, this.settings = { fetchTimeoutMillis: 6e4, minimumFetchIntervalMillis: 432e5 }, this.defaultConfig = {} } get fetchTimeMillis() { return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1 } get lastFetchStatus() { return this._storageCache.getLastFetchStatus() || "no-fetch-yet" } } function X(e, t) { const n = e.target.error || void 0; return z.create(t, { originalErrorMessage: n && n.message }) } const Z = "app_namespace_store"; class Q { constructor(e, t, n, r = function () { return new Promise((e, t) => { try { const n = indexedDB.open("firebase_remote_config", 1); n.onerror = e => { t(X(e, "storage-open")) }, n.onsuccess = t => { e(t.target.result) }, n.onupgradeneeded = e => { const t = e.target.result; switch (e.oldVersion) { case 0: t.createObjectStore(Z, { keyPath: "compositeKey" }) } } } catch (n) { t(z.create("storage-open", { originalErrorMessage: n })) } }) }()) { this.appId = e, this.appName = t, this.namespace = n, this.openDbPromise = r } getLastFetchStatus() { return this.get("last_fetch_status") } setLastFetchStatus(e) { return this.set("last_fetch_status", e) } getLastSuccessfulFetchTimestampMillis() { return this.get("last_successful_fetch_timestamp_millis") } setLastSuccessfulFetchTimestampMillis(e) { return this.set("last_successful_fetch_timestamp_millis", e) } getLastSuccessfulFetchResponse() { return this.get("last_successful_fetch_response") } setLastSuccessfulFetchResponse(e) { return this.set("last_successful_fetch_response", e) } getActiveConfig() { return this.get("active_config") } setActiveConfig(e) { return this.set("active_config", e) } getActiveConfigEtag() { return this.get("active_config_etag") } setActiveConfigEtag(e) { return this.set("active_config_etag", e) } getThrottleMetadata() { return this.get("throttle_metadata") } setThrottleMetadata(e) { return this.set("throttle_metadata", e) } deleteThrottleMetadata() { return this.delete("throttle_metadata") } async get(e) { const t = await this.openDbPromise; return new Promise((n, r) => { const s = t.transaction([Z], "readonly").objectStore(Z), i = this.createCompositeKey(e); try { const e = s.get(i); e.onerror = e => { r(X(e, "storage-get")) }, e.onsuccess = e => { const t = e.target.result; n(t ? t.value : void 0) } } catch (o) { r(z.create("storage-get", { originalErrorMessage: o && o.message })) } }) } async set(e, t) { const n = await this.openDbPromise; return new Promise((r, s) => { const i = n.transaction([Z], "readwrite").objectStore(Z), o = this.createCompositeKey(e); try { const e = i.put({ compositeKey: o, value: t }); e.onerror = e => { s(X(e, "storage-set")) }, e.onsuccess = () => { r() } } catch (a) { s(z.create("storage-set", { originalErrorMessage: a && a.message })) } }) } async delete(e) { const t = await this.openDbPromise; return new Promise((n, r) => { const s = t.transaction([Z], "readwrite").objectStore(Z), i = this.createCompositeKey(e); try { const e = s.delete(i); e.onerror = e => { r(X(e, "storage-delete")) }, e.onsuccess = () => { n() } } catch (o) { r(z.create("storage-delete", { originalErrorMessage: o && o.message })) } }) } createCompositeKey(e) { return [this.appId, this.appName, this.namespace, e].join() } } class J { constructor(e) { this.storage = e } getLastFetchStatus() { return this.lastFetchStatus } getLastSuccessfulFetchTimestampMillis() { return this.lastSuccessfulFetchTimestampMillis } getActiveConfig() { return this.activeConfig } async loadFromStorage() { const e = this.storage.getLastFetchStatus(), t = this.storage.getLastSuccessfulFetchTimestampMillis(), n = this.storage.getActiveConfig(), r = await e; r && (this.lastFetchStatus = r); const s = await t; s && (this.lastSuccessfulFetchTimestampMillis = s); const i = await n; i && (this.activeConfig = i) } setLastFetchStatus(e) { return this.lastFetchStatus = e, this.storage.setLastFetchStatus(e) } setLastSuccessfulFetchTimestampMillis(e) { return this.lastSuccessfulFetchTimestampMillis = e, this.storage.setLastSuccessfulFetchTimestampMillis(e) } setActiveConfig(e) { return this.activeConfig = e, this.storage.setActiveConfig(e) } } async function ee() { if (!(0, o.hl)()) return !1; try { return await (0, o.eu)() } catch (e) { return !1 } } (0, i._registerComponent)(new a.wA("remote-config", function (e, { instanceIdentifier: t }) { const n = e.getProvider("app").getImmediate(), r = e.getProvider("installations-internal").getImmediate(); if ("undefined" == typeof window) throw z.create("registration-window"); if (!(0, o.hl)()) throw z.create("indexed-db-unavailable"); const { projectId: s, apiKey: a, appId: l } = n.options; if (!s) throw z.create("registration-project-id"); if (!a) throw z.create("registration-api-key"); if (!l) throw z.create("registration-app-id"); const u = new Q(l, n.name, t = t || "firebase"), h = new J(u), d = new c.Yd(j); d.logLevel = c.in.ERROR; const f = new W(r, i.SDK_VERSION, t, s, a, l), p = new Y(f, u), m = new H(p, u, h, d), g = new K(n, m, h, u, d); return function (e) { const t = (0, o.m9)(e); t._initializePromise || (t._initializePromise = t._storageCache.loadFromStorage().then(() => { t._isInitializationComplete = !0 })) }(g), g }, "PUBLIC").setMultipleInstances(!0)), (0, i.registerVersion)(j, q), (0, i.registerVersion)(j, q, "esm2017"); const te = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4"; var ne = (() => (function (e) { e.PUSH_RECEIVED = "push-received", e.NOTIFICATION_CLICKED = "notification-clicked" }(ne || (ne = {})), ne))(); function re(e) { const t = new Uint8Array(e); return btoa(String.fromCharCode(...t)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_") } function se(e) { const t = (e + "=".repeat((4 - e.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"), n = atob(t), r = new Uint8Array(n.length); for (let s = 0; s < n.length; ++s)r[s] = n.charCodeAt(s); return r } const ie = "fcm_token_details_db", oe = "fcm_token_object_Store", ae = "firebase-messaging-store"; let ce = null; function le() { return ce || (ce = (0, o.X3)("firebase-messaging-database", 1, (e, t) => { switch (t) { case 0: e.createObjectStore(ae) } })), ce } async function ue(e) { const t = de(e), n = await le(), r = await n.transaction(ae).objectStore(ae).get(t); if (r) return r; { const t = await async function (e) { if ("databases" in indexedDB && !(await indexedDB.databases()).map(e => e.name).includes(ie)) return null; let t = null; return (await (0, o.X3)(ie, 5, async (n, r, s, i) => { var o; if (r < 2) return; if (!n.objectStoreNames.contains(oe)) return; const a = i.objectStore(oe), c = await a.index("fcmSenderId").get(e); if (await a.clear(), c) if (2 === r) { const e = c; if (!e.auth || !e.p256dh || !e.endpoint) return; t = { token: e.fcmToken, createTime: null !== (o = e.createTime) && void 0 !== o ? o : Date.now(), subscriptionOptions: { auth: e.auth, p256dh: e.p256dh, endpoint: e.endpoint, swScope: e.swScope, vapidKey: "string" == typeof e.vapidKey ? e.vapidKey : re(e.vapidKey) } } } else if (3 === r) { const e = c; t = { token: e.fcmToken, createTime: e.createTime, subscriptionOptions: { auth: re(e.auth), p256dh: re(e.p256dh), endpoint: e.endpoint, swScope: e.swScope, vapidKey: re(e.vapidKey) } } } else if (4 === r) { const e = c; t = { token: e.fcmToken, createTime: e.createTime, subscriptionOptions: { auth: re(e.auth), p256dh: re(e.p256dh), endpoint: e.endpoint, swScope: e.swScope, vapidKey: re(e.vapidKey) } } } })).close(), await (0, o.Lj)(ie), await (0, o.Lj)("fcm_vapid_details_db"), await (0, o.Lj)("undefined"), function (e) { if (!e || !e.subscriptionOptions) return !1; const { subscriptionOptions: t } = e; return "number" == typeof e.createTime && e.createTime > 0 && "string" == typeof e.token && e.token.length > 0 && "string" == typeof t.auth && t.auth.length > 0 && "string" == typeof t.p256dh && t.p256dh.length > 0 && "string" == typeof t.endpoint && t.endpoint.length > 0 && "string" == typeof t.swScope && t.swScope.length > 0 && "string" == typeof t.vapidKey && t.vapidKey.length > 0 }(t) ? t : null }(e.appConfig.senderId); if (t) return await he(e, t), t } } async function he(e, t) { const n = de(e), r = (await le()).transaction(ae, "readwrite"); return await r.objectStore(ae).put(t, n), await r.complete, t } function de({ appConfig: e }) { return e.appId } const fe = new o.LL("messaging", "Messaging", { "missing-app-config-values": 'Missing App configuration value: "{$valueName}"', "only-available-in-window": "This method is available in a Window context.", "only-available-in-sw": "This method is available in a service worker context.", "permission-default": "The notification permission was not granted and dismissed instead.", "permission-blocked": "The notification permission was not granted and blocked instead.", "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.", "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)", "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}", "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}", "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.", "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}", "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}", "token-update-no-token": "FCM returned no token when updating the user to push.", "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.", "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.", "invalid-vapid-key": "The public VAPID key must be a string.", "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used." }); async function pe(e, t) { const n = { method: "DELETE", headers: await ge(e) }; try { const r = await fetch(`${me(e.appConfig)}/${t}`, n), s = await r.json(); if (s.error) throw fe.create("token-unsubscribe-failed", { errorInfo: s.error.message }) } catch (r) { throw fe.create("token-unsubscribe-failed", { errorInfo: r }) } } function me({ projectId: e }) { return `https://fcmregistrations.googleapis.com/v1/projects/${e}/registrations` } async function ge({ appConfig: e, installations: t }) { const n = await t.getToken(); return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": e.apiKey, "x-goog-firebase-installations-auth": `FIS ${n}` }) } function ye({ p256dh: e, auth: t, endpoint: n, vapidKey: r }) { const s = { web: { endpoint: n, auth: t, p256dh: e } }; return r !== te && (s.web.applicationPubKey = r), s } async function ve(e, t) { const n = { token: await async function (e, t) { const n = await ge(e), r = ye(t), s = { method: "POST", headers: n, body: JSON.stringify(r) }; let i; try { const t = await fetch(me(e.appConfig), s); i = await t.json() } catch (o) { throw fe.create("token-subscribe-failed", { errorInfo: o }) } if (i.error) throw fe.create("token-subscribe-failed", { errorInfo: i.error.message }); if (!i.token) throw fe.create("token-subscribe-no-token"); return i.token }(e, t), createTime: Date.now(), subscriptionOptions: t }; return await he(e, n), n.token } function we(e) { const t = { from: e.from, collapseKey: e.collapse_key, messageId: e.fcmMessageId }; return function (e, t) { if (!t.notification) return; e.notification = {}; const n = t.notification.title; n && (e.notification.title = n); const r = t.notification.body; r && (e.notification.body = r); const s = t.notification.image; s && (e.notification.image = s) }(t, e), function (e, t) { t.data && (e.data = t.data) }(t, e), function (e, t) { if (!t.fcmOptions) return; e.fcmOptions = {}; const n = t.fcmOptions.link; n && (e.fcmOptions.link = n); const r = t.fcmOptions.analytics_label; r && (e.fcmOptions.analyticsLabel = r) }(t, e), t } function be(e, t) { const n = []; for (let r = 0; r < e.length; r++)n.push(e.charAt(r)), r < t.length && n.push(t.charAt(r)); return n.join("") } function _e(e) { return fe.create("missing-app-config-values", { valueName: e }) } be("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o"), be("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4"); class Ee { constructor(e, t, n) { this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1; const r = function (e) { if (!e || !e.options) throw _e("App Configuration Object"); if (!e.name) throw _e("App Name"); const t = ["projectId", "apiKey", "appId", "messagingSenderId"], { options: n } = e; for (const r of t) if (!n[r]) throw _e(r); return { appName: e.name, projectId: n.projectId, apiKey: n.apiKey, appId: n.appId, senderId: n.messagingSenderId } }(e); this.firebaseDependencies = { app: e, appConfig: r, installations: t, analyticsProvider: n } } _delete() { return Promise.resolve() } } async function Ce(e, t) { if (!navigator) throw fe.create("only-available-in-window"); if ("default" === Notification.permission && await Notification.requestPermission(), "granted" !== Notification.permission) throw fe.create("permission-blocked"); return await async function (e, t) { t ? e.vapidKey = t : e.vapidKey || (e.vapidKey = te) }(e, null == t ? void 0 : t.vapidKey), await async function (e, t) { if (t || e.swRegistration || await async function (e) { try { e.swRegistration = await navigator.serviceWorker.register("/firebase-messaging-sw.js", { scope: "/firebase-cloud-messaging-push-scope" }), e.swRegistration.update().catch(() => { }) } catch (t) { throw fe.create("failed-service-worker-registration", { browserErrorMessage: t.message }) } }(e), t || !e.swRegistration) { if (!(t instanceof ServiceWorkerRegistration)) throw fe.create("invalid-sw-registration"); e.swRegistration = t } }(e, null == t ? void 0 : t.serviceWorkerRegistration), async function (e) { const t = await async function (e, t) { return await e.pushManager.getSubscription() || e.pushManager.subscribe({ userVisibleOnly: !0, applicationServerKey: se(t) }) }(e.swRegistration, e.vapidKey), n = { vapidKey: e.vapidKey, swScope: e.swRegistration.scope, endpoint: t.endpoint, auth: re(t.getKey("auth")), p256dh: re(t.getKey("p256dh")) }, r = await ue(e.firebaseDependencies); if (r) { if ((i = n).vapidKey === (s = r.subscriptionOptions).vapidKey && i.endpoint === s.endpoint && i.auth === s.auth && i.p256dh === s.p256dh) return Date.now() >= r.createTime + 6048e5 ? async function (e, t) { try { const n = await async function (e, t) { const n = await ge(e), r = ye(t.subscriptionOptions), s = { method: "PATCH", headers: n, body: JSON.stringify(r) }; let i; try { const n = await fetch(`${me(e.appConfig)}/${t.token}`, s); i = await n.json() } catch (o) { throw fe.create("token-update-failed", { errorInfo: o }) } if (i.error) throw fe.create("token-update-failed", { errorInfo: i.error.message }); if (!i.token) throw fe.create("token-update-no-token"); return i.token }(e.firebaseDependencies, t), r = Object.assign(Object.assign({}, t), { token: n, createTime: Date.now() }); return await he(e.firebaseDependencies, r), n } catch (n) { throw await async function (e) { const t = await ue(e.firebaseDependencies); t && (await pe(e.firebaseDependencies, t.token), await async function (e) { const t = de(e), n = (await le()).transaction(ae, "readwrite"); await n.objectStore(ae).delete(t), await n.complete }(e.firebaseDependencies)); const n = await e.swRegistration.pushManager.getSubscription(); return !n || n.unsubscribe() }(e), n } }(e, { token: r.token, createTime: Date.now(), subscriptionOptions: n }) : r.token; try { await pe(e.firebaseDependencies, r.token) } catch (o) { console.warn(o) } return ve(e.firebaseDependencies, n) } var s, i; return ve(e.firebaseDependencies, n) }(e) } const Se = "@firebase/messaging", Te = "0.9.10"; async function Ie() { try { await (0, o.eu)() } catch (e) { return !1 } return "undefined" != typeof window && (0, o.hl)() && (0, o.zI)() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey") } (0, i._registerComponent)(new a.wA("messaging", e => { const t = new Ee(e.getProvider("app").getImmediate(), e.getProvider("installations-internal").getImmediate(), e.getProvider("analytics-internal")); return navigator.serviceWorker.addEventListener("message", e => async function (e, t) { const n = t.data; if (!n.isFirebaseMessaging) return; e.onMessageHandler && n.messageType === ne.PUSH_RECEIVED && ("function" == typeof e.onMessageHandler ? e.onMessageHandler(we(n)) : e.onMessageHandler.next(we(n))); const r = n.data; var s; "object" == typeof (s = r) && s && "google.c.a.c_id" in s && "1" === r["google.c.a.e"] && await async function (e, t, n) { const r = function (e) { switch (e) { case ne.NOTIFICATION_CLICKED: return "notification_open"; case ne.PUSH_RECEIVED: return "notification_foreground"; default: throw new Error } }(t); (await e.firebaseDependencies.analyticsProvider.get()).logEvent(r, { message_id: n["google.c.a.c_id"], message_name: n["google.c.a.c_l"], message_time: n["google.c.a.ts"], message_device_time: Math.floor(Date.now() / 1e3) }) }(e, n.messageType, r) }(t, e)), t }, "PUBLIC")), (0, i._registerComponent)(new a.wA("messaging-internal", e => { const t = e.getProvider("messaging").getImmediate(); return { getToken: e => Ce(t, e) } }, "PRIVATE")), (0, i.registerVersion)(Se, Te), (0, i.registerVersion)(Se, Te, "esm2017"); const ke = "analytics", Ae = "https://www.googletagmanager.com/gtag/js", xe = new c.Yd("@firebase/analytics"); function De(e) { return Promise.all(e.map(e => e.catch(e => e))) } const Oe = new o.LL("analytics", "Analytics", { "already-exists": "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.", "already-initialized": "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.", "already-initialized-settings": "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.", "interop-component-reg-failed": "Firebase Analytics Interop Component failed to instantiate: {$reason}", "invalid-analytics-context": "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", "indexeddb-unavailable": "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", "fetch-throttle": "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.", "config-fetch-failed": "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}", "no-api-key": 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.', "no-app-id": 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.' }), Re = new class { constructor(e = {}, t = 1e3) { this.throttleMetadata = e, this.intervalMillis = t } getThrottleMetadata(e) { return this.throttleMetadata[e] } setThrottleMetadata(e, t) { this.throttleMetadata[e] = t } deleteThrottleMetadata(e) { delete this.throttleMetadata[e] } }; function Ne(e) { return new Headers({ Accept: "application/json", "x-goog-api-key": e }) } async function Pe(e, t = Re, n) { const { appId: r, apiKey: s, measurementId: i } = e.options; if (!r) throw Oe.create("no-app-id"); if (!s) { if (i) return { measurementId: i, appId: r }; throw Oe.create("no-api-key") } const o = t.getThrottleMetadata(r) || { backoffCount: 0, throttleEndTimeMillis: Date.now() }, a = new Le; return setTimeout(async () => { a.abort() }, void 0 !== n ? n : 6e4), Fe({ appId: r, apiKey: s, measurementId: i }, o, a, t) } async function Fe(e, { throttleEndTimeMillis: t, backoffCount: n }, r, s = Re) { const { appId: i, measurementId: a } = e; try { await function (e, t) { return new Promise((n, r) => { const s = Math.max(t - Date.now(), 0), i = setTimeout(n, s); e.addEventListener(() => { clearTimeout(i), r(Oe.create("fetch-throttle", { throttleEndTimeMillis: t })) }) }) }(r, t) } catch (c) { if (a) return xe.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${c.message}]`), { appId: i, measurementId: a }; throw c } try { const t = await async function (e) { var t; const { appId: n, apiKey: r } = e, s = { method: "GET", headers: Ne(r) }, i = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig".replace("{app-id}", n), o = await fetch(i, s); if (200 !== o.status && 304 !== o.status) { let e = ""; try { const n = await o.json(); (null === (t = n.error) || void 0 === t ? void 0 : t.message) && (e = n.error.message) } catch (a) { } throw Oe.create("config-fetch-failed", { httpStatus: o.status, responseMessage: e }) } return o.json() }(e); return s.deleteThrottleMetadata(i), t } catch (c) { if (!function (e) { if (!(e instanceof o.ZR && e.customData)) return !1; const t = Number(e.customData.httpStatus); return 429 === t || 500 === t || 503 === t || 504 === t }(c)) { if (s.deleteThrottleMetadata(i), a) return xe.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${a} provided in the "measurementId" field in the local Firebase config. [${c.message}]`), { appId: i, measurementId: a }; throw c } const t = 503 === Number(c.customData.httpStatus) ? (0, o.$s)(n, s.intervalMillis, 30) : (0, o.$s)(n, s.intervalMillis), l = { throttleEndTimeMillis: Date.now() + t, backoffCount: n + 1 }; return s.setThrottleMetadata(i, l), xe.debug(`Calling attemptFetch again in ${t} millis`), Fe(e, l, r, s) } } class Le { constructor() { this.listeners = [] } addEventListener(e) { this.listeners.push(e) } abort() { this.listeners.forEach(e => e()) } } class Me { constructor(e) { this.app = e } _delete() { return delete $e[this.app.options.appId], Promise.resolve() } } let $e = {}, Be = []; const Ve = {}; let Ue, je, qe = !1; async function ze() { if ((0, o.ru)()) return !1; if (!(0, o.zI)()) return !1; if (!(0, o.hl)()) return !1; try { return await (0, o.eu)() } catch (e) { return !1 } } const He = "@firebase/analytics", Ge = "0.7.6"; (0, i._registerComponent)(new a.wA(ke, (e, { options: t }) => function (e, t, n) { !function () { const e = []; if ((0, o.ru)() && e.push("This is a browser extension environment."), (0, o.zI)() || e.push("Cookies are not available."), e.length > 0) { const t = e.map((e, t) => `(${t + 1}) ${e}`).join(" "), n = Oe.create("invalid-analytics-context", { errorInfo: t }); xe.warn(n.message) } }(); const r = e.options.appId; if (!r) throw Oe.create("no-app-id"); if (!e.options.apiKey) { if (!e.options.measurementId) throw Oe.create("no-api-key"); xe.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${e.options.measurementId} provided in the "measurementId" field in the local Firebase config.`) } if (null != $e[r]) throw Oe.create("already-exists", { id: r }); if (!qe) { !function (e) { let t = []; Array.isArray(window.dataLayer) ? t = window.dataLayer : window.dataLayer = t }(); const { wrappedGtag: e, gtagCore: t } = function (e, t, n, r, s) { let i = function (...e) { window.dataLayer.push(arguments) }; return window.gtag && "function" == typeof window.gtag && (i = window.gtag), window.gtag = function (e, t, n, r) { return async function (s, i, o) { try { "event" === s ? await async function (e, t, n, r, s) { try { let i = []; if (s && s.send_to) { let e = s.send_to; Array.isArray(e) || (e = [e]); const r = await De(n); for (const n of e) { const e = r.find(e => e.measurementId === n), s = e && t[e.appId]; if (!s) { i = []; break } i.push(s) } } 0 === i.length && (i = Object.values(t)), await Promise.all(i), e("event", r, s || {}) } catch (i) { xe.error(i) } }(e, t, n, i, o) : "config" === s ? await async function (e, t, n, r, s, i) { const o = r[s]; try { if (o) await t[o]; else { const e = (await De(n)).find(e => e.measurementId === s); e && await t[e.appId] } } catch (a) { xe.error(a) } e("config", s, i) }(e, t, n, r, i, o) : e("set", i) } catch (a) { xe.error(a) } } }(i, e, t, n), { gtagCore: i, wrappedGtag: window.gtag } }($e, Be, Ve); je = e, Ue = t, qe = !0 } return $e[r] = async function (e, t, n, r, s, i, a) { var c; const l = Pe(e); l.then(t => { n[t.measurementId] = t.appId, e.options.measurementId && t.measurementId !== e.options.measurementId && xe.warn(`The measurement ID in the local Firebase config (${e.options.measurementId}) does not match the measurement ID fetched from the server (${t.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`) }).catch(e => xe.error(e)), t.push(l); const u = async function () { if (!(0, o.hl)()) return xe.warn(Oe.create("indexeddb-unavailable", { errorInfo: "IndexedDB is not available in this environment." }).message), !1; try { await (0, o.eu)() } catch (e) { return xe.warn(Oe.create("indexeddb-unavailable", { errorInfo: e }).message), !1 } return !0 }().then(e => e ? r.getId() : void 0), [h, d] = await Promise.all([l, u]); (function () { const e = window.document.getElementsByTagName("script"); for (const t of Object.values(e)) if (t.src && t.src.includes(Ae)) return t; return null })() || function (e, t) { const n = document.createElement("script"); n.src = `${Ae}?l=dataLayer&id=${t}`, n.async = !0, document.head.appendChild(n) }(0, h.measurementId), s("js", new Date); const f = null !== (c = null == a ? void 0 : a.config) && void 0 !== c ? c : {}; return f.origin = "firebase", f.update = !0, null != d && (f.firebase_id = d), s("config", h.measurementId, f), h.measurementId }(e, Be, Ve, t, Ue, 0, n), new Me(e) }(e.getProvider("app").getImmediate(), e.getProvider("installations-internal").getImmediate(), t), "PUBLIC")), (0, i._registerComponent)(new a.wA("analytics-internal", function (e) { try { const t = e.getProvider(ke).getImmediate(); return { logEvent: (e, n, r) => function (e, t, n, r) { e = (0, o.m9)(e), async function (e, t, n, r, s) { if (s && s.global) e("event", n, r); else { const s = await t; e("event", n, Object.assign(Object.assign({}, r), { send_to: s })) } }(je, $e[e.app.options.appId], t, n, r).catch(e => xe.error(e)) }(t, e, n, r) } } catch (t) { throw Oe.create("interop-component-reg-failed", { reason: t }) } }, "PRIVATE")), (0, i.registerVersion)(He, Ge), (0, i.registerVersion)(He, Ge, "esm2017"); var We = n(7771), Ye = n(3637), Ke = n(8307), Xe = n(9746), Ze = n(3101); const Qe = new r.GfV("7.2.0"), Je = "__angularfire_symbol__analyticsIsSupported", et = "__angularfire_symbol__remoteConfigIsSupported", tt = "__angularfire_symbol__messagingIsSupported"; function nt(e, t, n) { if (t) { if (1 === t.length) return t[0]; const e = t.filter(e => e.app === n); if (1 === e.length) return e[0] } return n.container.getProvider(e).getImmediate({ optional: !0 }) } globalThis[Je] || (globalThis[Je] = ze().then(e => globalThis.__angularfire_symbol__analyticsIsSupportedValue = e)), globalThis[tt] || (globalThis[tt] = Ie().then(e => globalThis.__angularfire_symbol__messagingIsSupportedValue = e)), globalThis[et] || (globalThis[et] = ee().then(e => globalThis.__angularfire_symbol__remoteConfigIsSupportedValue = e)); const rt = (e, t) => { const n = t ? [t] : (0, s.C6)(), r = []; return n.forEach(t => { t.container.getProvider(e).instances.forEach(e => { r.includes(e) || r.push(e) }) }), r }; function st() { } class it { constructor(e, t = We.N) { this.zone = e, this.delegate = t } now() { return this.delegate.now() } schedule(e, t, n) { const r = this.zone; return this.delegate.schedule(function (t) { r.runGuarded(() => { e.apply(this, [t]) }) }, t, n) } } class ot { constructor(e) { this.zone = e, this.task = null } call(e, t) { const n = this.unscheduleTask.bind(this); return this.task = this.zone.run(() => Zone.current.scheduleMacroTask("firebaseZoneBlock", st, {}, st, st)), t.pipe((0, Ke.b)({ next: n, complete: n, error: n })).subscribe(e).add(n) } unscheduleTask() { setTimeout(() => { null != this.task && "scheduled" === this.task.state && (this.task.invoke(), this.task = null) }, 10) } } let at = (() => { class e { constructor(e) { this.ngZone = e, this.outsideAngular = e.runOutsideAngular(() => new it(Zone.current)), this.insideAngular = e.run(() => new it(Zone.current, Ye.z)), globalThis.\u0275AngularFireScheduler || (globalThis.\u0275AngularFireScheduler = this) } } return e.\u0275fac = function (t) { return new (t || e)(r.LFG(r.R0b)) }, e.\u0275prov = r.Yz7({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function ct() { const e = globalThis.\u0275AngularFireScheduler; if (!e) throw new Error("Either AngularFireModule has not been provided in your AppModule (this can be done manually or implictly using\nprovideFirebaseApp) or you're calling an AngularFire method outside of an NgModule (which is not supported)."); return e } function lt(e) { return e.pipe((0, Xe.QV)(ct().outsideAngular)) } function ut(e) { return ct(), (t = ct(), function (e) { return (e = e.lift(new ot(t.ngZone))).pipe((0, Ze.R)(t.outsideAngular), (0, Xe.QV)(t.insideAngular)) })(e); var t } }, 665: (e, t, n) => { "use strict"; n.d(t, { NI: () => oe, u: () => me, cw: () => ae, sg: () => fe, u5: () => we, JU: () => f, a5: () => B, JJ: () => U, JL: () => j, UX: () => be, Q7: () => ye, kI: () => E, _Y: () => le }); var r = n(8720), s = n(8583), i = n(8891), o = n(9796), a = n(8002), c = n(1555), l = n(4402); function u(e, t) { return new i.y(n => { const r = e.length; if (0 === r) return void n.complete(); const s = new Array(r); let i = 0, o = 0; for (let a = 0; a < r; a++) { const c = (0, l.D)(e[a]); let u = !1; n.add(c.subscribe({ next: e => { u || (u = !0, o++), s[a] = e }, error: e => n.error(e), complete: () => { i++, i !== r && u || (o === r && n.next(t ? t.reduce((e, t, n) => (e[t] = s[n], e), {}) : s), n.complete()) } })) } }) } let h = (() => { class e { constructor(e, t) { this._renderer = e, this._elementRef = t, this.onChange = e => { }, this.onTouched = () => { } } setProperty(e, t) { this._renderer.setProperty(this._elementRef.nativeElement, e, t) } registerOnTouched(e) { this.onTouched = e } registerOnChange(e) { this.onChange = e } setDisabledState(e) { this.setProperty("disabled", e) } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(r.Qsj), r.Y36(r.SBq)) }, e.\u0275dir = r.lG2({ type: e }), e })(), d = (() => { class e extends h { } return e.\u0275fac = function () { let t; return function (n) { return (t || (t = r.n5z(e)))(n || e) } }(), e.\u0275dir = r.lG2({ type: e, features: [r.qOj] }), e })(); const f = new r.OlP("NgValueAccessor"), p = { provide: f, useExisting: (0, r.Gpc)(() => g), multi: !0 }, m = new r.OlP("CompositionEventMode"); let g = (() => { class e extends h { constructor(e, t, n) { super(e, t), this._compositionMode = n, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const e = (0, s.q)() ? (0, s.q)().getUserAgent() : ""; return /android (\d+)/.test(e.toLowerCase()) }()) } writeValue(e) { this.setProperty("value", null == e ? "" : e) } _handleInput(e) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(e) } _compositionStart() { this._composing = !0 } _compositionEnd(e) { this._composing = !1, this._compositionMode && this.onChange(e) } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(r.Qsj), r.Y36(r.SBq), r.Y36(m, 8)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (e, t) { 1 & e && r.NdJ("input", function (e) { return t._handleInput(e.target.value) })("blur", function () { return t.onTouched() })("compositionstart", function () { return t._compositionStart() })("compositionend", function (e) { return t._compositionEnd(e.target.value) }) }, features: [r._Bn([p]), r.qOj] }), e })(); function y(e) { return null == e || 0 === e.length } function v(e) { return null != e && "number" == typeof e.length } const w = new r.OlP("NgValidators"), b = new r.OlP("NgAsyncValidators"), _ = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class E { static min(e) { return function (e) { return t => { if (y(t.value) || y(e)) return null; const n = parseFloat(t.value); return !isNaN(n) && n < e ? { min: { min: e, actual: t.value } } : null } }(e) } static max(e) { return function (e) { return t => { if (y(t.value) || y(e)) return null; const n = parseFloat(t.value); return !isNaN(n) && n > e ? { max: { max: e, actual: t.value } } : null } }(e) } static required(e) { return C(e) } static requiredTrue(e) { return function (e) { return !0 === e.value ? null : { required: !0 } }(e) } static email(e) { return function (e) { return y(e.value) || _.test(e.value) ? null : { email: !0 } }(e) } static minLength(e) { return function (e) { return t => y(t.value) || !v(t.value) ? null : t.value.length < e ? { minlength: { requiredLength: e, actualLength: t.value.length } } : null }(e) } static maxLength(e) { return function (e) { return t => v(t.value) && t.value.length > e ? { maxlength: { requiredLength: e, actualLength: t.value.length } } : null }(e) } static pattern(e) { return function (e) { if (!e) return S; let t, n; return "string" == typeof e ? (n = "", "^" !== e.charAt(0) && (n += "^"), n += e, "$" !== e.charAt(e.length - 1) && (n += "$"), t = new RegExp(n)) : (n = e.toString(), t = e), e => { if (y(e.value)) return null; const r = e.value; return t.test(r) ? null : { pattern: { requiredPattern: n, actualValue: r } } } }(e) } static nullValidator(e) { return null } static compose(e) { return D(e) } static composeAsync(e) { return R(e) } } function C(e) { return y(e.value) ? { required: !0 } : null } function S(e) { return null } function T(e) { return null != e } function I(e) { const t = (0, r.QGY)(e) ? (0, l.D)(e) : e; return (0, r.CqO)(t), t } function k(e) { let t = {}; return e.forEach(e => { t = null != e ? Object.assign(Object.assign({}, t), e) : t }), 0 === Object.keys(t).length ? null : t } function A(e, t) { return t.map(t => t(e)) } function x(e) { return e.map(e => function (e) { return !e.validate }(e) ? e : t => e.validate(t)) } function D(e) { if (!e) return null; const t = e.filter(T); return 0 == t.length ? null : function (e) { return k(A(e, t)) } } function O(e) { return null != e ? D(x(e)) : null } function R(e) { if (!e) return null; const t = e.filter(T); return 0 == t.length ? null : function (e) { return function (...e) { if (1 === e.length) { const t = e[0]; if ((0, o.k)(t)) return u(t, null); if ((0, c.K)(t) && Object.getPrototypeOf(t) === Object.prototype) { const e = Object.keys(t); return u(e.map(e => t[e]), e) } } if ("function" == typeof e[e.length - 1]) { const t = e.pop(); return u(e = 1 === e.length && (0, o.k)(e[0]) ? e[0] : e, null).pipe((0, a.U)(e => t(...e))) } return u(e, null) }(A(e, t).map(I)).pipe((0, a.U)(k)) } } function N(e) { return null != e ? R(x(e)) : null } function P(e, t) { return null === e ? [t] : Array.isArray(e) ? [...e, t] : [e, t] } function F(e) { return e._rawValidators } function L(e) { return e._rawAsyncValidators } let M = (() => { class e { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(e) { this._rawValidators = e || [], this._composedValidatorFn = O(this._rawValidators) } _setAsyncValidators(e) { this._rawAsyncValidators = e || [], this._composedAsyncValidatorFn = N(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(e) { this._onDestroyCallbacks.push(e) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(e => e()), this._onDestroyCallbacks = [] } reset(e) { this.control && this.control.reset(e) } hasError(e, t) { return !!this.control && this.control.hasError(e, t) } getError(e, t) { return this.control ? this.control.getError(e, t) : null } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = r.lG2({ type: e }), e })(), $ = (() => { class e extends M { get formDirective() { return null } get path() { return null } } return e.\u0275fac = function () { let t; return function (n) { return (t || (t = r.n5z(e)))(n || e) } }(), e.\u0275dir = r.lG2({ type: e, features: [r.qOj] }), e })(); class B extends M { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class V { constructor(e) { this._cd = e } is(e) { var t, n, r; return "submitted" === e ? !!(null === (t = this._cd) || void 0 === t ? void 0 : t.submitted) : !!(null === (r = null === (n = this._cd) || void 0 === n ? void 0 : n.control) || void 0 === r ? void 0 : r[e]) } } let U = (() => { class e extends V { constructor(e) { super(e) } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(B, 2)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (e, t) { 2 & e && r.ekj("ng-untouched", t.is("untouched"))("ng-touched", t.is("touched"))("ng-pristine", t.is("pristine"))("ng-dirty", t.is("dirty"))("ng-valid", t.is("valid"))("ng-invalid", t.is("invalid"))("ng-pending", t.is("pending")) }, features: [r.qOj] }), e })(), j = (() => { class e extends V { constructor(e) { super(e) } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36($, 10)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (e, t) { 2 & e && r.ekj("ng-untouched", t.is("untouched"))("ng-touched", t.is("touched"))("ng-pristine", t.is("pristine"))("ng-dirty", t.is("dirty"))("ng-valid", t.is("valid"))("ng-invalid", t.is("invalid"))("ng-pending", t.is("pending"))("ng-submitted", t.is("submitted")) }, features: [r.qOj] }), e })(); function q(e, t) { G(e, t), t.valueAccessor.writeValue(e.value), function (e, t) { t.valueAccessor.registerOnChange(n => { e._pendingValue = n, e._pendingChange = !0, e._pendingDirty = !0, "change" === e.updateOn && Y(e, t) }) }(e, t), function (e, t) { const n = (e, n) => { t.valueAccessor.writeValue(e), n && t.viewToModelUpdate(e) }; e.registerOnChange(n), t._registerOnDestroy(() => { e._unregisterOnChange(n) }) }(e, t), function (e, t) { t.valueAccessor.registerOnTouched(() => { e._pendingTouched = !0, "blur" === e.updateOn && e._pendingChange && Y(e, t), "submit" !== e.updateOn && e.markAsTouched() }) }(e, t), function (e, t) { if (t.valueAccessor.setDisabledState) { const n = e => { t.valueAccessor.setDisabledState(e) }; e.registerOnDisabledChange(n), t._registerOnDestroy(() => { e._unregisterOnDisabledChange(n) }) } }(e, t) } function z(e, t, n = !0) { const r = () => { }; t.valueAccessor && (t.valueAccessor.registerOnChange(r), t.valueAccessor.registerOnTouched(r)), W(e, t), e && (t._invokeOnDestroyCallbacks(), e._registerOnCollectionChange(() => { })) } function H(e, t) { e.forEach(e => { e.registerOnValidatorChange && e.registerOnValidatorChange(t) }) } function G(e, t) { const n = F(e); null !== t.validator ? e.setValidators(P(n, t.validator)) : "function" == typeof n && e.setValidators([n]); const r = L(e); null !== t.asyncValidator ? e.setAsyncValidators(P(r, t.asyncValidator)) : "function" == typeof r && e.setAsyncValidators([r]); const s = () => e.updateValueAndValidity(); H(t._rawValidators, s), H(t._rawAsyncValidators, s) } function W(e, t) { let n = !1; if (null !== e) { if (null !== t.validator) { const r = F(e); if (Array.isArray(r) && r.length > 0) { const s = r.filter(e => e !== t.validator); s.length !== r.length && (n = !0, e.setValidators(s)) } } if (null !== t.asyncValidator) { const r = L(e); if (Array.isArray(r) && r.length > 0) { const s = r.filter(e => e !== t.asyncValidator); s.length !== r.length && (n = !0, e.setAsyncValidators(s)) } } } const r = () => { }; return H(t._rawValidators, r), H(t._rawAsyncValidators, r), n } function Y(e, t) { e._pendingDirty && e.markAsDirty(), e.setValue(e._pendingValue, { emitModelToViewChange: !1 }), t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1 } function K(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const X = "VALID", Z = "INVALID", Q = "PENDING", J = "DISABLED"; function ee(e) { return (se(e) ? e.validators : e) || null } function te(e) { return Array.isArray(e) ? O(e) : e || null } function ne(e, t) { return (se(t) ? t.asyncValidators : e) || null } function re(e) { return Array.isArray(e) ? N(e) : e || null } function se(e) { return null != e && !Array.isArray(e) && "object" == typeof e } class ie { constructor(e, t) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = e, this._rawAsyncValidators = t, this._composedValidatorFn = te(this._rawValidators), this._composedAsyncValidatorFn = re(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(e) { this._rawValidators = this._composedValidatorFn = e } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(e) { this._rawAsyncValidators = this._composedAsyncValidatorFn = e } get parent() { return this._parent } get valid() { return this.status === X } get invalid() { return this.status === Z } get pending() { return this.status == Q } get disabled() { return this.status === J } get enabled() { return this.status !== J } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(e) { this._rawValidators = e, this._composedValidatorFn = te(e) } setAsyncValidators(e) { this._rawAsyncValidators = e, this._composedAsyncValidatorFn = re(e) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(e = {}) { this.touched = !0, this._parent && !e.onlySelf && this._parent.markAsTouched(e) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(e => e.markAllAsTouched()) } markAsUntouched(e = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(e => { e.markAsUntouched({ onlySelf: !0 }) }), this._parent && !e.onlySelf && this._parent._updateTouched(e) } markAsDirty(e = {}) { this.pristine = !1, this._parent && !e.onlySelf && this._parent.markAsDirty(e) } markAsPristine(e = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(e => { e.markAsPristine({ onlySelf: !0 }) }), this._parent && !e.onlySelf && this._parent._updatePristine(e) } markAsPending(e = {}) { this.status = Q, !1 !== e.emitEvent && this.statusChanges.emit(this.status), this._parent && !e.onlySelf && this._parent.markAsPending(e) } disable(e = {}) { const t = this._parentMarkedDirty(e.onlySelf); this.status = J, this.errors = null, this._forEachChild(t => { t.disable(Object.assign(Object.assign({}, e), { onlySelf: !0 })) }), this._updateValue(), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, e), { skipPristineCheck: t })), this._onDisabledChange.forEach(e => e(!0)) } enable(e = {}) { const t = this._parentMarkedDirty(e.onlySelf); this.status = X, this._forEachChild(t => { t.enable(Object.assign(Object.assign({}, e), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: e.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, e), { skipPristineCheck: t })), this._onDisabledChange.forEach(e => e(!1)) } _updateAncestors(e) { this._parent && !e.onlySelf && (this._parent.updateValueAndValidity(e), e.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(e) { this._parent = e } updateValueAndValidity(e = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== X && this.status !== Q || this._runAsyncValidator(e.emitEvent)), !1 !== e.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !e.onlySelf && this._parent.updateValueAndValidity(e) } _updateTreeValidity(e = { emitEvent: !0 }) { this._forEachChild(t => t._updateTreeValidity(e)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: e.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? J : X } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(e) { if (this.asyncValidator) { this.status = Q, this._hasOwnPendingAsyncValidator = !0; const t = I(this.asyncValidator(this)); this._asyncValidationSubscription = t.subscribe(t => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(t, { emitEvent: e }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(e, t = {}) { this.errors = e, this._updateControlsErrors(!1 !== t.emitEvent) } get(e) { return function (e, t, n) { if (null == t) return null; if (Array.isArray(t) || (t = t.split(".")), Array.isArray(t) && 0 === t.length) return null; let r = e; return t.forEach(e => { r = r instanceof ae ? r.controls.hasOwnProperty(e) ? r.controls[e] : null : r instanceof ce && r.at(e) || null }), r }(this, e) } getError(e, t) { const n = t ? this.get(t) : this; return n && n.errors ? n.errors[e] : null } hasError(e, t) { return !!this.getError(e, t) } get root() { let e = this; for (; e._parent;)e = e._parent; return e } _updateControlsErrors(e) { this.status = this._calculateStatus(), e && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(e) } _initObservables() { this.valueChanges = new r.vpe, this.statusChanges = new r.vpe } _calculateStatus() { return this._allControlsDisabled() ? J : this.errors ? Z : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(Q) ? Q : this._anyControlsHaveStatus(Z) ? Z : X } _anyControlsHaveStatus(e) { return this._anyControls(t => t.status === e) } _anyControlsDirty() { return this._anyControls(e => e.dirty) } _anyControlsTouched() { return this._anyControls(e => e.touched) } _updatePristine(e = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !e.onlySelf && this._parent._updatePristine(e) } _updateTouched(e = {}) { this.touched = this._anyControlsTouched(), this._parent && !e.onlySelf && this._parent._updateTouched(e) } _isBoxedValue(e) { return "object" == typeof e && null !== e && 2 === Object.keys(e).length && "value" in e && "disabled" in e } _registerOnCollectionChange(e) { this._onCollectionChange = e } _setUpdateStrategy(e) { se(e) && null != e.updateOn && (this._updateOn = e.updateOn) } _parentMarkedDirty(e) { return !e && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class oe extends ie { constructor(e = null, t, n) { super(ee(t), ne(n, t)), this._onChange = [], this._applyFormState(e), this._setUpdateStrategy(t), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } setValue(e, t = {}) { this.value = this._pendingValue = e, this._onChange.length && !1 !== t.emitModelToViewChange && this._onChange.forEach(e => e(this.value, !1 !== t.emitViewToModelChange)), this.updateValueAndValidity(t) } patchValue(e, t = {}) { this.setValue(e, t) } reset(e = null, t = {}) { this._applyFormState(e), this.markAsPristine(t), this.markAsUntouched(t), this.setValue(this.value, t), this._pendingChange = !1 } _updateValue() { } _anyControls(e) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(e) { this._onChange.push(e) } _unregisterOnChange(e) { K(this._onChange, e) } registerOnDisabledChange(e) { this._onDisabledChange.push(e) } _unregisterOnDisabledChange(e) { K(this._onDisabledChange, e) } _forEachChild(e) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(e) { this._isBoxedValue(e) ? (this.value = this._pendingValue = e.value, e.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = e } } class ae extends ie { constructor(e, t, n) { super(ee(t), ne(n, t)), this.controls = e, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(e, t) { return this.controls[e] ? this.controls[e] : (this.controls[e] = t, t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange), t) } addControl(e, t, n = {}) { this.registerControl(e, t), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } removeControl(e, t = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), delete this.controls[e], this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } setControl(e, t, n = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), delete this.controls[e], t && this.registerControl(e, t), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } contains(e) { return this.controls.hasOwnProperty(e) && this.controls[e].enabled } setValue(e, t = {}) { this._checkAllValuesPresent(e), Object.keys(e).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(e[n], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(e, t = {}) { null != e && (Object.keys(e).forEach(n => { this.controls[n] && this.controls[n].patchValue(e[n], { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(e = {}, t = {}) { this._forEachChild((n, r) => { n.reset(e[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this._reduceChildren({}, (e, t, n) => (e[n] = t instanceof oe ? t.value : t.getRawValue(), e)) } _syncPendingControls() { let e = this._reduceChildren(!1, (e, t) => !!t._syncPendingControls() || e); return e && this.updateValueAndValidity({ onlySelf: !0 }), e } _throwIfControlMissing(e) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[e]) throw new Error(`Cannot find form control with name: ${e}.`) } _forEachChild(e) { Object.keys(this.controls).forEach(t => { const n = this.controls[t]; n && e(n, t) }) } _setUpControls() { this._forEachChild(e => { e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(e) { for (const t of Object.keys(this.controls)) { const n = this.controls[t]; if (this.contains(t) && e(n)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (e, t, n) => ((t.enabled || this.disabled) && (e[n] = t.value), e)) } _reduceChildren(e, t) { let n = e; return this._forEachChild((e, r) => { n = t(n, e, r) }), n } _allControlsDisabled() { for (const e of Object.keys(this.controls)) if (this.controls[e].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(e) { this._forEachChild((t, n) => { if (void 0 === e[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class ce extends ie { constructor(e, t, n) { super(ee(t), ne(n, t)), this.controls = e, this._initObservables(), this._setUpdateStrategy(t), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } at(e) { return this.controls[e] } push(e, t = {}) { this.controls.push(e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: t.emitEvent }), this._onCollectionChange() } insert(e, t, n = {}) { this.controls.splice(e, 0, t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } removeAt(e, t = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), this.controls.splice(e, 1), this.updateValueAndValidity({ emitEvent: t.emitEvent }) } setControl(e, t, n = {}) { this.controls[e] && this.controls[e]._registerOnCollectionChange(() => { }), this.controls.splice(e, 1), t && (this.controls.splice(e, 0, t), this._registerControl(t)), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(e, t = {}) { this._checkAllValuesPresent(e), e.forEach((e, n) => { this._throwIfControlMissing(n), this.at(n).setValue(e, { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t) } patchValue(e, t = {}) { null != e && (e.forEach((e, n) => { this.at(n) && this.at(n).patchValue(e, { onlySelf: !0, emitEvent: t.emitEvent }) }), this.updateValueAndValidity(t)) } reset(e = [], t = {}) { this._forEachChild((n, r) => { n.reset(e[r], { onlySelf: !0, emitEvent: t.emitEvent }) }), this._updatePristine(t), this._updateTouched(t), this.updateValueAndValidity(t) } getRawValue() { return this.controls.map(e => e instanceof oe ? e.value : e.getRawValue()) } clear(e = {}) { this.controls.length < 1 || (this._forEachChild(e => e._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: e.emitEvent })) } _syncPendingControls() { let e = this.controls.reduce((e, t) => !!t._syncPendingControls() || e, !1); return e && this.updateValueAndValidity({ onlySelf: !0 }), e } _throwIfControlMissing(e) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(e)) throw new Error(`Cannot find form control at index ${e}`) } _forEachChild(e) { this.controls.forEach((t, n) => { e(t, n) }) } _updateValue() { this.value = this.controls.filter(e => e.enabled || this.disabled).map(e => e.value) } _anyControls(e) { return this.controls.some(t => t.enabled && e(t)) } _setUpControls() { this._forEachChild(e => this._registerControl(e)) } _checkAllValuesPresent(e) { this._forEachChild((t, n) => { if (void 0 === e[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const e of this.controls) if (e.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(e) { e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange) } } let le = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = r.lG2({ type: e, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), e })(), ue = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({}), e })(); const he = new r.OlP("NgModelWithFormControlWarning"), de = { provide: $, useExisting: (0, r.Gpc)(() => fe) }; let fe = (() => { class e extends $ { constructor(e, t) { super(), this.validators = e, this.asyncValidators = t, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new r.vpe, this._setValidators(e), this._setAsyncValidators(t) } ngOnChanges(e) { this._checkFormPresent(), e.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (W(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(e) { const t = this.form.get(e.path); return q(t, e), t.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(e), t } getControl(e) { return this.form.get(e.path) } removeControl(e) { z(e.control || null, e, !1), K(this.directives, e) } addFormGroup(e) { this._setUpFormContainer(e) } removeFormGroup(e) { this._cleanUpFormContainer(e) } getFormGroup(e) { return this.form.get(e.path) } addFormArray(e) { this._setUpFormContainer(e) } removeFormArray(e) { this._cleanUpFormContainer(e) } getFormArray(e) { return this.form.get(e.path) } updateModel(e, t) { this.form.get(e.path).setValue(t) } onSubmit(e) { return this.submitted = !0, t = this.directives, this.form._syncPendingControls(), t.forEach(e => { const t = e.control; "submit" === t.updateOn && t._pendingChange && (e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1) }), this.ngSubmit.emit(e), !1; var t } onReset() { this.resetForm() } resetForm(e) { this.form.reset(e), this.submitted = !1 } _updateDomValue() { this.directives.forEach(e => { const t = e.control, n = this.form.get(e.path); t !== n && (z(t || null, e), n instanceof oe && (q(n, e), e.control = n)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(e) { const t = this.form.get(e.path); (function (e, t) { G(e, t) })(t, e), t.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(e) { if (this.form) { const t = this.form.get(e.path); t && function (e, t) { return W(e, t) }(t, e) && t.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { G(this.form, this), this._oldForm && W(this._oldForm, this) } _checkFormPresent() { } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36(w, 10), r.Y36(b, 10)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "formGroup", ""]], hostBindings: function (e, t) { 1 & e && r.NdJ("submit", function (e) { return t.onSubmit(e) })("reset", function () { return t.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [r._Bn([de]), r.qOj, r.TTD] }), e })(); const pe = { provide: B, useExisting: (0, r.Gpc)(() => me) }; let me = (() => { class e extends B { constructor(e, t, n, s, i) { super(), this._ngModelWarningConfig = i, this._added = !1, this.update = new r.vpe, this._ngModelWarningSent = !1, this._parent = e, this._setValidators(t), this._setAsyncValidators(n), this.valueAccessor = function (e, t) { if (!t) return null; let n, r, s; return Array.isArray(t), t.forEach(e => { e.constructor === g ? n = e : Object.getPrototypeOf(e.constructor) === d ? r = e : s = e }), s || r || n || null }(0, s) } set isDisabled(e) { } ngOnChanges(e) { this._added || this._setUpControl(), function (e, t) { if (!e.hasOwnProperty("model")) return !1; const n = e.model; return !!n.isFirstChange() || !Object.is(t, n.currentValue) }(e, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(e) { this.viewModel = e, this.update.emit(e) } get path() { return e = null == this.name ? this.name : this.name.toString(), [...this._parent.path, e]; var e } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this.control.disabled && this.valueAccessor.setDisabledState && this.valueAccessor.setDisabledState(!0), this._added = !0 } } return e.\u0275fac = function (t) { return new (t || e)(r.Y36($, 13), r.Y36(w, 10), r.Y36(b, 10), r.Y36(f, 10), r.Y36(he, 8)) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "formControlName", ""]], inputs: { isDisabled: ["disabled", "isDisabled"], name: ["formControlName", "name"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [r._Bn([pe]), r.qOj, r.TTD] }), e._ngModelWarningSentOnce = !1, e })(); const ge = { provide: w, useExisting: (0, r.Gpc)(() => ye), multi: !0 }; let ye = (() => { class e { constructor() { this._required = !1 } get required() { return this._required } set required(e) { this._required = null != e && !1 !== e && "false" != `${e}`, this._onChange && this._onChange() } validate(e) { return this.required ? C(e) : null } registerOnValidatorChange(e) { this._onChange = e } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275dir = r.lG2({ type: e, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (e, t) { 2 & e && r.uIk("required", t.required ? "" : null) }, inputs: { required: "required" }, features: [r._Bn([ge])] }), e })(), ve = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ imports: [[ue]] }), e })(), we = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ imports: [ve] }), e })(), be = (() => { class e { static withConfig(t) { return { ngModule: e, providers: [{ provide: he, useValue: t.warnOnNgModelWithFormControl }] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = r.oAB({ type: e }), e.\u0275inj = r.cJS({ imports: [ve] }), e })() }, 9075: (e, t, n) => { "use strict"; n.d(t, { b2: () => $, H7: () => N, q6: () => L }); var r = n(8583), s = n(8720); class i extends r.w_ { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class o extends i { static makeCurrent() { (0, r.HT)(new o) } onAndCancel(e, t, n) { return e.addEventListener(t, n, !1), () => { e.removeEventListener(t, n, !1) } } dispatchEvent(e, t) { e.dispatchEvent(t) } remove(e) { e.parentNode && e.parentNode.removeChild(e) } createElement(e, t) { return (t = t || this.getDefaultDocument()).createElement(e) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(e) { return e.nodeType === Node.ELEMENT_NODE } isShadowRoot(e) { return e instanceof DocumentFragment } getGlobalEventTarget(e, t) { return "window" === t ? window : "document" === t ? e : "body" === t ? e.body : null } getBaseHref(e) { const t = (c = c || document.querySelector("base"), c ? c.getAttribute("href") : null); return null == t ? null : function (e) { a = a || document.createElement("a"), a.setAttribute("href", e); const t = a.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(t) } resetBaseElement() { c = null } getUserAgent() { return window.navigator.userAgent } getCookie(e) { return (0, r.Mx)(document.cookie, e) } } let a, c = null; const l = new s.OlP("TRANSITION_ID"), u = [{ provide: s.ip1, useFactory: function (e, t, n) { return () => { n.get(s.CZH).donePromise.then(() => { const n = (0, r.q)(); Array.prototype.slice.apply(t.querySelectorAll("style[ng-transition]")).filter(t => t.getAttribute("ng-transition") === e).forEach(e => n.remove(e)) }) } }, deps: [l, r.K0, s.zs3], multi: !0 }]; class h { static init() { (0, s.VLi)(new h) } addToWindow(e) { s.dqk.getAngularTestability = (t, n = !0) => { const r = e.findTestabilityInTree(t, n); if (null == r) throw new Error("Could not find testability for element."); return r }, s.dqk.getAllAngularTestabilities = () => e.getAllTestabilities(), s.dqk.getAllAngularRootElements = () => e.getAllRootElements(), s.dqk.frameworkStabilizers || (s.dqk.frameworkStabilizers = []), s.dqk.frameworkStabilizers.push(e => { const t = s.dqk.getAllAngularTestabilities(); let n = t.length, r = !1; const i = function (t) { r = r || t, n--, 0 == n && e(r) }; t.forEach(function (e) { e.whenStable(i) }) }) } findTestabilityInTree(e, t, n) { if (null == t) return null; const s = e.getTestability(t); return null != s ? s : n ? (0, r.q)().isShadowRoot(t) ? this.findTestabilityInTree(e, t.host, !0) : this.findTestabilityInTree(e, t.parentElement, !0) : null } } let d = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); const f = new s.OlP("EventManagerPlugins"); let p = (() => { class e { constructor(e, t) { this._zone = t, this._eventNameToPlugin = new Map, e.forEach(e => e.manager = this), this._plugins = e.slice().reverse() } addEventListener(e, t, n) { return this._findPluginFor(t).addEventListener(e, t, n) } addGlobalEventListener(e, t, n) { return this._findPluginFor(t).addGlobalEventListener(e, t, n) } getZone() { return this._zone } _findPluginFor(e) { const t = this._eventNameToPlugin.get(e); if (t) return t; const n = this._plugins; for (let r = 0; r < n.length; r++) { const t = n[r]; if (t.supports(e)) return this._eventNameToPlugin.set(e, t), t } throw new Error(`No event manager plugin found for event ${e}`) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(f), s.LFG(s.R0b)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); class m { constructor(e) { this._doc = e } addGlobalEventListener(e, t, n) { const s = (0, r.q)().getGlobalEventTarget(this._doc, e); if (!s) throw new Error(`Unsupported event target ${s} for event ${t}`); return this.addEventListener(s, t, n) } } let g = (() => { class e { constructor() { this._stylesSet = new Set } addStyles(e) { const t = new Set; e.forEach(e => { this._stylesSet.has(e) || (this._stylesSet.add(e), t.add(e)) }), this.onStylesAdded(t) } onStylesAdded(e) { } getAllStyles() { return Array.from(this._stylesSet) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), y = (() => { class e extends g { constructor(e) { super(), this._doc = e, this._hostNodes = new Map, this._hostNodes.set(e.head, []) } _addStylesToHost(e, t, n) { e.forEach(e => { const r = this._doc.createElement("style"); r.textContent = e, n.push(t.appendChild(r)) }) } addHost(e) { const t = []; this._addStylesToHost(this._stylesSet, e, t), this._hostNodes.set(e, t) } removeHost(e) { const t = this._hostNodes.get(e); t && t.forEach(v), this._hostNodes.delete(e) } onStylesAdded(e) { this._hostNodes.forEach((t, n) => { this._addStylesToHost(e, n, t) }) } ngOnDestroy() { this._hostNodes.forEach(e => e.forEach(v)) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(r.K0)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); function v(e) { (0, r.q)().remove(e) } const w = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, b = /%COMP%/g; function _(e, t, n) { for (let r = 0; r < t.length; r++) { let s = t[r]; Array.isArray(s) ? _(e, s, n) : (s = s.replace(b, e), n.push(s)) } return n } function E(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let C = (() => { class e { constructor(e, t, n) { this.eventManager = e, this.sharedStylesHost = t, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new S(e) } createRenderer(e, t) { if (!e || !t) return this.defaultRenderer; switch (t.encapsulation) { case s.ifc.Emulated: { let n = this.rendererByCompId.get(t.id); return n || (n = new T(this.eventManager, this.sharedStylesHost, t, this.appId), this.rendererByCompId.set(t.id, n)), n.applyToHost(e), n } case 1: case s.ifc.ShadowDom: return new I(this.eventManager, this.sharedStylesHost, e, t); default: if (!this.rendererByCompId.has(t.id)) { const e = _(t.id, t.styles, []); this.sharedStylesHost.addStyles(e), this.rendererByCompId.set(t.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(p), s.LFG(y), s.LFG(s.AFp)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); class S { constructor(e) { this.eventManager = e, this.data = Object.create(null) } destroy() { } createElement(e, t) { return t ? document.createElementNS(w[t] || t, e) : document.createElement(e) } createComment(e) { return document.createComment(e) } createText(e) { return document.createTextNode(e) } appendChild(e, t) { e.appendChild(t) } insertBefore(e, t, n) { e && e.insertBefore(t, n) } removeChild(e, t) { e && e.removeChild(t) } selectRootElement(e, t) { let n = "string" == typeof e ? document.querySelector(e) : e; if (!n) throw new Error(`The selector "${e}" did not match any elements`); return t || (n.textContent = ""), n } parentNode(e) { return e.parentNode } nextSibling(e) { return e.nextSibling } setAttribute(e, t, n, r) { if (r) { t = r + ":" + t; const s = w[r]; s ? e.setAttributeNS(s, t, n) : e.setAttribute(t, n) } else e.setAttribute(t, n) } removeAttribute(e, t, n) { if (n) { const r = w[n]; r ? e.removeAttributeNS(r, t) : e.removeAttribute(`${n}:${t}`) } else e.removeAttribute(t) } addClass(e, t) { e.classList.add(t) } removeClass(e, t) { e.classList.remove(t) } setStyle(e, t, n, r) { r & (s.JOm.DashCase | s.JOm.Important) ? e.style.setProperty(t, n, r & s.JOm.Important ? "important" : "") : e.style[t] = n } removeStyle(e, t, n) { n & s.JOm.DashCase ? e.style.removeProperty(t) : e.style[t] = "" } setProperty(e, t, n) { e[t] = n } setValue(e, t) { e.nodeValue = t } listen(e, t, n) { return "string" == typeof e ? this.eventManager.addGlobalEventListener(e, t, E(n)) : this.eventManager.addEventListener(e, t, E(n)) } } class T extends S { constructor(e, t, n, r) { super(e), this.component = n; const s = _(r + "-" + n.id, n.styles, []); t.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(b, r + "-" + n.id), this.hostAttr = "_nghost-%COMP%".replace(b, r + "-" + n.id) } applyToHost(e) { super.setAttribute(e, this.hostAttr, "") } createElement(e, t) { const n = super.createElement(e, t); return super.setAttribute(n, this.contentAttr, ""), n } } class I extends S { constructor(e, t, n, r) { super(e), this.sharedStylesHost = t, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = _(r.id, r.styles, []); for (let i = 0; i < s.length; i++) { const e = document.createElement("style"); e.textContent = s[i], this.shadowRoot.appendChild(e) } } nodeOrShadowRoot(e) { return e === this.hostEl ? this.shadowRoot : e } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(e, t) { return super.appendChild(this.nodeOrShadowRoot(e), t) } insertBefore(e, t, n) { return super.insertBefore(this.nodeOrShadowRoot(e), t, n) } removeChild(e, t) { return super.removeChild(this.nodeOrShadowRoot(e), t) } parentNode(e) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(e))) } } let k = (() => { class e extends m { constructor(e) { super(e) } supports(e) { return !0 } addEventListener(e, t, n) { return e.addEventListener(t, n, !1), () => this.removeEventListener(e, t, n) } removeEventListener(e, t, n) { return e.removeEventListener(t, n) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(r.K0)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); const A = ["alt", "control", "meta", "shift"], x = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, D = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, O = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let R = (() => { class e extends m { constructor(e) { super(e) } supports(t) { return null != e.parseEventName(t) } addEventListener(t, n, s) { const i = e.parseEventName(n), o = e.eventCallback(i.fullKey, s, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => (0, r.q)().onAndCancel(t, i.domEventName, o)) } static parseEventName(t) { const n = t.toLowerCase().split("."), r = n.shift(); if (0 === n.length || "keydown" !== r && "keyup" !== r) return null; const s = e._normalizeKey(n.pop()); let i = ""; if (A.forEach(e => { const t = n.indexOf(e); t > -1 && (n.splice(t, 1), i += e + ".") }), i += s, 0 != n.length || 0 === s.length) return null; const o = {}; return o.domEventName = r, o.fullKey = i, o } static getEventFullKey(e) { let t = "", n = function (e) { let t = e.key; if (null == t) { if (t = e.keyIdentifier, null == t) return "Unidentified"; t.startsWith("U+") && (t = String.fromCharCode(parseInt(t.substring(2), 16)), 3 === e.location && D.hasOwnProperty(t) && (t = D[t])) } return x[t] || t }(e); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), A.forEach(r => { r != n && (0, O[r])(e) && (t += r + ".") }), t += n, t } static eventCallback(t, n, r) { return s => { e.getEventFullKey(s) === t && r.runGuarded(() => n(s)) } } static _normalizeKey(e) { switch (e) { case "esc": return "escape"; default: return e } } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(r.K0)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), N = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = (0, s.Yz7)({ factory: function () { return (0, s.LFG)(F) }, token: e, providedIn: "root" }), e })(); function P(e) { return new F(e.get(r.K0)) } let F = (() => { class e extends N { constructor(e) { super(), this._doc = e } sanitize(e, t) { if (null == t) return null; switch (e) { case s.q3G.NONE: return t; case s.q3G.HTML: return (0, s.qzn)(t, "HTML") ? (0, s.z3N)(t) : (0, s.EiD)(this._doc, String(t)).toString(); case s.q3G.STYLE: return (0, s.qzn)(t, "Style") ? (0, s.z3N)(t) : t; case s.q3G.SCRIPT: if ((0, s.qzn)(t, "Script")) return (0, s.z3N)(t); throw new Error("unsafe value used in a script context"); case s.q3G.URL: return (0, s.yhl)(t), (0, s.qzn)(t, "URL") ? (0, s.z3N)(t) : (0, s.mCW)(String(t)); case s.q3G.RESOURCE_URL: if ((0, s.qzn)(t, "ResourceURL")) return (0, s.z3N)(t); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${e} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(e) { return (0, s.JVY)(e) } bypassSecurityTrustStyle(e) { return (0, s.L6k)(e) } bypassSecurityTrustScript(e) { return (0, s.eBb)(e) } bypassSecurityTrustUrl(e) { return (0, s.LAX)(e) } bypassSecurityTrustResourceUrl(e) { return (0, s.pB0)(e) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(r.K0)) }, e.\u0275prov = (0, s.Yz7)({ factory: function () { return P((0, s.LFG)(s.gxx)) }, token: e, providedIn: "root" }), e })(); const L = (0, s.eFA)(s._c5, "browser", [{ provide: s.Lbi, useValue: r.bD }, { provide: s.g9A, useValue: function () { o.makeCurrent(), h.init() }, multi: !0 }, { provide: r.K0, useFactory: function () { return (0, s.RDi)(document), document }, deps: [] }]), M = [[], { provide: s.zSh, useValue: "root" }, { provide: s.qLn, useFactory: function () { return new s.qLn }, deps: [] }, { provide: f, useClass: k, multi: !0, deps: [r.K0, s.R0b, s.Lbi] }, { provide: f, useClass: R, multi: !0, deps: [r.K0] }, [], { provide: C, useClass: C, deps: [p, y, s.AFp] }, { provide: s.FYo, useExisting: C }, { provide: g, useExisting: y }, { provide: y, useClass: y, deps: [r.K0] }, { provide: s.dDg, useClass: s.dDg, deps: [s.R0b] }, { provide: p, useClass: p, deps: [f, s.R0b] }, { provide: r.JF, useClass: d, deps: [] }, []]; let $ = (() => { class e { constructor(e) { if (e) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(t) { return { ngModule: e, providers: [{ provide: s.AFp, useValue: t.appId }, { provide: l, useExisting: s.AFp }, u] } } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(e, 12)) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({ providers: M, imports: [r.ez, s.hGG] }), e })(); "undefined" != typeof window && window }, 4026: (e, t, n) => { "use strict"; n.d(t, { gz: () => nt, y6: () => wn, OD: () => X, eC: () => de, wm: () => Rn, wN: () => pn, F0: () => In, rH: () => kn, Bz: () => Vn, Hx: () => Ne }); var r = n(8583), s = n(8720), i = n(4869), o = n(9796), a = n(7393); class c extends a.L { notifyNext(e, t, n, r, s) { this.destination.next(t) } notifyError(e, t) { this.destination.error(e) } notifyComplete(e) { this.destination.complete() } } class l extends a.L { constructor(e, t, n) { super(), this.parent = e, this.outerValue = t, this.outerIndex = n, this.index = 0 } _next(e) { this.parent.notifyNext(this.outerValue, e, this.outerIndex, this.index++, this) } _error(e) { this.parent.notifyError(e, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } var u = n(7444), h = n(8891); function d(e, t, n, r, s = new l(e, n, r)) { if (!s.closed) return t instanceof h.y ? t.subscribe(s) : (0, u.s)(t)(s) } var f = n(6693); const p = {}; class m { constructor(e) { this.resultSelector = e } call(e, t) { return t.subscribe(new g(e, this.resultSelector)) } } class g extends c { constructor(e, t) { super(e), this.resultSelector = t, this.active = 0, this.values = [], this.observables = [] } _next(e) { this.values.push(p), this.observables.push(e) } _complete() { const e = this.observables, t = e.length; if (0 === t) this.destination.complete(); else { this.active = t, this.toRespond = t; for (let n = 0; n < t; n++)this.add(d(this, e[n], void 0, n)) } } notifyComplete(e) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(e, t, n) { const r = this.values, s = this.toRespond ? r[n] === p ? --this.toRespond : this.toRespond : 0; r[n] = t, 0 === s && (this.resultSelector ? this._tryResultSelector(r) : this.destination.next(r.slice())) } _tryResultSelector(e) { let t; try { t = this.resultSelector.apply(this, e) } catch (n) { return void this.destination.error(n) } this.destination.next(t) } } var y = n(4402), v = n(5917), w = n(6215), b = n(3410), _ = n(8071), E = n(1439), C = n(9193), S = n(2441), T = n(9765), I = n(5435), k = n(7108); function A(e) { return function (t) { return 0 === e ? (0, C.c)() : t.lift(new x(e)) } } class x { constructor(e) { if (this.total = e, this.total < 0) throw new k.W } call(e, t) { return t.subscribe(new D(e, this.total)) } } class D extends a.L { constructor(e, t) { super(e), this.total = t, this.ring = new Array, this.count = 0 } _next(e) { const t = this.ring, n = this.total, r = this.count++; t.length < n ? t.push(e) : t[r % n] = e } _complete() { const e = this.destination; let t = this.count; if (t > 0) { const n = this.count >= this.total ? this.total : this.count, r = this.ring; for (let s = 0; s < n; s++) { const s = t++ % n; e.next(r[s]) } } e.complete() } } var O = n(4635), R = n(5242), N = n(4487), P = n(5319); class F { constructor(e) { this.callback = e } call(e, t) { return t.subscribe(new L(e, this.callback)) } } class L extends a.L { constructor(e, t) { super(e), this.add(new P.w(t)) } } var M = n(8002), $ = n(3190), B = n(5257), V = n(9761), U = n(2145), j = n(5304), q = n(4612), z = n(8049), H = n(9773), G = n(8307), W = n(1307), Y = n(3282); class K { constructor(e, t) { this.id = e, this.url = t } } class X extends K { constructor(e, t, n = "imperative", r = null) { super(e, t), this.navigationTrigger = n, this.restoredState = r } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Z extends K { constructor(e, t, n) { super(e, t), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Q extends K { constructor(e, t, n) { super(e, t), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class J extends K { constructor(e, t, n) { super(e, t), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class ee extends K { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class te extends K { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class ne extends K { constructor(e, t, n, r, s) { super(e, t), this.urlAfterRedirects = n, this.state = r, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class re extends K { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class se extends K { constructor(e, t, n, r) { super(e, t), this.urlAfterRedirects = n, this.state = r } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class ie { constructor(e) { this.route = e } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class oe { constructor(e) { this.route = e } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class ae { constructor(e) { this.snapshot = e } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ce { constructor(e) { this.snapshot = e } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class le { constructor(e) { this.snapshot = e } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ue { constructor(e) { this.snapshot = e } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class he { constructor(e, t, n) { this.routerEvent = e, this.position = t, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const de = "primary"; class fe { constructor(e) { this.params = e || {} } has(e) { return Object.prototype.hasOwnProperty.call(this.params, e) } get(e) { if (this.has(e)) { const t = this.params[e]; return Array.isArray(t) ? t[0] : t } return null } getAll(e) { if (this.has(e)) { const t = this.params[e]; return Array.isArray(t) ? t : [t] } return [] } get keys() { return Object.keys(this.params) } } function pe(e) { return new fe(e) } function me(e) { const t = Error("NavigationCancelingError: " + e); return t.ngNavigationCancelingError = !0, t } function ge(e, t, n) { const r = n.path.split("/"); if (r.length > e.length) return null; if ("full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const s = {}; for (let i = 0; i < r.length; i++) { const t = r[i], n = e[i]; if (t.startsWith(":")) s[t.substring(1)] = n; else if (t !== n.path) return null } return { consumed: e.slice(0, r.length), posParams: s } } function ye(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let s; for (let i = 0; i < n.length; i++)if (s = n[i], !ve(e[s], t[s])) return !1; return !0 } function ve(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((e, t) => r[t] === e) } return e === t } function we(e) { return Array.prototype.concat.apply([], e) } function be(e) { return e.length > 0 ? e[e.length - 1] : null } function _e(e, t) { for (const n in e) e.hasOwnProperty(n) && t(e[n], n) } function Ee(e) { return (0, s.CqO)(e) ? e : (0, s.QGY)(e) ? (0, y.D)(Promise.resolve(e)) : (0, v.of)(e) } const Ce = { exact: function e(t, n, r) { if (!Re(t.segments, n.segments)) return !1; if (!Ae(t.segments, n.segments, r)) return !1; if (t.numberOfChildren !== n.numberOfChildren) return !1; for (const s in n.children) { if (!t.children[s]) return !1; if (!e(t.children[s], n.children[s], r)) return !1 } return !0 }, subset: Ie }, Se = { exact: function (e, t) { return ye(e, t) }, subset: function (e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => ve(e[n], t[n])) }, ignored: () => !0 }; function Te(e, t, n) { return Ce[n.paths](e.root, t.root, n.matrixParams) && Se[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function Ie(e, t, n) { return ke(e, t, t.segments, n) } function ke(e, t, n, r) { if (e.segments.length > n.length) { const s = e.segments.slice(0, n.length); return !!Re(s, n) && !t.hasChildren() && !!Ae(s, n, r) } if (e.segments.length === n.length) { if (!Re(e.segments, n)) return !1; if (!Ae(e.segments, n, r)) return !1; for (const n in t.children) { if (!e.children[n]) return !1; if (!Ie(e.children[n], t.children[n], r)) return !1 } return !0 } { const s = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !!Re(e.segments, s) && !!Ae(e.segments, s, r) && !!e.children[de] && ke(e.children[de], t, i, r) } } function Ae(e, t, n) { return t.every((t, r) => Se[n](e[r].parameters, t.parameters)) } class xe { constructor(e, t, n) { this.root = e, this.queryParams = t, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = pe(this.queryParams)), this._queryParamMap } toString() { return Fe.serialize(this) } } class De { constructor(e, t) { this.segments = e, this.children = t, this.parent = null, _e(t, (e, t) => e.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Le(this) } } class Oe { constructor(e, t) { this.path = e, this.parameters = t } get parameterMap() { return this._parameterMap || (this._parameterMap = pe(this.parameters)), this._parameterMap } toString() { return qe(this) } } function Re(e, t) { return e.length === t.length && e.every((e, n) => e.path === t[n].path) } class Ne { } class Pe { parse(e) { const t = new Ye(e); return new xe(t.parseRootSegment(), t.parseQueryParams(), t.parseFragment()) } serialize(e) { var t; return `/${Me(e.root, !0)}${function (e) { const t = Object.keys(e).map(t => { const n = e[t]; return Array.isArray(n) ? n.map(e => `${Be(t)}=${Be(e)}`).join("&") : `${Be(t)}=${Be(n)}` }).filter(e => !!e); return t.length ? `?${t.join("&")}` : "" }(e.queryParams)}${"string" == typeof e.fragment ? `#${t = e.fragment, encodeURI(t)}` : ""}` } } const Fe = new Pe; function Le(e) { return e.segments.map(e => qe(e)).join("/") } function Me(e, t) { if (!e.hasChildren()) return Le(e); if (t) { const t = e.children[de] ? Me(e.children[de], !1) : "", n = []; return _e(e.children, (e, t) => { t !== de && n.push(`${t}:${Me(e, !1)}`) }), n.length > 0 ? `${t}(${n.join("//")})` : t } { const t = function (e, t) { let n = []; return _e(e.children, (e, r) => { r === de && (n = n.concat(t(e, r))) }), _e(e.children, (e, r) => { r !== de && (n = n.concat(t(e, r))) }), n }(e, (t, n) => n === de ? [Me(e.children[de], !1)] : [`${n}:${Me(t, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[de] ? `${Le(e)}/${t[0]}` : `${Le(e)}/(${t.join("//")})` } } function $e(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Be(e) { return $e(e).replace(/%3B/gi, ";") } function Ve(e) { return $e(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Ue(e) { return decodeURIComponent(e) } function je(e) { return Ue(e.replace(/\+/g, "%20")) } function qe(e) { return `${Ve(e.path)}${t = e.parameters, Object.keys(t).map(e => `;${Ve(e)}=${Ve(t[e])}`).join("")}`; var t } const ze = /^[^\/()?;=#]+/; function He(e) { const t = e.match(ze); return t ? t[0] : "" } const Ge = /^[^=?&#]+/, We = /^[^?&#]+/; class Ye { constructor(e) { this.url = e, this.remaining = e } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new De([], {}) : new De([], this.parseChildren()) } parseQueryParams() { const e = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(e) } while (this.consumeOptional("&")); return e } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const e = []; for (this.peekStartsWith("(") || e.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), e.push(this.parseSegment()); let t = {}; this.peekStartsWith("/(") && (this.capture("/"), t = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (e.length > 0 || Object.keys(t).length > 0) && (n[de] = new De(e, t)), n } parseSegment() { const e = He(this.remaining); if ("" === e && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(e), new Oe(Ue(e), this.parseMatrixParams()) } parseMatrixParams() { const e = {}; for (; this.consumeOptional(";");)this.parseParam(e); return e } parseParam(e) { const t = He(this.remaining); if (!t) return; this.capture(t); let n = ""; if (this.consumeOptional("=")) { const e = He(this.remaining); e && (n = e, this.capture(n)) } e[Ue(t)] = Ue(n) } parseQueryParam(e) { const t = function (e) { const t = e.match(Ge); return t ? t[0] : "" }(this.remaining); if (!t) return; this.capture(t); let n = ""; if (this.consumeOptional("=")) { const e = function (e) { const t = e.match(We); return t ? t[0] : "" }(this.remaining); e && (n = e, this.capture(n)) } const r = je(t), s = je(n); if (e.hasOwnProperty(r)) { let t = e[r]; Array.isArray(t) || (t = [t], e[r] = t), t.push(s) } else e[r] = s } parseParens(e) { const t = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = He(this.remaining), r = this.remaining[n.length]; if ("/" !== r && ")" !== r && ";" !== r) throw new Error(`Cannot parse url '${this.url}'`); let s; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : e && (s = de); const i = this.parseChildren(); t[s] = 1 === Object.keys(i).length ? i[de] : new De([], i), this.consumeOptional("//") } return t } peekStartsWith(e) { return this.remaining.startsWith(e) } consumeOptional(e) { return !!this.peekStartsWith(e) && (this.remaining = this.remaining.substring(e.length), !0) } capture(e) { if (!this.consumeOptional(e)) throw new Error(`Expected "${e}".`) } } class Ke { constructor(e) { this._root = e } get root() { return this._root.value } parent(e) { const t = this.pathFromRoot(e); return t.length > 1 ? t[t.length - 2] : null } children(e) { const t = Xe(e, this._root); return t ? t.children.map(e => e.value) : [] } firstChild(e) { const t = Xe(e, this._root); return t && t.children.length > 0 ? t.children[0].value : null } siblings(e) { const t = Ze(e, this._root); return t.length < 2 ? [] : t[t.length - 2].children.map(e => e.value).filter(t => t !== e) } pathFromRoot(e) { return Ze(e, this._root).map(e => e.value) } } function Xe(e, t) { if (e === t.value) return t; for (const n of t.children) { const t = Xe(e, n); if (t) return t } return null } function Ze(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = Ze(e, n); if (r.length) return r.unshift(t), r } return [] } class Qe { constructor(e, t) { this.value = e, this.children = t } toString() { return `TreeNode(${this.value})` } } function Je(e) { const t = {}; return e && e.children.forEach(e => t[e.value.outlet] = e), t } class et extends Ke { constructor(e, t) { super(e), this.snapshot = t, ot(this, e) } toString() { return this.snapshot.toString() } } function tt(e, t) { const n = function (e, t) { const n = new st([], {}, {}, "", {}, de, t, null, e.root, -1, {}); return new it("", new Qe(n, [])) }(e, t), r = new w.X([new Oe("", {})]), s = new w.X({}), i = new w.X({}), o = new w.X({}), a = new w.X(""), c = new nt(r, s, o, a, i, de, t, n.root); return c.snapshot = n.root, new et(new Qe(c, []), n) } class nt { constructor(e, t, n, r, s, i, o, a) { this.url = e, this.params = t, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe((0, M.U)(e => pe(e)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe((0, M.U)(e => pe(e)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function rt(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const e = n[r], t = n[r - 1]; if (e.routeConfig && "" === e.routeConfig.path) r--; else { if (t.component) break; r-- } } return function (e) { return e.reduce((e, t) => ({ params: Object.assign(Object.assign({}, e.params), t.params), data: Object.assign(Object.assign({}, e.data), t.data), resolve: Object.assign(Object.assign({}, e.resolve), t._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class st { constructor(e, t, n, r, s, i, o, a, c, l, u) { this.url = e, this.params = t, this.queryParams = n, this.fragment = r, this.data = s, this.outlet = i, this.component = o, this.routeConfig = a, this._urlSegment = c, this._lastPathIndex = l, this._resolve = u } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = pe(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = pe(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(e => e.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class it extends Ke { constructor(e, t) { super(t), this.url = e, ot(this, t) } toString() { return at(this._root) } } function ot(e, t) { t.value._routerState = e, t.children.forEach(t => ot(e, t)) } function at(e) { const t = e.children.length > 0 ? ` { ${e.children.map(at).join(", ")} } ` : ""; return `${e.value}${t}` } function ct(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, ye(t.queryParams, n.queryParams) || e.queryParams.next(n.queryParams), t.fragment !== n.fragment && e.fragment.next(n.fragment), ye(t.params, n.params) || e.params.next(n.params), function (e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!ye(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.url.next(n.url), ye(t.data, n.data) || e.data.next(n.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function lt(e, t) { var n, r; return ye(e.params, t.params) && Re(n = e.url, r = t.url) && n.every((e, t) => ye(e.parameters, r[t].parameters)) && !(!e.parent != !t.parent) && (!e.parent || lt(e.parent, t.parent)) } function ut(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const s = function (e, t, n) { return t.children.map(t => { for (const r of n.children) if (e.shouldReuseRoute(t.value, r.value.snapshot)) return ut(e, t, r); return ut(e, t) }) }(e, t, n); return new Qe(r, s) } { if (e.shouldAttach(t.value)) { const n = e.retrieve(t.value); if (null !== n) { const e = n.route; return ht(t, e), e } } const n = new nt(new w.X((r = t.value).url), new w.X(r.params), new w.X(r.queryParams), new w.X(r.fragment), new w.X(r.data), r.outlet, r.component, r), s = t.children.map(t => ut(e, t)); return new Qe(n, s) } var r } function ht(e, t) { if (e.value.routeConfig !== t.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (e.children.length !== t.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); t.value._futureSnapshot = e.value; for (let n = 0; n < e.children.length; ++n)ht(e.children[n], t.children[n]) } function dt(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function ft(e) { return "object" == typeof e && null != e && e.outlets } function pt(e, t, n, r, s) { let i = {}; return r && _e(r, (e, t) => { i[t] = Array.isArray(e) ? e.map(e => `${e}`) : `${e}` }), new xe(n.root === e ? t : mt(n.root, e, t), i, s) } function mt(e, t, n) { const r = {}; return _e(e.children, (e, s) => { r[s] = e === t ? n : mt(e, t, n) }), new De(e.segments, r) } class gt { constructor(e, t, n) { if (this.isAbsolute = e, this.numberOfDoubleDots = t, this.commands = n, e && n.length > 0 && dt(n[0])) throw new Error("Root segment cannot have matrix parameters"); const r = n.find(ft); if (r && r !== be(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class yt { constructor(e, t, n) { this.segmentGroup = e, this.processChildren = t, this.index = n } } function vt(e, t, n) { if (e || (e = new De([], {})), 0 === e.segments.length && e.hasChildren()) return wt(e, t, n); const r = function (e, t, n) { let r = 0, s = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < e.segments.length;) { if (r >= n.length) return i; const t = e.segments[s], o = n[r]; if (ft(o)) break; const a = `${o}`, c = r < n.length - 1 ? n[r + 1] : null; if (s > 0 && void 0 === a) break; if (a && c && "object" == typeof c && void 0 === c.outlets) { if (!Ct(a, c, t)) return i; r += 2 } else { if (!Ct(a, {}, t)) return i; r++ } s++ } return { match: !0, pathIndex: s, commandIndex: r } }(e, t, n), s = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const t = new De(e.segments.slice(0, r.pathIndex), {}); return t.children[de] = new De(e.segments.slice(r.pathIndex), e.children), wt(t, 0, s) } return r.match && 0 === s.length ? new De(e.segments, {}) : r.match && !e.hasChildren() ? bt(e, t, n) : r.match ? wt(e, 0, s) : bt(e, t, n) } function wt(e, t, n) { if (0 === n.length) return new De(e.segments, {}); { const r = function (e) { return ft(e[0]) ? e[0].outlets : { [de]: e } }(n), s = {}; return _e(r, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (s[r] = vt(e.children[r], t, n)) }), _e(e.children, (e, t) => { void 0 === r[t] && (s[t] = e) }), new De(e.segments, s) } } function bt(e, t, n) { const r = e.segments.slice(0, t); let s = 0; for (; s < n.length;) { const i = n[s]; if (ft(i)) { const e = _t(i.outlets); return new De(r, e) } if (0 === s && dt(n[0])) { r.push(new Oe(e.segments[t].path, Et(n[0]))), s++; continue } const o = ft(i) ? i.outlets[de] : `${i}`, a = s < n.length - 1 ? n[s + 1] : null; o && a && dt(a) ? (r.push(new Oe(o, Et(a))), s += 2) : (r.push(new Oe(o, {})), s++) } return new De(r, {}) } function _t(e) { const t = {}; return _e(e, (e, n) => { "string" == typeof e && (e = [e]), null !== e && (t[n] = bt(new De([], {}), 0, e)) }), t } function Et(e) { const t = {}; return _e(e, (e, n) => t[n] = `${e}`), t } function Ct(e, t, n) { return e == n.path && ye(t, n.parameters) } class St { constructor(e, t, n, r) { this.routeReuseStrategy = e, this.futureState = t, this.currState = n, this.forwardEvent = r } activate(e) { const t = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(t, n, e), ct(this.futureState.root), this.activateChildRoutes(t, n, e) } deactivateChildRoutes(e, t, n) { const r = Je(t); e.children.forEach(e => { const t = e.value.outlet; this.deactivateRoutes(e, r[t], n), delete r[t] }), _e(r, (e, t) => { this.deactivateRouteAndItsChildren(e, n) }) } deactivateRoutes(e, t, n) { const r = e.value, s = t ? t.value : null; if (r === s) if (r.component) { const s = n.getContext(r.outlet); s && this.deactivateChildRoutes(e, t, s.children) } else this.deactivateChildRoutes(e, t, n); else s && this.deactivateRouteAndItsChildren(t, n) } deactivateRouteAndItsChildren(e, t) { this.routeReuseStrategy.shouldDetach(e.value.snapshot) ? this.detachAndStoreRouteSubtree(e, t) : this.deactivateRouteAndOutlet(e, t) } detachAndStoreRouteSubtree(e, t) { const n = t.getContext(e.value.outlet); if (n && n.outlet) { const t = n.outlet.detach(), r = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(e.value.snapshot, { componentRef: t, route: e, contexts: r }) } } deactivateRouteAndOutlet(e, t) { const n = t.getContext(e.value.outlet), r = n && e.value.component ? n.children : t, s = Je(e); for (const i of Object.keys(s)) this.deactivateRouteAndItsChildren(s[i], r); n && n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated(), n.attachRef = null, n.resolver = null, n.route = null) } activateChildRoutes(e, t, n) { const r = Je(t); e.children.forEach(e => { this.activateRoutes(e, r[e.value.outlet], n), this.forwardEvent(new ue(e.value.snapshot)) }), e.children.length && this.forwardEvent(new ce(e.value.snapshot)) } activateRoutes(e, t, n) { const r = e.value, s = t ? t.value : null; if (ct(r), r === s) if (r.component) { const s = n.getOrCreateContext(r.outlet); this.activateChildRoutes(e, t, s.children) } else this.activateChildRoutes(e, t, n); else if (r.component) { const t = n.getOrCreateContext(r.outlet); if (this.routeReuseStrategy.shouldAttach(r.snapshot)) { const e = this.routeReuseStrategy.retrieve(r.snapshot); this.routeReuseStrategy.store(r.snapshot, null), t.children.onOutletReAttached(e.contexts), t.attachRef = e.componentRef, t.route = e.route.value, t.outlet && t.outlet.attach(e.componentRef, e.route.value), Tt(e.route) } else { const n = function (e) { for (let t = e.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig; if (e && e.component) return null } return null }(r.snapshot), s = n ? n.module.componentFactoryResolver : null; t.attachRef = null, t.route = r, t.resolver = s, t.outlet && t.outlet.activateWith(r, s), this.activateChildRoutes(e, null, t.children) } } else this.activateChildRoutes(e, null, n) } } function Tt(e) { ct(e.value), e.children.forEach(Tt) } class It { constructor(e, t) { this.routes = e, this.module = t } } function kt(e) { return "function" == typeof e } function At(e) { return e instanceof xe } const xt = Symbol("INITIAL_VALUE"); function Dt() { return (0, $.w)(e => function (...e) { let t, n; return (0, i.K)(e[e.length - 1]) && (n = e.pop()), "function" == typeof e[e.length - 1] && (t = e.pop()), 1 === e.length && (0, o.k)(e[0]) && (e = e[0]), (0, f.n)(e, n).lift(new m(t)) }(e.map(e => e.pipe((0, B.q)(1), (0, V.O)(xt)))).pipe((0, U.R)((e, t) => { let n = !1; return t.reduce((e, r, s) => { if (e !== xt) return e; if (r === xt && (n = !0), !n) { if (!1 === r) return r; if (s === t.length - 1 || At(r)) return r } return e }, e) }, xt), (0, I.h)(e => e !== xt), (0, M.U)(e => At(e) ? e : !0 === e), (0, B.q)(1))) } let Ot = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275cmp = s.Xpm({ type: e, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (e, t) { 1 & e && s._UZ(0, "router-outlet") }, directives: function () { return [xn] }, encapsulation: 2 }), e })(); function Rt(e, t = "") { for (let n = 0; n < e.length; n++) { const r = e[n]; Nt(r, Pt(t, r)) } } function Nt(e, t) { e.children && Rt(e.children, t) } function Pt(e, t) { return t ? e || t.path ? e && !t.path ? `${e}/` : !e && t.path ? t.path : `${e}/${t.path}` : "" : e } function Ft(e) { const t = e.children && e.children.map(Ft), n = t ? Object.assign(Object.assign({}, e), { children: t }) : Object.assign({}, e); return !n.component && (t || n.loadChildren) && n.outlet && n.outlet !== de && (n.component = Ot), n } function Lt(e) { return e.outlet || de } function Mt(e, t) { const n = e.filter(e => Lt(e) === t); return n.push(...e.filter(e => Lt(e) !== t)), n } const $t = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function Bt(e, t, n) { var r; if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? Object.assign({}, $t) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const s = (t.matcher || ge)(n, e, t); if (!s) return Object.assign({}, $t); const i = {}; _e(s.posParams, (e, t) => { i[t] = e.path }); const o = s.consumed.length > 0 ? Object.assign(Object.assign({}, i), s.consumed[s.consumed.length - 1].parameters) : i; return { matched: !0, consumedSegments: s.consumed, lastChild: s.consumed.length, parameters: o, positionalParamSegments: null !== (r = s.posParams) && void 0 !== r ? r : {} } } function Vt(e, t, n, r, s = "corrected") { if (n.length > 0 && function (e, t, n) { return n.some(n => Ut(e, t, n) && Lt(n) !== de) }(e, n, r)) { const s = new De(t, function (e, t, n, r) { const s = {}; s[de] = r, r._sourceSegment = e, r._segmentIndexShift = t.length; for (const i of n) if ("" === i.path && Lt(i) !== de) { const n = new De([], {}); n._sourceSegment = e, n._segmentIndexShift = t.length, s[Lt(i)] = n } return s }(e, t, r, new De(n, e.children))); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (e, t, n) { return n.some(n => Ut(e, t, n)) }(e, n, r)) { const i = new De(e.segments, function (e, t, n, r, s, i) { const o = {}; for (const a of r) if (Ut(e, n, a) && !s[Lt(a)]) { const n = new De([], {}); n._sourceSegment = e, n._segmentIndexShift = "legacy" === i ? e.segments.length : t.length, o[Lt(a)] = n } return Object.assign(Object.assign({}, s), o) }(e, t, n, r, e.children, s)); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } const i = new De(e.segments, e.children); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } function Ut(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } function jt(e, t, n, r) { return !!(Lt(e) === r || r !== de && Ut(t, n, e)) && ("**" === e.path || Bt(t, e, n).matched) } function qt(e, t, n) { return 0 === t.length && !e.children[n] } class zt { constructor(e) { this.segmentGroup = e || null } } class Ht { constructor(e) { this.urlTree = e } } function Gt(e) { return new h.y(t => t.error(new zt(e))) } function Wt(e) { return new h.y(t => t.error(new Ht(e))) } function Yt(e) { return new h.y(t => t.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${e}'`))) } class Kt { constructor(e, t, n, r, i) { this.configLoader = t, this.urlSerializer = n, this.urlTree = r, this.config = i, this.allowRedirects = !0, this.ngModule = e.get(s.h0i) } apply() { const e = Vt(this.urlTree.root, [], [], this.config).segmentGroup, t = new De(e.segments, e.children); return this.expandSegmentGroup(this.ngModule, this.config, t, de).pipe((0, M.U)(e => this.createUrlTree(Xt(e), this.urlTree.queryParams, this.urlTree.fragment))).pipe((0, j.K)(e => { if (e instanceof Ht) return this.allowRedirects = !1, this.match(e.urlTree); if (e instanceof zt) throw this.noMatchError(e); throw e })) } match(e) { return this.expandSegmentGroup(this.ngModule, this.config, e.root, de).pipe((0, M.U)(t => this.createUrlTree(Xt(t), e.queryParams, e.fragment))).pipe((0, j.K)(e => { if (e instanceof zt) throw this.noMatchError(e); throw e })) } noMatchError(e) { return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`) } createUrlTree(e, t, n) { const r = e.segments.length > 0 ? new De([], { [de]: e }) : e; return new xe(r, t, n) } expandSegmentGroup(e, t, n, r) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(e, t, n).pipe((0, M.U)(e => new De([], e))) : this.expandSegment(e, n, t, n.segments, r, !0) } expandChildren(e, t, n) { const r = []; for (const s of Object.keys(n.children)) "primary" === s ? r.unshift(s) : r.push(s); return (0, y.D)(r).pipe((0, q.b)(r => { const s = n.children[r], i = Mt(t, r); return this.expandSegmentGroup(e, i, s, r).pipe((0, M.U)(e => ({ segment: e, outlet: r }))) }), (0, U.R)((e, t) => (e[t.outlet] = t.segment, e), {}), function (e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? (0, I.h)((t, n) => e(t, n, r)) : N.y, A(1), n ? (0, R.d)(t) : (0, O.T)(() => new b.K)) }()) } expandSegment(e, t, n, r, s, i) { return (0, y.D)(n).pipe((0, q.b)(o => this.expandSegmentAgainstRoute(e, t, n, o, r, s, i).pipe((0, j.K)(e => { if (e instanceof zt) return (0, v.of)(null); throw e }))), (0, z.P)(e => !!e), (0, j.K)((e, n) => { if (e instanceof b.K || "EmptyError" === e.name) { if (qt(t, r, s)) return (0, v.of)(new De([], {})); throw new zt(t) } throw e })) } expandSegmentAgainstRoute(e, t, n, r, s, i, o) { return jt(r, t, s, i) ? void 0 === r.redirectTo ? this.matchSegmentAgainstRoute(e, t, r, s, i) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) : Gt(t) : Gt(t) } expandSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) { return "**" === r.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, n, r, i) : this.expandRegularSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) } expandWildCardWithParamsAgainstRouteUsingRedirect(e, t, n, r) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? Wt(s) : this.lineralizeSegments(n, s).pipe((0, H.zg)(n => { const s = new De(n, {}); return this.expandSegment(e, s, t, n, r, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(e, t, n, r, s, i) { const { matched: o, consumedSegments: a, lastChild: c, positionalParamSegments: l } = Bt(t, r, s); if (!o) return Gt(t); const u = this.applyRedirectCommands(a, r.redirectTo, l); return r.redirectTo.startsWith("/") ? Wt(u) : this.lineralizeSegments(r, u).pipe((0, H.zg)(r => this.expandSegment(e, t, n, r.concat(s.slice(c)), i, !1))) } matchSegmentAgainstRoute(e, t, n, r, s) { if ("**" === n.path) return n.loadChildren ? (n._loadedConfig ? (0, v.of)(n._loadedConfig) : this.configLoader.load(e.injector, n)).pipe((0, M.U)(e => (n._loadedConfig = e, new De(r, {})))) : (0, v.of)(new De(r, {})); const { matched: i, consumedSegments: o, lastChild: a } = Bt(t, n, r); if (!i) return Gt(t); const c = r.slice(a); return this.getChildConfig(e, n, r).pipe((0, H.zg)(e => { const r = e.module, i = e.routes, { segmentGroup: a, slicedSegments: l } = Vt(t, o, c, i), u = new De(a.segments, a.children); if (0 === l.length && u.hasChildren()) return this.expandChildren(r, i, u).pipe((0, M.U)(e => new De(o, e))); if (0 === i.length && 0 === l.length) return (0, v.of)(new De(o, {})); const h = Lt(n) === s; return this.expandSegment(r, u, i, l, h ? de : s, !0).pipe((0, M.U)(e => new De(o.concat(e.segments), e.children))) })) } getChildConfig(e, t, n) { return t.children ? (0, v.of)(new It(t.children, e)) : t.loadChildren ? void 0 !== t._loadedConfig ? (0, v.of)(t._loadedConfig) : this.runCanLoadGuards(e.injector, t, n).pipe((0, H.zg)(n => n ? this.configLoader.load(e.injector, t).pipe((0, M.U)(e => (t._loadedConfig = e, e))) : function (e) { return new h.y(t => t.error(me(`Cannot load children because the guard of the route "path: '${e.path}'" returned false`))) }(t))) : (0, v.of)(new It([], e)) } runCanLoadGuards(e, t, n) { const r = t.canLoad; if (!r || 0 === r.length) return (0, v.of)(!0); const s = r.map(r => { const s = e.get(r); let i; if (function (e) { return e && kt(e.canLoad) }(s)) i = s.canLoad(t, n); else { if (!kt(s)) throw new Error("Invalid CanLoad guard"); i = s(t, n) } return Ee(i) }); return (0, v.of)(s).pipe(Dt(), (0, G.b)(e => { if (!At(e)) return; const t = me(`Redirecting to "${this.urlSerializer.serialize(e)}"`); throw t.url = e, t }), (0, M.U)(e => !0 === e)) } lineralizeSegments(e, t) { let n = [], r = t.root; for (; ;) { if (n = n.concat(r.segments), 0 === r.numberOfChildren) return (0, v.of)(n); if (r.numberOfChildren > 1 || !r.children[de]) return Yt(e.redirectTo); r = r.children[de] } } applyRedirectCommands(e, t, n) { return this.applyRedirectCreatreUrlTree(t, this.urlSerializer.parse(t), e, n) } applyRedirectCreatreUrlTree(e, t, n, r) { const s = this.createSegmentGroup(e, t.root, n, r); return new xe(s, this.createQueryParams(t.queryParams, this.urlTree.queryParams), t.fragment) } createQueryParams(e, t) { const n = {}; return _e(e, (e, r) => { if ("string" == typeof e && e.startsWith(":")) { const s = e.substring(1); n[r] = t[s] } else n[r] = e }), n } createSegmentGroup(e, t, n, r) { const s = this.createSegments(e, t.segments, n, r); let i = {}; return _e(t.children, (t, s) => { i[s] = this.createSegmentGroup(e, t, n, r) }), new De(s, i) } createSegments(e, t, n, r) { return t.map(t => t.path.startsWith(":") ? this.findPosParam(e, t, r) : this.findOrReturn(t, n)) } findPosParam(e, t, n) { const r = n[t.path.substring(1)]; if (!r) throw new Error(`Cannot redirect to '${e}'. Cannot find '${t.path}'.`); return r } findOrReturn(e, t) { let n = 0; for (const r of t) { if (r.path === e.path) return t.splice(n), r; n++ } return e } } function Xt(e) { const t = {}; for (const n of Object.keys(e.children)) { const r = Xt(e.children[n]); (r.segments.length > 0 || r.hasChildren()) && (t[n] = r) } return function (e) { if (1 === e.numberOfChildren && e.children[de]) { const t = e.children[de]; return new De(e.segments.concat(t.segments), t.children) } return e }(new De(e.segments, t)) } class Zt { constructor(e) { this.path = e, this.route = this.path[this.path.length - 1] } } class Qt { constructor(e, t) { this.component = e, this.route = t } } function Jt(e, t, n) { const r = e._root; return tn(r, t ? t._root : null, n, [r.value]) } function en(e, t, n) { const r = function (e) { if (!e) return null; for (let t = e.parent; t; t = t.parent) { const e = t.routeConfig; if (e && e._loadedConfig) return e._loadedConfig } return null }(t); return (r ? r.module.injector : n).get(e) } function tn(e, t, n, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = Je(t); return e.children.forEach(e => { !function (e, t, n, r, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, o = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (o && i.routeConfig === o.routeConfig) { const c = function (e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !Re(e.url, t.url); case "pathParamsOrQueryParamsChange": return !Re(e.url, t.url) || !ye(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !lt(e, t) || !ye(e.queryParams, t.queryParams); case "paramsChange": default: return !lt(e, t) } }(o, i, i.routeConfig.runGuardsAndResolvers); c ? s.canActivateChecks.push(new Zt(r)) : (i.data = o.data, i._resolvedData = o._resolvedData), tn(e, t, i.component ? a ? a.children : null : n, r, s), c && a && a.outlet && a.outlet.isActivated && s.canDeactivateChecks.push(new Qt(a.outlet.component, o)) } else o && nn(t, a, s), s.canActivateChecks.push(new Zt(r)), tn(e, null, i.component ? a ? a.children : null : n, r, s) }(e, i[e.value.outlet], n, r.concat([e.value]), s), delete i[e.value.outlet] }), _e(i, (e, t) => nn(e, n.getContext(t), s)), s } function nn(e, t, n) { const r = Je(e), s = e.value; _e(r, (e, r) => { nn(e, s.component ? t ? t.children.getContext(r) : null : t, n) }), n.canDeactivateChecks.push(new Qt(s.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, s)) } class rn { } function sn(e) { return new h.y(t => t.error(e)) } class on { constructor(e, t, n, r, s, i) { this.rootComponentType = e, this.config = t, this.urlTree = n, this.url = r, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = i } recognize() { const e = Vt(this.urlTree.root, [], [], this.config.filter(e => void 0 === e.redirectTo), this.relativeLinkResolution).segmentGroup, t = this.processSegmentGroup(this.config, e, de); if (null === t) return null; const n = new st([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, de, this.rootComponentType, null, this.urlTree.root, -1, {}), r = new Qe(n, t), s = new it(this.url, r); return this.inheritParamsAndData(s._root), s } inheritParamsAndData(e) { const t = e.value, n = rt(t, this.paramsInheritanceStrategy); t.params = Object.freeze(n.params), t.data = Object.freeze(n.data), e.children.forEach(e => this.inheritParamsAndData(e)) } processSegmentGroup(e, t, n) { return 0 === t.segments.length && t.hasChildren() ? this.processChildren(e, t) : this.processSegment(e, t, t.segments, n) } processChildren(e, t) { const n = []; for (const s of Object.keys(t.children)) { const r = t.children[s], i = Mt(e, s), o = this.processSegmentGroup(i, r, s); if (null === o) return null; n.push(...o) } const r = cn(n); return r.sort((e, t) => e.value.outlet === de ? -1 : t.value.outlet === de ? 1 : e.value.outlet.localeCompare(t.value.outlet)), r } processSegment(e, t, n, r) { for (const s of e) { const e = this.processSegmentAgainstRoute(s, t, n, r); if (null !== e) return e } return qt(t, n, r) ? [] : null } processSegmentAgainstRoute(e, t, n, r) { if (e.redirectTo || !jt(e, t, n, r)) return null; let s, i = [], o = []; if ("**" === e.path) { const r = n.length > 0 ? be(n).parameters : {}; s = new st(n, r, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, hn(e), Lt(e), e.component, e, ln(t), un(t) + n.length, dn(e)) } else { const r = Bt(t, e, n); if (!r.matched) return null; i = r.consumedSegments, o = n.slice(r.lastChild), s = new st(i, r.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, hn(e), Lt(e), e.component, e, ln(t), un(t) + i.length, dn(e)) } const a = function (e) { return e.children ? e.children : e.loadChildren ? e._loadedConfig.routes : [] }(e), { segmentGroup: c, slicedSegments: l } = Vt(t, i, o, a.filter(e => void 0 === e.redirectTo), this.relativeLinkResolution); if (0 === l.length && c.hasChildren()) { const e = this.processChildren(a, c); return null === e ? null : [new Qe(s, e)] } if (0 === a.length && 0 === l.length) return [new Qe(s, [])]; const u = Lt(e) === r, h = this.processSegment(a, c, l, u ? de : r); return null === h ? null : [new Qe(s, h)] } } function an(e) { const t = e.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function cn(e) { const t = [], n = new Set; for (const r of e) { if (!an(r)) { t.push(r); continue } const e = t.find(e => r.value.routeConfig === e.value.routeConfig); void 0 !== e ? (e.children.push(...r.children), n.add(e)) : t.push(r) } for (const r of n) { const e = cn(r.children); t.push(new Qe(r.value, e)) } return t.filter(e => !n.has(e)) } function ln(e) { let t = e; for (; t._sourceSegment;)t = t._sourceSegment; return t } function un(e) { let t = e, n = t._segmentIndexShift ? t._segmentIndexShift : 0; for (; t._sourceSegment;)t = t._sourceSegment, n += t._segmentIndexShift ? t._segmentIndexShift : 0; return n - 1 } function hn(e) { return e.data || {} } function dn(e) { return e.resolve || {} } function fn(e) { return (0, $.w)(t => { const n = e(t); return n ? (0, y.D)(n).pipe((0, M.U)(() => t)) : (0, v.of)(t) }) } class pn { } class mn extends class { shouldDetach(e) { return !1 } store(e, t) { } shouldAttach(e) { return !1 } retrieve(e) { return null } shouldReuseRoute(e, t) { return e.routeConfig === t.routeConfig } }{ } const gn = new s.OlP("ROUTES"); class yn { constructor(e, t, n, r) { this.loader = e, this.compiler = t, this.onLoadStartListener = n, this.onLoadEndListener = r } load(e, t) { if (t._loader$) return t._loader$; this.onLoadStartListener && this.onLoadStartListener(t); const n = this.loadModuleFactory(t.loadChildren).pipe((0, M.U)(n => { this.onLoadEndListener && this.onLoadEndListener(t); const r = n.create(e); return new It(we(r.injector.get(gn, void 0, s.XFs.Self | s.XFs.Optional)).map(Ft), r) }), (0, j.K)(e => { throw t._loader$ = void 0, e })); return t._loader$ = new S.c(n, () => new T.xQ).pipe((0, W.x)()), t._loader$ } loadModuleFactory(e) { return "string" == typeof e ? (0, y.D)(this.loader.load(e)) : Ee(e()).pipe((0, H.zg)(e => e instanceof s.YKP ? (0, v.of)(e) : (0, y.D)(this.compiler.compileModuleAsync(e)))) } } class vn { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new wn, this.attachRef = null } } class wn { constructor() { this.contexts = new Map } onChildOutletCreated(e, t) { const n = this.getOrCreateContext(e); n.outlet = t, this.contexts.set(e, n) } onChildOutletDestroyed(e) { const t = this.getContext(e); t && (t.outlet = null) } onOutletDeactivated() { const e = this.contexts; return this.contexts = new Map, e } onOutletReAttached(e) { this.contexts = e } getOrCreateContext(e) { let t = this.getContext(e); return t || (t = new vn, this.contexts.set(e, t)), t } getContext(e) { return this.contexts.get(e) || null } } class bn { shouldProcessUrl(e) { return !0 } extract(e) { return e } merge(e, t) { return e } } function _n(e) { throw e } function En(e, t, n) { return t.parse("/") } function Cn(e, t) { return (0, v.of)(null) } const Sn = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, Tn = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let In = (() => { class e { constructor(e, t, n, r, i, o, a, c) { this.rootComponentType = e, this.urlSerializer = t, this.rootContexts = n, this.location = r, this.config = c, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new T.xQ, this.errorHandler = _n, this.malformedUriErrorHandler = En, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Cn, afterPreactivation: Cn }, this.urlHandlingStrategy = new bn, this.routeReuseStrategy = new mn, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.ngModule = i.get(s.h0i), this.console = i.get(s.c2e); const l = i.get(s.R0b); this.isNgZoneEnabled = l instanceof s.R0b && s.R0b.isInAngularZone(), this.resetConfig(c), this.currentUrlTree = new xe(new De([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new yn(o, a, e => this.triggerEvent(new ie(e)), e => this.triggerEvent(new oe(e))), this.routerState = tt(this.currentUrlTree, this.rootComponentType), this.transitions = new w.X({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { var e; return null === (e = this.location.getState()) || void 0 === e ? void 0 : e.\u0275routerPageId } setupNavigations(e) { const t = this.events; return e.pipe((0, I.h)(e => 0 !== e.id), (0, M.U)(e => Object.assign(Object.assign({}, e), { extractedUrl: this.urlHandlingStrategy.extract(e.rawUrl) })), (0, $.w)(e => { let n = !1, r = !1; return (0, v.of)(e).pipe((0, G.b)(e => { this.currentNavigation = { id: e.id, initialUrl: e.currentRawUrl, extractedUrl: e.extractedUrl, trigger: e.source, extras: e.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), (0, $.w)(e => { const n = !this.navigated || e.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(e.rawUrl)) return (0, v.of)(e).pipe((0, $.w)(e => { const n = this.transitions.getValue(); return t.next(new X(e.id, this.serializeUrl(e.extractedUrl), e.source, e.restoredState)), n !== this.transitions.getValue() ? C.E : Promise.resolve(e) }), (r = this.ngModule.injector, s = this.configLoader, i = this.urlSerializer, o = this.config, (0, $.w)(e => function (e, t, n, r, s) { return new Kt(e, t, n, r, s).apply() }(r, s, i, e.extractedUrl, o).pipe((0, M.U)(t => Object.assign(Object.assign({}, e), { urlAfterRedirects: t }))))), (0, G.b)(e => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: e.urlAfterRedirects }) }), function (e, t, n, r, s) { return (0, H.zg)(i => function (e, t, n, r, s = "emptyOnly", i = "legacy") { try { const o = new on(e, t, n, r, s, i).recognize(); return null === o ? sn(new rn) : (0, v.of)(o) } catch (o) { return sn(o) } }(e, t, i.urlAfterRedirects, n(i.urlAfterRedirects), r, s).pipe((0, M.U)(e => Object.assign(Object.assign({}, i), { targetSnapshot: e })))) }(this.rootComponentType, this.config, e => this.serializeUrl(e), this.paramsInheritanceStrategy, this.relativeLinkResolution), (0, G.b)(e => { "eager" === this.urlUpdateStrategy && (e.extras.skipLocationChange || this.setBrowserUrl(e.urlAfterRedirects, e), this.browserUrlTree = e.urlAfterRedirects); const n = new ee(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); t.next(n) })); var r, s, i, o; if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: r, source: s, restoredState: i, extras: o } = e, a = new X(n, this.serializeUrl(r), s, i); t.next(a); const c = tt(r, this.rootComponentType).snapshot; return (0, v.of)(Object.assign(Object.assign({}, e), { targetSnapshot: c, urlAfterRedirects: r, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = e.rawUrl, this.browserUrlTree = e.urlAfterRedirects, e.resolve(null), C.E }), fn(e => { const { targetSnapshot: t, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = e; return this.hooks.beforePreactivation(t, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), (0, G.b)(e => { const t = new te(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); this.triggerEvent(t) }), (0, M.U)(e => Object.assign(Object.assign({}, e), { guards: Jt(e.targetSnapshot, e.currentSnapshot, this.rootContexts) })), function (e, t) { return (0, H.zg)(n => { const { targetSnapshot: r, currentSnapshot: s, guards: { canActivateChecks: i, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === i.length ? (0, v.of)(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (e, t, n, r) { return (0, y.D)(e).pipe((0, H.zg)(e => function (e, t, n, r, s) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; if (!i || 0 === i.length) return (0, v.of)(!0); const o = i.map(i => { const o = en(i, t, s); let a; if (function (e) { return e && kt(e.canDeactivate) }(o)) a = Ee(o.canDeactivate(e, t, n, r)); else { if (!kt(o)) throw new Error("Invalid CanDeactivate guard"); a = Ee(o(e, t, n, r)) } return a.pipe((0, z.P)()) }); return (0, v.of)(o).pipe(Dt()) }(e.component, e.route, n, t, r)), (0, z.P)(e => !0 !== e, !0)) }(o, r, s, e).pipe((0, H.zg)(n => n && "boolean" == typeof n ? function (e, t, n, r) { return (0, y.D)(t).pipe((0, q.b)(t => (0, _.z)(function (e, t) { return null !== e && t && t(new ae(e)), (0, v.of)(!0) }(t.route.parent, r), function (e, t) { return null !== e && t && t(new le(e)), (0, v.of)(!0) }(t.route, r), function (e, t, n) { const r = t[t.length - 1], s = t.slice(0, t.length - 1).reverse().map(e => function (e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(e)).filter(e => null !== e).map(t => (0, E.P)(() => { const s = t.guards.map(s => { const i = en(s, t.node, n); let o; if (function (e) { return e && kt(e.canActivateChild) }(i)) o = Ee(i.canActivateChild(r, e)); else { if (!kt(i)) throw new Error("Invalid CanActivateChild guard"); o = Ee(i(r, e)) } return o.pipe((0, z.P)()) }); return (0, v.of)(s).pipe(Dt()) })); return (0, v.of)(s).pipe(Dt()) }(e, t.path, n), function (e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return (0, v.of)(!0); const s = r.map(r => (0, E.P)(() => { const s = en(r, t, n); let i; if (function (e) { return e && kt(e.canActivate) }(s)) i = Ee(s.canActivate(t, e)); else { if (!kt(s)) throw new Error("Invalid CanActivate guard"); i = Ee(s(t, e)) } return i.pipe((0, z.P)()) })); return (0, v.of)(s).pipe(Dt()) }(e, t.route, n))), (0, z.P)(e => !0 !== e, !0)) }(r, i, e, t) : (0, v.of)(n)), (0, M.U)(e => Object.assign(Object.assign({}, n), { guardsResult: e }))) }) }(this.ngModule.injector, e => this.triggerEvent(e)), (0, G.b)(e => { if (At(e.guardsResult)) { const t = me(`Redirecting to "${this.serializeUrl(e.guardsResult)}"`); throw t.url = e.guardsResult, t } const t = new ne(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot, !!e.guardsResult); this.triggerEvent(t) }), (0, I.h)(e => !!e.guardsResult || (this.restoreHistory(e), this.cancelNavigationTransition(e, ""), !1)), fn(e => { if (e.guards.canActivateChecks.length) return (0, v.of)(e).pipe((0, G.b)(e => { const t = new re(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); this.triggerEvent(t) }), (0, $.w)(e => { let t = !1; return (0, v.of)(e).pipe((n = this.paramsInheritanceStrategy, r = this.ngModule.injector, (0, H.zg)(e => { const { targetSnapshot: t, guards: { canActivateChecks: s } } = e; if (!s.length) return (0, v.of)(e); let i = 0; return (0, y.D)(s).pipe((0, q.b)(e => function (e, t, n, r) { return function (e, t, n, r) { const s = Object.keys(e); if (0 === s.length) return (0, v.of)({}); const i = {}; return (0, y.D)(s).pipe((0, H.zg)(s => function (e, t, n, r) { const s = en(e, t, r); return Ee(s.resolve ? s.resolve(t, n) : s(t, n)) }(e[s], t, n, r).pipe((0, G.b)(e => { i[s] = e }))), A(1), (0, H.zg)(() => Object.keys(i).length === s.length ? (0, v.of)(i) : C.E)) }(e._resolve, e, t, r).pipe((0, M.U)(t => (e._resolvedData = t, e.data = Object.assign(Object.assign({}, e.data), rt(e, n).resolve), null))) }(e.route, t, n, r)), (0, G.b)(() => i++), A(1), (0, H.zg)(t => i === s.length ? (0, v.of)(e) : C.E)) })), (0, G.b)({ next: () => t = !0, complete: () => { t || (this.restoreHistory(e), this.cancelNavigationTransition(e, "At least one route resolver didn't emit any value.")) } })); var n, r }), (0, G.b)(e => { const t = new se(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(e.urlAfterRedirects), e.targetSnapshot); this.triggerEvent(t) })) }), fn(e => { const { targetSnapshot: t, id: n, extractedUrl: r, rawUrl: s, extras: { skipLocationChange: i, replaceUrl: o } } = e; return this.hooks.afterPreactivation(t, { navigationId: n, appliedUrlTree: r, rawUrlTree: s, skipLocationChange: !!i, replaceUrl: !!o }) }), (0, M.U)(e => { const t = function (e, t, n) { const r = ut(e, t._root, n ? n._root : void 0); return new et(r, t) }(this.routeReuseStrategy, e.targetSnapshot, e.currentRouterState); return Object.assign(Object.assign({}, e), { targetRouterState: t }) }), (0, G.b)(e => { this.currentUrlTree = e.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl), this.routerState = e.targetRouterState, "deferred" === this.urlUpdateStrategy && (e.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, e), this.browserUrlTree = e.urlAfterRedirects) }), (i = this.rootContexts, o = this.routeReuseStrategy, a = e => this.triggerEvent(e), (0, M.U)(e => (new St(o, e.targetRouterState, e.currentRouterState, a).activate(i), e))), (0, G.b)({ next() { n = !0 }, complete() { n = !0 } }), (s = () => { if (!n && !r) { const t = `Navigation ID ${e.id} is not equal to the current navigation id ${this.navigationId}`; "replace" === this.canceledNavigationResolution ? (this.restoreHistory(e), this.cancelNavigationTransition(e, t)) : this.cancelNavigationTransition(e, t) } this.currentNavigation = null }, e => e.lift(new F(s))), (0, j.K)(n => { if (r = !0, (s = n) && s.ngNavigationCancelingError) { const r = At(n.url); r || (this.navigated = !0, this.restoreHistory(e, !0)); const s = new Q(e.id, this.serializeUrl(e.extractedUrl), n.message); t.next(s), r ? setTimeout(() => { const t = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); this.scheduleNavigation(t, "imperative", null, { skipLocationChange: e.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: e.resolve, reject: e.reject, promise: e.promise }) }, 0) : e.resolve(!1) } else { this.restoreHistory(e, !0); const r = new J(e.id, this.serializeUrl(e.extractedUrl), n); t.next(r); try { e.resolve(this.errorHandler(n)) } catch (i) { e.reject(i) } } var s; return C.E })); var s, i, o, a })) } resetRootComponentType(e) { this.rootComponentType = e, this.routerState.root.component = this.rootComponentType } getTransition() { const e = this.transitions.value; return e.urlAfterRedirects = this.browserUrlTree, e } setTransition(e) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), e)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(e => { const t = this.extractLocationChangeInfoFromEvent(e); this.shouldScheduleNavigation(this.lastLocationChangeInfo, t) && setTimeout(() => { const { source: e, state: n, urlTree: r } = t, s = { replaceUrl: !0 }; if (n) { const e = Object.assign({}, n); delete e.navigationId, delete e.\u0275routerPageId, 0 !== Object.keys(e).length && (s.state = e) } this.scheduleNavigation(r, e, n, s) }, 0), this.lastLocationChangeInfo = t })) } extractLocationChangeInfoFromEvent(e) { var t; return { source: "popstate" === e.type ? "popstate" : "hashchange", urlTree: this.parseUrl(e.url), state: (null === (t = e.state) || void 0 === t ? void 0 : t.navigationId) ? e.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(e, t) { if (!e) return !0; const n = t.urlTree.toString() === e.urlTree.toString(); return !(t.transitionId === e.transitionId && n && ("hashchange" === t.source && "popstate" === e.source || "popstate" === t.source && "hashchange" === e.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(e) { this.events.next(e) } resetConfig(e) { Rt(e), this.config = e.map(Ft), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(e, t = {}) { const { relativeTo: n, queryParams: r, fragment: s, queryParamsHandling: i, preserveFragment: o } = t, a = n || this.routerState.root, c = o ? this.currentUrlTree.fragment : s; let l = null; switch (i) { case "merge": l = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), r); break; case "preserve": l = this.currentUrlTree.queryParams; break; default: l = r || null }return null !== l && (l = this.removeEmptyProps(l)), function (e, t, n, r, s) { if (0 === n.length) return pt(t.root, t.root, t, r, s); const i = function (e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new gt(!0, 0, e); let t = 0, n = !1; const r = e.reduce((e, r, s) => { if ("object" == typeof r && null != r) { if (r.outlets) { const t = {}; return _e(r.outlets, (e, n) => { t[n] = "string" == typeof e ? e.split("/") : e }), [...e, { outlets: t }] } if (r.segmentPath) return [...e, r.segmentPath] } return "string" != typeof r ? [...e, r] : 0 === s ? (r.split("/").forEach((r, s) => { 0 == s && "." === r || (0 == s && "" === r ? n = !0 : ".." === r ? t++ : "" != r && e.push(r)) }), e) : [...e, r] }, []); return new gt(n, t, r) }(n); if (i.toRoot()) return pt(t.root, new De([], {}), t, r, s); const o = function (e, t, n) { if (e.isAbsolute) return new yt(t.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const e = n.snapshot._urlSegment; return new yt(e, e === t.root, 0) } const r = dt(e.commands[0]) ? 0 : 1; return function (e, t, n) { let r = e, s = t, i = n; for (; i > s;) { if (i -= s, r = r.parent, !r) throw new Error("Invalid number of '../'"); s = r.segments.length } return new yt(r, !1, s - i) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + r, e.numberOfDoubleDots) }(i, t, e), a = o.processChildren ? wt(o.segmentGroup, o.index, i.commands) : vt(o.segmentGroup, o.index, i.commands); return pt(o.segmentGroup, a, t, r, s) }(a, this.currentUrlTree, e, l, null != c ? c : null) } navigateByUrl(e, t = { skipLocationChange: !1 }) { const n = At(e) ? e : this.parseUrl(e), r = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(r, "imperative", null, t) } navigate(e, t = { skipLocationChange: !1 }) { return function (e) { for (let t = 0; t < e.length; t++) { const n = e[t]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${t}`) } }(e), this.navigateByUrl(this.createUrlTree(e, t), t) } serializeUrl(e) { return this.urlSerializer.serialize(e) } parseUrl(e) { let t; try { t = this.urlSerializer.parse(e) } catch (n) { t = this.malformedUriErrorHandler(n, this.urlSerializer, e) } return t } isActive(e, t) { let n; if (n = !0 === t ? Object.assign({}, Sn) : !1 === t ? Object.assign({}, Tn) : t, At(e)) return Te(this.currentUrlTree, e, n); const r = this.parseUrl(e); return Te(this.currentUrlTree, r, n) } removeEmptyProps(e) { return Object.keys(e).reduce((t, n) => { const r = e[n]; return null != r && (t[n] = r), t }, {}) } processNavigations() { this.navigations.subscribe(e => { this.navigated = !0, this.lastSuccessfulId = e.id, this.currentPageId = e.targetPageId, this.events.next(new Z(e.id, this.serializeUrl(e.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, e.resolve(!0) }, e => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(e, t, n, r, s) { var i, o; if (this.disposed) return Promise.resolve(!1); const a = this.getTransition(), c = "imperative" !== t && "imperative" === (null == a ? void 0 : a.source), l = (this.lastSuccessfulId === a.id || this.currentNavigation ? a.rawUrl : a.urlAfterRedirects).toString() === e.toString(); if (c && l) return Promise.resolve(!0); let u, h, d; s ? (u = s.resolve, h = s.reject, d = s.promise) : d = new Promise((e, t) => { u = e, h = t }); const f = ++this.navigationId; let p; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (n = this.location.getState()), p = n && n.\u0275routerPageId ? n.\u0275routerPageId : r.replaceUrl || r.skipLocationChange ? null !== (i = this.browserPageId) && void 0 !== i ? i : 0 : (null !== (o = this.browserPageId) && void 0 !== o ? o : 0) + 1) : p = 0, this.setTransition({ id: f, targetPageId: p, source: t, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: e, extras: r, resolve: u, reject: h, promise: d, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), d.catch(e => Promise.reject(e)) } setBrowserUrl(e, t) { const n = this.urlSerializer.serialize(e), r = Object.assign(Object.assign({}, t.extras.state), this.generateNgRouterState(t.id, t.targetPageId)); this.location.isCurrentPathEqualTo(n) || t.extras.replaceUrl ? this.location.replaceState(n, "", r) : this.location.go(n, "", r) } restoreHistory(e, t = !1) { var n, r; if ("computed" === this.canceledNavigationResolution) { const t = this.currentPageId - e.targetPageId; "popstate" !== e.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== (null === (n = this.currentNavigation) || void 0 === n ? void 0 : n.finalUrl) || 0 === t ? this.currentUrlTree === (null === (r = this.currentNavigation) || void 0 === r ? void 0 : r.finalUrl) && 0 === t && (this.resetState(e), this.browserUrlTree = e.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(t) } else "replace" === this.canceledNavigationResolution && (t && this.resetState(e), this.resetUrlToCurrentUrlTree()) } resetState(e) { this.routerState = e.currentRouterState, this.currentUrlTree = e.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, e.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(e, t) { const n = new Q(e.id, this.serializeUrl(e.extractedUrl), t); this.triggerEvent(n), e.resolve(!1) } generateNgRouterState(e, t) { return "computed" === this.canceledNavigationResolution ? { navigationId: e, "\u0275routerPageId": t } : { navigationId: e } } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(s.DyG), s.LFG(Ne), s.LFG(wn), s.LFG(r.Ye), s.LFG(s.zs3), s.LFG(s.v3s), s.LFG(s.Sil), s.LFG(void 0)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), kn = (() => { class e { constructor(e, t, n, r, s) { this.router = e, this.route = t, this.commands = [], this.onChanges = new T.xQ, null == n && r.setAttribute(s.nativeElement, "tabindex", "0") } ngOnChanges(e) { this.onChanges.next(this) } set routerLink(e) { this.commands = null != e ? Array.isArray(e) ? e : [e] : [] } onClick() { const e = { skipLocationChange: An(this.skipLocationChange), replaceUrl: An(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, e), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: An(this.preserveFragment) }) } } return e.\u0275fac = function (t) { return new (t || e)(s.Y36(In), s.Y36(nt), s.$8M("tabindex"), s.Y36(s.Qsj), s.Y36(s.SBq)) }, e.\u0275dir = s.lG2({ type: e, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (e, t) { 1 & e && s.NdJ("click", function () { return t.onClick() }) }, inputs: { routerLink: "routerLink", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [s.TTD] }), e })(); function An(e) { return "" === e || !!e } let xn = (() => { class e { constructor(e, t, n, r, i) { this.parentContexts = e, this.location = t, this.resolver = n, this.changeDetector = i, this.activated = null, this._activatedRoute = null, this.activateEvents = new s.vpe, this.deactivateEvents = new s.vpe, this.name = r || de, e.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const e = this.parentContexts.getContext(this.name); e && e.route && (e.attachRef ? this.attach(e.attachRef, e.route) : this.activateWith(e.route, e.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const e = this.activated; return this.activated = null, this._activatedRoute = null, e } attach(e, t) { this.activated = e, this._activatedRoute = t, this.location.insert(e.hostView) } deactivate() { if (this.activated) { const e = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, t) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = e; const n = (t = t || this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component), r = this.parentContexts.getOrCreateContext(this.name).children, s = new Dn(e, r, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (t) { return new (t || e)(s.Y36(wn), s.Y36(s.s_b), s.Y36(s._Vd), s.$8M("name"), s.Y36(s.sBO)) }, e.\u0275dir = s.lG2({ type: e, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), e })(); class Dn { constructor(e, t, n) { this.route = e, this.childContexts = t, this.parent = n } get(e, t) { return e === nt ? this.route : e === wn ? this.childContexts : this.parent.get(e, t) } } class On { } class Rn { preload(e, t) { return t().pipe((0, j.K)(() => (0, v.of)(null))) } } class Nn { preload(e, t) { return (0, v.of)(null) } } let Pn = (() => { class e { constructor(e, t, n, r, s) { this.router = e, this.injector = r, this.preloadingStrategy = s, this.loader = new yn(t, n, t => e.triggerEvent(new ie(t)), t => e.triggerEvent(new oe(t))) } setUpPreloading() { this.subscription = this.router.events.pipe((0, I.h)(e => e instanceof Z), (0, q.b)(() => this.preload())).subscribe(() => { }) } preload() { const e = this.injector.get(s.h0i); return this.processRoutes(e, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(e, t) { const n = []; for (const r of t) if (r.loadChildren && !r.canLoad && r._loadedConfig) { const e = r._loadedConfig; n.push(this.processRoutes(e.module, e.routes)) } else r.loadChildren && !r.canLoad ? n.push(this.preloadConfig(e, r)) : r.children && n.push(this.processRoutes(e, r.children)); return (0, y.D)(n).pipe((0, Y.J)(), (0, M.U)(e => { })) } preloadConfig(e, t) { return this.preloadingStrategy.preload(t, () => (t._loadedConfig ? (0, v.of)(t._loadedConfig) : this.loader.load(e.injector, t)).pipe((0, H.zg)(e => (t._loadedConfig = e, this.processRoutes(e.module, e.routes))))) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(In), s.LFG(s.v3s), s.LFG(s.Sil), s.LFG(s.zs3), s.LFG(On)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), Fn = (() => { class e { constructor(e, t, n = {}) { this.router = e, this.viewportScroller = t, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(e => { e instanceof X ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = e.navigationTrigger, this.restoredId = e.restoredState ? e.restoredState.navigationId : 0) : e instanceof Z && (this.lastId = e.id, this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(e => { e instanceof he && (e.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(e.position) : e.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(e.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(e, t) { this.router.triggerEvent(new he(e, "popstate" === this.lastSource ? this.store[this.restoredId] : null, t)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(In), s.LFG(r.EM), s.LFG(void 0)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); const Ln = new s.OlP("ROUTER_CONFIGURATION"), Mn = new s.OlP("ROUTER_FORROOT_GUARD"), $n = [r.Ye, { provide: Ne, useClass: Pe }, { provide: In, useFactory: function (e, t, n, r, s, i, o, a = {}, c, l) { const u = new In(null, e, t, n, r, s, i, we(o)); return c && (u.urlHandlingStrategy = c), l && (u.routeReuseStrategy = l), function (e, t) { e.errorHandler && (t.errorHandler = e.errorHandler), e.malformedUriErrorHandler && (t.malformedUriErrorHandler = e.malformedUriErrorHandler), e.onSameUrlNavigation && (t.onSameUrlNavigation = e.onSameUrlNavigation), e.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = e.paramsInheritanceStrategy), e.relativeLinkResolution && (t.relativeLinkResolution = e.relativeLinkResolution), e.urlUpdateStrategy && (t.urlUpdateStrategy = e.urlUpdateStrategy) }(a, u), a.enableTracing && u.events.subscribe(e => { var t, n; null === (t = console.group) || void 0 === t || t.call(console, `Router Event: ${e.constructor.name}`), console.log(e.toString()), console.log(e), null === (n = console.groupEnd) || void 0 === n || n.call(console) }), u }, deps: [Ne, wn, r.Ye, s.zs3, s.v3s, s.Sil, gn, Ln, [class { }, new s.FiY], [pn, new s.FiY]] }, wn, { provide: nt, useFactory: function (e) { return e.routerState.root }, deps: [In] }, { provide: s.v3s, useClass: s.EAV }, Pn, Nn, Rn, { provide: Ln, useValue: { enableTracing: !1 } }]; function Bn() { return new s.PXZ("Router", In) } let Vn = (() => { class e { constructor(e, t) { } static forRoot(t, n) { return { ngModule: e, providers: [$n, zn(t), { provide: Mn, useFactory: qn, deps: [[In, new s.FiY, new s.tp0]] }, { provide: Ln, useValue: n || {} }, { provide: r.S$, useFactory: jn, deps: [r.lw, [new s.tBr(r.mr), new s.FiY], Ln] }, { provide: Fn, useFactory: Un, deps: [In, r.EM, Ln] }, { provide: On, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Nn }, { provide: s.PXZ, multi: !0, useFactory: Bn }, [Hn, { provide: s.ip1, multi: !0, useFactory: Gn, deps: [Hn] }, { provide: Yn, useFactory: Wn, deps: [Hn] }, { provide: s.tb, multi: !0, useExisting: Yn }]] } } static forChild(t) { return { ngModule: e, providers: [zn(t)] } } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(Mn, 8), s.LFG(In, 8)) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({}), e })(); function Un(e, t, n) { return n.scrollOffset && t.setOffset(n.scrollOffset), new Fn(e, t, n) } function jn(e, t, n = {}) { return n.useHash ? new r.Do(e, t) : new r.b0(e, t) } function qn(e) { return "guarded" } function zn(e) { return [{ provide: s.deG, multi: !0, useValue: e }, { provide: gn, multi: !0, useValue: e }] } let Hn = (() => { class e { constructor(e) { this.injector = e, this.initNavigation = !1, this.destroyed = !1, this.resultOfPreactivationDone = new T.xQ } appInitializer() { return this.injector.get(r.V_, Promise.resolve(null)).then(() => { if (this.destroyed) return Promise.resolve(!0); let e = null; const t = new Promise(t => e = t), n = this.injector.get(In), r = this.injector.get(Ln); return "disabled" === r.initialNavigation ? (n.setUpLocationChangeListener(), e(!0)) : "enabled" === r.initialNavigation || "enabledBlocking" === r.initialNavigation ? (n.hooks.afterPreactivation = () => this.initNavigation ? (0, v.of)(null) : (this.initNavigation = !0, e(!0), this.resultOfPreactivationDone), n.initialNavigation()) : e(!0), t }) } bootstrapListener(e) { const t = this.injector.get(Ln), n = this.injector.get(Pn), r = this.injector.get(Fn), i = this.injector.get(In), o = this.injector.get(s.z2F); e === o.components[0] && ("enabledNonBlocking" !== t.initialNavigation && void 0 !== t.initialNavigation || i.initialNavigation(), n.setUpPreloading(), r.init(), i.resetRootComponentType(o.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } ngOnDestroy() { this.destroyed = !0 } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(s.zs3)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); function Gn(e) { return e.appInitializer.bind(e) } function Wn(e) { return e.bootstrapListener.bind(e) } const Yn = new s.OlP("Router Initializer") }, 156: (e, t, n) => { "use strict"; n.d(t, { Z: () => h }); var r = n(3854), s = n(8604), i = n(279), o = n(9306); class a { constructor(e, t) { this._delegate = e, this.firebase = t, (0, i._addComponent)(e, new s.wA("app-compat", () => this, "PUBLIC")), this.container = e.container } get automaticDataCollectionEnabled() { return this._delegate.automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this._delegate.automaticDataCollectionEnabled = e } get name() { return this._delegate.name } get options() { return this._delegate.options } delete() { return new Promise(e => { this._delegate.checkDestroyed(), e() }).then(() => (this.firebase.INTERNAL.removeApp(this.name), (0, i.deleteApp)(this._delegate))) } _getService(e, t = i._DEFAULT_ENTRY_NAME) { var n; this._delegate.checkDestroyed(); const r = this._delegate.container.getProvider(e); return r.isInitialized() || "EXPLICIT" !== (null === (n = r.getComponent()) || void 0 === n ? void 0 : n.instantiationMode) || r.initialize(), r.getImmediate({ identifier: t }) } _removeServiceInstance(e, t = i._DEFAULT_ENTRY_NAME) { this._delegate.container.getProvider(e).clearInstance(t) } _addComponent(e) { (0, i._addComponent)(this._delegate, e) } _addOrOverwriteComponent(e) { (0, i._addOrOverwriteComponent)(this._delegate, e) } toJSON() { return { name: this.name, automaticDataCollectionEnabled: this.automaticDataCollectionEnabled, options: this.options } } } const c = new r.LL("app-compat", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance." }), l = function e() { const t = function (e) { const t = {}, n = { __esModule: !0, initializeApp: function (s, o = {}) { const a = i.initializeApp(s, o); if ((0, r.r3)(t, a.name)) return t[a.name]; const c = new e(a, n); return t[a.name] = c, c }, app: s, registerVersion: i.registerVersion, setLogLevel: i.setLogLevel, onLog: i.onLog, apps: null, SDK_VERSION: i.SDK_VERSION, INTERNAL: { registerComponent: function (t) { const o = t.name, a = o.replace("-compat", ""); if (i._registerComponent(t) && "PUBLIC" === t.type) { const i = (e = s()) => { if ("function" != typeof e[a]) throw c.create("invalid-app-argument", { appName: o }); return e[a]() }; void 0 !== t.serviceProps && (0, r.ZB)(i, t.serviceProps), n[a] = i, e.prototype[a] = function (...e) { return this._getService.bind(this, o).apply(this, t.multipleInstances ? e : []) } } return "PUBLIC" === t.type ? n[a] : null }, removeApp: function (e) { delete t[e] }, useAsService: function (e, t) { return "serverAuth" === t ? null : t }, modularAPIs: i } }; function s(e) { if (!(0, r.r3)(t, e = e || i._DEFAULT_ENTRY_NAME)) throw c.create("no-app", { appName: e }); return t[e] } return n.default = n, Object.defineProperty(n, "apps", { get: function () { return Object.keys(t).map(e => t[e]) } }), s.App = e, n }(a); return t.INTERNAL = Object.assign(Object.assign({}, t.INTERNAL), { createFirebaseNamespace: e, extendNamespace: function (e) { (0, r.ZB)(t, e) }, createSubscribe: r.ne, ErrorFactory: r.LL, deepExtend: r.ZB }), t }(), u = new o.Yd("@firebase/app-compat"); if ((0, r.jU)() && void 0 !== self.firebase) { u.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  "); const e = self.firebase.SDK_VERSION; e && e.indexOf("LITE") >= 0 && u.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ") } const h = l; (0, i.registerVersion)("@firebase/app-compat", "0.1.20", void 0) }, 279: (e, t, n) => { "use strict"; n.r(t), n.d(t, { FirebaseError: () => i.ZR, SDK_VERSION: () => E, _DEFAULT_ENTRY_NAME: () => u, _addComponent: () => p, _addOrOverwriteComponent: () => m, _apps: () => d, _clearComponents: () => w, _components: () => f, _getProvider: () => y, _registerComponent: () => g, _removeServiceInstance: () => v, deleteApp: () => I, getApp: () => S, getApps: () => T, initializeApp: () => C, onLog: () => A, registerVersion: () => k, setLogLevel: () => x }); var r = n(8604), s = n(9306), i = n(3854); class o { constructor(e) { this.container = e } getPlatformInfoString() { return this.container.getProviders().map(e => { if (function (e) { const t = e.getComponent(); return "VERSION" === (null == t ? void 0 : t.type) }(e)) { const t = e.getImmediate(); return `${t.library}/${t.version}` } return null }).filter(e => e).join(" ") } } const a = "@firebase/app", c = "0.7.19", l = new s.Yd("@firebase/app"), u = "[DEFAULT]", h = { [a]: "fire-core", "@firebase/app-compat": "fire-core-compat", "@firebase/analytics": "fire-analytics", "@firebase/analytics-compat": "fire-analytics-compat", "@firebase/app-check": "fire-app-check", "@firebase/app-check-compat": "fire-app-check-compat", "@firebase/auth": "fire-auth", "@firebase/auth-compat": "fire-auth-compat", "@firebase/database": "fire-rtdb", "@firebase/database-compat": "fire-rtdb-compat", "@firebase/functions": "fire-fn", "@firebase/functions-compat": "fire-fn-compat", "@firebase/installations": "fire-iid", "@firebase/installations-compat": "fire-iid-compat", "@firebase/messaging": "fire-fcm", "@firebase/messaging-compat": "fire-fcm-compat", "@firebase/performance": "fire-perf", "@firebase/performance-compat": "fire-perf-compat", "@firebase/remote-config": "fire-rc", "@firebase/remote-config-compat": "fire-rc-compat", "@firebase/storage": "fire-gcs", "@firebase/storage-compat": "fire-gcs-compat", "@firebase/firestore": "fire-fst", "@firebase/firestore-compat": "fire-fst-compat", "fire-js": "fire-js", firebase: "fire-js-all" }, d = new Map, f = new Map; function p(e, t) { try { e.container.addComponent(t) } catch (n) { l.debug(`Component ${t.name} failed to register with FirebaseApp ${e.name}`, n) } } function m(e, t) { e.container.addOrOverwriteComponent(t) } function g(e) { const t = e.name; if (f.has(t)) return l.debug(`There were multiple attempts to register component ${t}.`), !1; f.set(t, e); for (const n of d.values()) p(n, e); return !0 } function y(e, t) { const n = e.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return n && n.triggerHeartbeat(), e.container.getProvider(t) } function v(e, t, n = u) { y(e, t).clearInstance(n) } function w() { f.clear() } const b = new i.LL("app", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", "bad-app-name": "Illegal App name: '{$appName}", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "storage-delete": "Error thrown when deleting from storage. Original error: {$originalErrorMessage}." }); class _ { constructor(e, t, n) { this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = n, this.container.addComponent(new r.wA("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(e) { this.checkDestroyed(), this._automaticDataCollectionEnabled = e } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(e) { this._isDeleted = e } checkDestroyed() { if (this.isDeleted) throw b.create("app-deleted", { appName: this._name }) } } const E = "9.6.9"; function C(e, t = {}) { "object" != typeof t && (t = { name: t }); const n = Object.assign({ name: u, automaticDataCollectionEnabled: !1 }, t), s = n.name; if ("string" != typeof s || !s) throw b.create("bad-app-name", { appName: String(s) }); const o = d.get(s); if (o) { if ((0, i.vZ)(e, o.options) && (0, i.vZ)(n, o.config)) return o; throw b.create("duplicate-app", { appName: s }) } const a = new r.H0(s); for (const r of f.values()) a.addComponent(r); const c = new _(e, n, a); return d.set(s, c), c } function S(e = u) { const t = d.get(e); if (!t) throw b.create("no-app", { appName: e }); return t } function T() { return Array.from(d.values()) } async function I(e) { const t = e.name; d.has(t) && (d.delete(t), await Promise.all(e.container.getProviders().map(e => e.delete())), e.isDeleted = !0) } function k(e, t, n) { var s; let i = null !== (s = h[e]) && void 0 !== s ? s : e; n && (i += `-${n}`); const o = i.match(/\s|\//), a = t.match(/\s|\//); if (o || a) { const e = [`Unable to register library "${i}" with version "${t}":`]; return o && e.push(`library name "${i}" contains illegal characters (whitespace or "/")`), o && a && e.push("and"), a && e.push(`version name "${t}" contains illegal characters (whitespace or "/")`), void l.warn(e.join(" ")) } g(new r.wA(`${i}-version`, () => ({ library: i, version: t }), "VERSION")) } function A(e, t) { if (null !== e && "function" != typeof e) throw b.create("invalid-log-argument"); (0, s.Am)(e, t) } function x(e) { (0, s.Ub)(e) } const D = "firebase-heartbeat-store"; let O = null; function R() { return O || (O = (0, i.X3)("firebase-heartbeat-database", 1, (e, t) => { switch (t) { case 0: e.createObjectStore(D) } }).catch(e => { throw b.create("storage-open", { originalErrorMessage: e.message }) })), O } async function N(e, t) { try { const n = (await R()).transaction(D, "readwrite"), r = n.objectStore(D); return await r.put(t, P(e)), n.complete } catch (n) { throw b.create("storage-set", { originalErrorMessage: n.message }) } } function P(e) { return `${e.name}!${e.options.appId}` } class F { constructor(e) { this.container = e, this._heartbeatsCache = null; const t = this.container.getProvider("app").getImmediate(); this._storage = new M(t), this._heartbeatsCachePromise = this._storage.read().then(e => (this._heartbeatsCache = e, e)) } async triggerHeartbeat() { const e = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), t = L(); if (null === this._heartbeatsCache && (this._heartbeatsCache = await this._heartbeatsCachePromise), this._heartbeatsCache.lastSentHeartbeatDate !== t && !this._heartbeatsCache.heartbeats.some(e => e.date === t)) return this._heartbeatsCache.heartbeats.push({ date: t, agent: e }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(e => { const t = new Date(e.date).valueOf(); return Date.now() - t <= 2592e6 }), this._storage.overwrite(this._heartbeatsCache) } async getHeartbeatsHeader() { if (null === this._heartbeatsCache && await this._heartbeatsCachePromise, null === this._heartbeatsCache || 0 === this._heartbeatsCache.heartbeats.length) return ""; const e = L(), { heartbeatsToSend: t, unsentEntries: n } = function (e, t = 1024) { const n = []; let r = e.slice(); for (const s of e) { const e = n.find(e => e.agent === s.agent); if (e) { if (e.dates.push(s.date), $(n) > t) { e.dates.pop(); break } } else if (n.push({ agent: s.agent, dates: [s.date] }), $(n) > t) { n.pop(); break } r = r.slice(1) } return { heartbeatsToSend: n, unsentEntries: r } }(this._heartbeatsCache.heartbeats), r = (0, i.L)(JSON.stringify({ version: 2, heartbeats: t })); return this._heartbeatsCache.lastSentHeartbeatDate = e, n.length > 0 ? (this._heartbeatsCache.heartbeats = n, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), r } } function L() { return (new Date).toISOString().substring(0, 10) } class M { constructor(e) { this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } async runIndexedDBEnvironmentCheck() { return !!(0, i.hl)() && (0, i.eu)().then(() => !0).catch(() => !1) } async read() { return await this._canUseIndexedDBPromise && await async function (e) { try { return (await R()).transaction(D).objectStore(D).get(P(e)) } catch (t) { throw b.create("storage-get", { originalErrorMessage: t.message }) } }(this.app) || { heartbeats: [] } } async overwrite(e) { var t; if (await this._canUseIndexedDBPromise) { const n = await this.read(); return N(this.app, { lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate, heartbeats: e.heartbeats }) } } async add(e) { var t; if (await this._canUseIndexedDBPromise) { const n = await this.read(); return N(this.app, { lastSentHeartbeatDate: null !== (t = e.lastSentHeartbeatDate) && void 0 !== t ? t : n.lastSentHeartbeatDate, heartbeats: [...n.heartbeats, ...e.heartbeats] }) } } } function $(e) { return (0, i.L)(JSON.stringify({ version: 2, heartbeats: e })).length } g(new r.wA("platform-logger", e => new o(e), "PRIVATE")), g(new r.wA("heartbeat", e => new F(e), "PRIVATE")), k(a, c, ""), k(a, c, "esm2017"), k("fire-js", "") }, 8604: (e, t, n) => { "use strict"; n.d(t, { wA: () => s, H0: () => a }); var r = n(3854); class s { constructor(e, t, n) { this.name = e, this.instanceFactory = t, this.type = n, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(e) { return this.instantiationMode = e, this } setMultipleInstances(e) { return this.multipleInstances = e, this } setServiceProps(e) { return this.serviceProps = e, this } setInstanceCreatedCallback(e) { return this.onInstanceCreated = e, this } } const i = "[DEFAULT]"; class o { constructor(e, t) { this.name = e, this.container = t, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(e) { const t = this.normalizeInstanceIdentifier(e); if (!this.instancesDeferred.has(t)) { const e = new r.BH; if (this.instancesDeferred.set(t, e), this.isInitialized(t) || this.shouldAutoInitialize()) try { const n = this.getOrInitializeService({ instanceIdentifier: t }); n && e.resolve(n) } catch (n) { } } return this.instancesDeferred.get(t).promise } getImmediate(e) { var t; const n = this.normalizeInstanceIdentifier(null == e ? void 0 : e.identifier), r = null !== (t = null == e ? void 0 : e.optional) && void 0 !== t && t; if (!this.isInitialized(n) && !this.shouldAutoInitialize()) { if (r) return null; throw Error(`Service ${this.name} is not available`) } try { return this.getOrInitializeService({ instanceIdentifier: n }) } catch (s) { if (r) return null; throw s } } getComponent() { return this.component } setComponent(e) { if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = e, this.shouldAutoInitialize()) { if (function (e) { return "EAGER" === e.instantiationMode }(e)) try { this.getOrInitializeService({ instanceIdentifier: i }) } catch (t) { } for (const [e, n] of this.instancesDeferred.entries()) { const r = this.normalizeInstanceIdentifier(e); try { const e = this.getOrInitializeService({ instanceIdentifier: r }); n.resolve(e) } catch (t) { } } } } clearInstance(e = "[DEFAULT]") { this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e) } async delete() { const e = Array.from(this.instances.values()); await Promise.all([...e.filter(e => "INTERNAL" in e).map(e => e.INTERNAL.delete()), ...e.filter(e => "_delete" in e).map(e => e._delete())]) } isComponentSet() { return null != this.component } isInitialized(e = "[DEFAULT]") { return this.instances.has(e) } getOptions(e = "[DEFAULT]") { return this.instancesOptions.get(e) || {} } initialize(e = {}) { const { options: t = {} } = e, n = this.normalizeInstanceIdentifier(e.instanceIdentifier); if (this.isInitialized(n)) throw Error(`${this.name}(${n}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const r = this.getOrInitializeService({ instanceIdentifier: n, options: t }); for (const [s, i] of this.instancesDeferred.entries()) n === this.normalizeInstanceIdentifier(s) && i.resolve(r); return r } onInit(e, t) { var n; const r = this.normalizeInstanceIdentifier(t), s = null !== (n = this.onInitCallbacks.get(r)) && void 0 !== n ? n : new Set; s.add(e), this.onInitCallbacks.set(r, s); const i = this.instances.get(r); return i && e(i, r), () => { s.delete(e) } } invokeOnInitCallbacks(e, t) { const n = this.onInitCallbacks.get(t); if (n) for (const s of n) try { s(e, t) } catch (r) { } } getOrInitializeService({ instanceIdentifier: e, options: t = {} }) { let n = this.instances.get(e); if (!n && this.component && (n = this.component.instanceFactory(this.container, { instanceIdentifier: (r = e, r === i ? void 0 : r), options: t }), this.instances.set(e, n), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(n, e), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, e, n) } catch (s) { } var r; return n || null } normalizeInstanceIdentifier(e = "[DEFAULT]") { return this.component ? this.component.multipleInstances ? e : i : e } shouldAutoInitialize() { return !!this.component && "EXPLICIT" !== this.component.instantiationMode } } class a { constructor(e) { this.name = e, this.providers = new Map } addComponent(e) { const t = this.getProvider(e.name); if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`); t.setComponent(e) } addOrOverwriteComponent(e) { this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e) } getProvider(e) { if (this.providers.has(e)) return this.providers.get(e); const t = new o(e, this); return this.providers.set(e, t), t } getProviders() { return Array.from(this.providers.values()) } } }, 9306: (e, t, n) => { "use strict"; n.d(t, { in: () => s, Yd: () => l, Ub: () => u, Am: () => h }); const r = []; var s = (() => (function (e) { e[e.DEBUG = 0] = "DEBUG", e[e.VERBOSE = 1] = "VERBOSE", e[e.INFO = 2] = "INFO", e[e.WARN = 3] = "WARN", e[e.ERROR = 4] = "ERROR", e[e.SILENT = 5] = "SILENT" }(s || (s = {})), s))(); const i = { debug: s.DEBUG, verbose: s.VERBOSE, info: s.INFO, warn: s.WARN, error: s.ERROR, silent: s.SILENT }, o = s.INFO, a = { [s.DEBUG]: "log", [s.VERBOSE]: "log", [s.INFO]: "info", [s.WARN]: "warn", [s.ERROR]: "error" }, c = (e, t, ...n) => { if (t < e.logLevel) return; const r = (new Date).toISOString(), s = a[t]; if (!s) throw new Error(`Attempted to log a message with an invalid logType (value: ${t})`); console[s](`[${r}]  ${e.name}:`, ...n) }; class l { constructor(e) { this.name = e, this._logLevel = o, this._logHandler = c, this._userLogHandler = null, r.push(this) } get logLevel() { return this._logLevel } set logLevel(e) { if (!(e in s)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``); this._logLevel = e } setLogLevel(e) { this._logLevel = "string" == typeof e ? i[e] : e } get logHandler() { return this._logHandler } set logHandler(e) { if ("function" != typeof e) throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = e } get userLogHandler() { return this._userLogHandler } set userLogHandler(e) { this._userLogHandler = e } debug(...e) { this._userLogHandler && this._userLogHandler(this, s.DEBUG, ...e), this._logHandler(this, s.DEBUG, ...e) } log(...e) { this._userLogHandler && this._userLogHandler(this, s.VERBOSE, ...e), this._logHandler(this, s.VERBOSE, ...e) } info(...e) { this._userLogHandler && this._userLogHandler(this, s.INFO, ...e), this._logHandler(this, s.INFO, ...e) } warn(...e) { this._userLogHandler && this._userLogHandler(this, s.WARN, ...e), this._logHandler(this, s.WARN, ...e) } error(...e) { this._userLogHandler && this._userLogHandler(this, s.ERROR, ...e), this._logHandler(this, s.ERROR, ...e) } } function u(e) { r.forEach(t => { t.setLogLevel(e) }) } function h(e, t) { for (const n of r) { let r = null; t && t.level && (r = i[t.level]), n.userLogHandler = null === e ? null : (t, n, ...i) => { const o = i.map(e => { if (null == e) return null; if ("string" == typeof e) return e; if ("number" == typeof e || "boolean" == typeof e) return e.toString(); if (e instanceof Error) return e.message; try { return JSON.stringify(e) } catch (t) { return null } }).filter(e => e).join(" "); n >= (null != r ? r : t.logLevel) && e({ level: s[n].toLowerCase(), message: o, args: i, type: t.name }) } } } }, 3854: (e, t, n) => { "use strict"; n.d(t, { BH: () => c, LL: () => S, ZR: () => C, zI: () => E, US: () => s, tV: () => o, L: () => i, $s: () => L, r3: () => I, Sg: () => l, ne: () => N, vZ: () => A, ZB: () => a, Lj: () => z, pd: () => R, m9: () => M, z$: () => u, jU: () => f, ru: () => p, d: () => g, xb: () => k, w1: () => y, hl: () => b, uI: () => h, UG: () => d, b$: () => m, G6: () => w, Mn: () => v, X3: () => q, xO: () => D, zd: () => O, eu: () => _ }); const r = function (e) { const t = []; let n = 0; for (let r = 0; r < e.length; r++) { let s = e.charCodeAt(r); s < 128 ? t[n++] = s : s < 2048 ? (t[n++] = s >> 6 | 192, t[n++] = 63 & s | 128) : 55296 == (64512 & s) && r + 1 < e.length && 56320 == (64512 & e.charCodeAt(r + 1)) ? (s = 65536 + ((1023 & s) << 10) + (1023 & e.charCodeAt(++r)), t[n++] = s >> 18 | 240, t[n++] = s >> 12 & 63 | 128, t[n++] = s >> 6 & 63 | 128, t[n++] = 63 & s | 128) : (t[n++] = s >> 12 | 224, t[n++] = s >> 6 & 63 | 128, t[n++] = 63 & s | 128) } return t }, s = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: "function" == typeof atob, encodeByteArray(e, t) { if (!Array.isArray(e)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const n = t ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = []; for (let s = 0; s < e.length; s += 3) { const t = e[s], i = s + 1 < e.length, o = i ? e[s + 1] : 0, a = s + 2 < e.length, c = a ? e[s + 2] : 0; let l = (15 & o) << 2 | c >> 6, u = 63 & c; a || (u = 64, i || (l = 64)), r.push(n[t >> 2], n[(3 & t) << 4 | o >> 4], n[l], n[u]) } return r.join("") }, encodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? btoa(e) : this.encodeByteArray(r(e), t) }, decodeString(e, t) { return this.HAS_NATIVE_SUPPORT && !t ? atob(e) : function (e) { const t = []; let n = 0, r = 0; for (; n < e.length;) { const s = e[n++]; if (s < 128) t[r++] = String.fromCharCode(s); else if (s > 191 && s < 224) { const i = e[n++]; t[r++] = String.fromCharCode((31 & s) << 6 | 63 & i) } else if (s > 239 && s < 365) { const i = ((7 & s) << 18 | (63 & e[n++]) << 12 | (63 & e[n++]) << 6 | 63 & e[n++]) - 65536; t[r++] = String.fromCharCode(55296 + (i >> 10)), t[r++] = String.fromCharCode(56320 + (1023 & i)) } else { const i = e[n++], o = e[n++]; t[r++] = String.fromCharCode((15 & s) << 12 | (63 & i) << 6 | 63 & o) } } return t.join("") }(this.decodeStringToByteArray(e, t)) }, decodeStringToByteArray(e, t) { this.init_(); const n = t ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = []; for (let s = 0; s < e.length;) { const t = n[e.charAt(s++)], i = s < e.length ? n[e.charAt(s)] : 0; ++s; const o = s < e.length ? n[e.charAt(s)] : 64; ++s; const a = s < e.length ? n[e.charAt(s)] : 64; if (++s, null == t || null == i || null == o || null == a) throw Error(); r.push(t << 2 | i >> 4), 64 !== o && (r.push(i << 4 & 240 | o >> 2), 64 !== a && r.push(o << 6 & 192 | a)) } return r }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let e = 0; e < this.ENCODED_VALS.length; e++)this.byteToCharMap_[e] = this.ENCODED_VALS.charAt(e), this.charToByteMap_[this.byteToCharMap_[e]] = e, this.byteToCharMapWebSafe_[e] = this.ENCODED_VALS_WEBSAFE.charAt(e), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[e]] = e, e >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(e)] = e, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(e)] = e) } } }, i = function (e) { return function (e) { const t = r(e); return s.encodeByteArray(t, !0) }(e).replace(/\./g, "") }, o = function (e) { try { return s.decodeString(e, !0) } catch (t) { console.error("base64Decode failed: ", t) } return null }; function a(e, t) { if (!(t instanceof Object)) return t; switch (t.constructor) { case Date: return new Date(t.getTime()); case Object: void 0 === e && (e = {}); break; case Array: e = []; break; default: return t }for (const n in t) t.hasOwnProperty(n) && "__proto__" !== n && (e[n] = a(e[n], t[n])); return e } class c { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } wrapCallback(e) { return (t, n) => { t ? this.reject(t) : this.resolve(n), "function" == typeof e && (this.promise.catch(() => { }), 1 === e.length ? e(t) : e(t, n)) } } } function l(e, t) { if (e.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); const n = t || "demo-project", r = e.iat || 0, s = e.sub || e.user_id; if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const o = Object.assign({ iss: `https://securetoken.google.com/${n}`, aud: n, iat: r, exp: r + 3600, auth_time: r, sub: s, user_id: s, firebase: { sign_in_provider: "custom", identities: {} } }, e); return [i(JSON.stringify({ alg: "none", type: "JWT" })), i(JSON.stringify(o)), ""].join(".") } function u() { return "undefined" != typeof navigator && "string" == typeof navigator.userAgent ? navigator.userAgent : "" } function h() { return "undefined" != typeof window && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(u()) } function d() { try { return "[object process]" === Object.prototype.toString.call(global.process) } catch (e) { return !1 } } function f() { return "object" == typeof self && self.self === self } function p() { const e = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0; return "object" == typeof e && void 0 !== e.id } function m() { return "object" == typeof navigator && "ReactNative" === navigator.product } function g() { return u().indexOf("Electron/") >= 0 } function y() { const e = u(); return e.indexOf("MSIE ") >= 0 || e.indexOf("Trident/") >= 0 } function v() { return u().indexOf("MSAppHost/") >= 0 } function w() { return !d() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") } function b() { return "object" == typeof indexedDB } function _() { return new Promise((e, t) => { try { let n = !0; const r = "validate-browser-context-for-indexeddb-analytics-module", s = self.indexedDB.open(r); s.onsuccess = () => { s.result.close(), n || self.indexedDB.deleteDatabase(r), e(!0) }, s.onupgradeneeded = () => { n = !1 }, s.onerror = () => { var e; t((null === (e = s.error) || void 0 === e ? void 0 : e.message) || "") } } catch (n) { t(n) } }) } function E() { return !("undefined" == typeof navigator || !navigator.cookieEnabled) } class C extends Error { constructor(e, t, n) { super(t), this.code = e, this.customData = n, this.name = "FirebaseError", Object.setPrototypeOf(this, C.prototype), Error.captureStackTrace && Error.captureStackTrace(this, S.prototype.create) } } class S { constructor(e, t, n) { this.service = e, this.serviceName = t, this.errors = n } create(e, ...t) { const n = t[0] || {}, r = `${this.service}/${e}`, s = this.errors[e], i = s ? function (e, t) { return e.replace(T, (e, n) => { const r = t[n]; return null != r ? String(r) : `<${n}?>` }) }(s, n) : "Error"; return new C(r, `${this.serviceName}: ${i} (${r}).`, n) } } const T = /\{\$([^}]+)}/g; function I(e, t) { return Object.prototype.hasOwnProperty.call(e, t) } function k(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t)) return !1; return !0 } function A(e, t) { if (e === t) return !0; const n = Object.keys(e), r = Object.keys(t); for (const s of n) { if (!r.includes(s)) return !1; const n = e[s], i = t[s]; if (x(n) && x(i)) { if (!A(n, i)) return !1 } else if (n !== i) return !1 } for (const s of r) if (!n.includes(s)) return !1; return !0 } function x(e) { return null !== e && "object" == typeof e } function D(e) { const t = []; for (const [n, r] of Object.entries(e)) Array.isArray(r) ? r.forEach(e => { t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e)) }) : t.push(encodeURIComponent(n) + "=" + encodeURIComponent(r)); return t.length ? "&" + t.join("&") : "" } function O(e) { const t = {}; return e.replace(/^\?/, "").split("&").forEach(e => { if (e) { const [n, r] = e.split("="); t[decodeURIComponent(n)] = decodeURIComponent(r) } }), t } function R(e) { const t = e.indexOf("?"); if (!t) return ""; const n = e.indexOf("#", t); return e.substring(t, n > 0 ? n : void 0) } function N(e, t) { const n = new P(e, t); return n.subscribe.bind(n) } class P { constructor(e, t) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = t, this.task.then(() => { e(this) }).catch(e => { this.error(e) }) } next(e) { this.forEachObserver(t => { t.next(e) }) } error(e) { this.forEachObserver(t => { t.error(e) }), this.close(e) } complete() { this.forEachObserver(e => { e.complete() }), this.close() } subscribe(e, t, n) { let r; if (void 0 === e && void 0 === t && void 0 === n) throw new Error("Missing Observer."); r = function (e, t) { if ("object" != typeof e || null === e) return !1; for (const n of ["next", "error", "complete"]) if (n in e && "function" == typeof e[n]) return !0; return !1 }(e) ? e : { next: e, error: t, complete: n }, void 0 === r.next && (r.next = F), void 0 === r.error && (r.error = F), void 0 === r.complete && (r.complete = F); const s = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then(() => { try { this.finalError ? r.error(this.finalError) : r.complete() } catch (e) { } }), this.observers.push(r), s } unsubscribeOne(e) { void 0 !== this.observers && void 0 !== this.observers[e] && (delete this.observers[e], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this)) } forEachObserver(e) { if (!this.finalized) for (let t = 0; t < this.observers.length; t++)this.sendOne(t, e) } sendOne(e, t) { this.task.then(() => { if (void 0 !== this.observers && void 0 !== this.observers[e]) try { t(this.observers[e]) } catch (n) { "undefined" != typeof console && console.error && console.error(n) } }) } close(e) { this.finalized || (this.finalized = !0, void 0 !== e && (this.finalError = e), this.task.then(() => { this.observers = void 0, this.onNoObservers = void 0 })) } } function F() { } function L(e, t = 1e3, n = 2) { const r = t * Math.pow(n, e), s = Math.round(.5 * r * (Math.random() - .5) * 2); return Math.min(144e5, r + s) } function M(e) { return e && e._delegate ? e._delegate : e } function $(e, t) { return new Promise((n, r) => { e.onsuccess = e => { n(e.target.result) }, e.onerror = e => { var n; r(`${t}: ${null === (n = e.target.error) || void 0 === n ? void 0 : n.message}`) } }) } class B { constructor(e) { this._db = e, this.objectStoreNames = this._db.objectStoreNames } transaction(e, t) { return new V(this._db.transaction.call(this._db, e, t)) } createObjectStore(e, t) { return new U(this._db.createObjectStore(e, t)) } close() { this._db.close() } } class V { constructor(e) { this._transaction = e, this.complete = new Promise((e, t) => { this._transaction.oncomplete = function () { e() }, this._transaction.onerror = () => { t(this._transaction.error) }, this._transaction.onabort = () => { t(this._transaction.error) } }) } objectStore(e) { return new U(this._transaction.objectStore(e)) } } class U { constructor(e) { this._store = e } index(e) { return new j(this._store.index(e)) } createIndex(e, t, n) { return new j(this._store.createIndex(e, t, n)) } get(e) { return $(this._store.get(e), "Error reading from IndexedDB") } put(e, t) { return $(this._store.put(e, t), "Error writing to IndexedDB") } delete(e) { return $(this._store.delete(e), "Error deleting from IndexedDB") } clear() { return $(this._store.clear(), "Error clearing IndexedDB object store") } } class j { constructor(e) { this._index = e } get(e) { return $(this._index.get(e), "Error reading from IndexedDB") } } function q(e, t, n) { return new Promise((r, s) => { try { const i = indexedDB.open(e, t); i.onsuccess = e => { r(new B(e.target.result)) }, i.onerror = e => { var t; s(`Error opening indexedDB: ${null === (t = e.target.error) || void 0 === t ? void 0 : t.message}`) }, i.onupgradeneeded = e => { n(new B(i.result), e.oldVersion, e.newVersion, new V(i.transaction)) } } catch (i) { s(`Error opening indexedDB: ${i.message}`) } }) } async function z(e) { return new Promise((t, n) => { try { const r = indexedDB.deleteDatabase(e); r.onsuccess = () => { t() }, r.onerror = t => { var r; n(`Error deleting indexedDB database "${e}": ${null === (r = t.target.error) || void 0 === r ? void 0 : r.message}`) } } catch (r) { n(`Error deleting indexedDB database "${e}": ${r.message}`) } }) } }, 2859: (e, t, n) => { "use strict"; function r(e, t, n, r) { var s, i = arguments.length, o = i < 3 ? t : null === r ? r = Object.getOwnPropertyDescriptor(t, n) : r; if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) o = Reflect.decorate(e, t, n, r); else for (var a = e.length - 1; a >= 0; a--)(s = e[a]) && (o = (i < 3 ? s(o) : i > 3 ? s(t, n, o) : s(t, n)) || o); return i > 3 && o && Object.defineProperty(t, n, o), o } function s(e, t) { return function (n, r) { t(n, r, e) } } function i(e, t, n, r) { return new (n || (n = Promise))(function (s, i) { function o(e) { try { c(r.next(e)) } catch (t) { i(t) } } function a(e) { try { c(r.throw(e)) } catch (t) { i(t) } } function c(e) { var t; e.done ? s(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) { e(t) })).then(o, a) } c((r = r.apply(e, t || [])).next()) }) } n.d(t, { dr: () => re, BJ: () => se, oU: () => ie, cs: () => ot, YG: () => oe, Sm: () => ae, PM: () => ce, FN: () => le, Zi: () => ue, tO: () => he, wI: () => de, W2: () => fe, fr: () => pe, Gu: () => me, gu: () => ge, pK: () => ye, Ie: () => ve, Q$: () => we, q_: () => be, yh: () => _e, z0: () => Ee, fG: () => Ce, uN: () => Se, jP: () => rt, Nd: () => Te, VI: () => Ie, t9: () => ke, n0: () => Ae, A$: () => xe, Hr: () => De, yq: () => Oe, ZU: () => Re, UN: () => it, yW: () => Ne, g2: () => Pe, wd: () => Fe, sr: () => Le, Pc: () => St, r4: () => _t, _q: () => dt, IN: () => pt, t4: () => G, YI: () => at, QI: () => q, j9: () => H }); var o = n(8720), a = n(665), c = n(8583), l = n(4026), u = n(4086), h = (n(9554), n(7405), n(7807)), d = n(9461), f = n(7585), p = n(2377), m = n(4001), g = n(5554), y = n(7053), v = (n(960), n(3150)), w = n(9765), b = n(2759), _ = n(6215), E = n(5435), C = n(3190), S = n(7519); const T = f.i, I = ["*"], k = ["outlet"], A = [[["", "slot", "top"]], "*"], x = ["[slot=top]", "*"], D = e => "function" == typeof __zone_symbol__requestAnimationFrame ? __zone_symbol__requestAnimationFrame(e) : "function" == typeof requestAnimationFrame ? requestAnimationFrame(e) : setTimeout(e); let O = (() => { class e { constructor(e, t) { this.injector = e, this.el = t, this.onChange = () => { }, this.onTouched = () => { } } writeValue(e) { this.el.nativeElement.value = this.lastValue = null == e ? "" : e, R(this.el) } handleChangeEvent(e, t) { e === this.el.nativeElement && (t !== this.lastValue && (this.lastValue = t, this.onChange(t)), R(this.el)) } _handleBlurEvent(e) { e === this.el.nativeElement && (this.onTouched(), R(this.el)) } registerOnChange(e) { this.onChange = e } registerOnTouched(e) { this.onTouched = e } setDisabledState(e) { this.el.nativeElement.disabled = e } ngOnDestroy() { this.statusChanges && this.statusChanges.unsubscribe() } ngAfterViewInit() { let e; try { e = this.injector.get(a.a5) } catch (n) { } if (!e) return; e.statusChanges && (this.statusChanges = e.statusChanges.subscribe(() => R(this.el))); const t = e.control; t && ["markAsTouched", "markAllAsTouched", "markAsUntouched", "markAsDirty", "markAsPristine"].forEach(e => { if (t[e]) { const n = t[e].bind(t); t[e] = (...e) => { n(...e), R(this.el) } } }) } } return e.\u0275fac = function (e) { o.$Z() }, e.\u0275dir = o.lG2({ type: e, hostBindings: function (e, t) { 1 & e && o.NdJ("ionBlur", function (e) { return t._handleBlurEvent(e.target) }) } }), r([(0, o.L6J)("ionBlur", ["$event.target"])], e.prototype, "_handleBlurEvent", null), e })(); const R = e => { D(() => { const t = e.nativeElement, n = N(t); P(t, n); const r = t.closest("ion-item"); r && P(r, n) }) }, N = e => { const t = e.classList, n = []; for (let r = 0; r < t.length; r++) { const e = t.item(r); null !== e && F(e, "ng-") && n.push(`ion-${e.substr(3)}`) } return n }, P = (e, t) => { const n = e.classList;["ion-valid", "ion-invalid", "ion-touched", "ion-untouched", "ion-dirty", "ion-pristine"].forEach(e => n.remove(e)), t.forEach(e => n.add(e)) }, F = (e, t) => e.substr(0, t.length) === t; var L; let M = L = class extends O { constructor(e, t) { super(e, t) } writeValue(e) { this.el.nativeElement.checked = this.lastValue = null != e && e, R(this.el) } _handleIonChange(e) { this.handleChangeEvent(e, e.checked) } }; var $; M.\u0275fac = function (e) { return new (e || M)(o.Y36(o.zs3), o.Y36(o.SBq)) }, M.\u0275dir = o.lG2({ type: M, selectors: [["ion-checkbox"], ["ion-toggle"]], hostBindings: function (e, t) { 1 & e && o.NdJ("ionChange", function (e) { return t._handleIonChange(e.target) }) }, features: [o._Bn([{ provide: a.JU, useExisting: L, multi: !0 }]), o.qOj] }), M.ctorParameters = () => [{ type: o.zs3 }, { type: o.SBq }], r([(0, o.L6J)("ionChange", ["$event.target"])], M.prototype, "_handleIonChange", null); let B = $ = class extends O { constructor(e, t) { super(e, t) } _handleIonChange(e) { this.handleChangeEvent(e, e.value) } registerOnChange(e) { super.registerOnChange(t => { e("" === t ? null : parseFloat(t)) }) } }; var V; B.\u0275fac = function (e) { return new (e || B)(o.Y36(o.zs3), o.Y36(o.SBq)) }, B.\u0275dir = o.lG2({ type: B, selectors: [["ion-input", "type", "number"]], hostBindings: function (e, t) { 1 & e && o.NdJ("ionChange", function (e) { return t._handleIonChange(e.target) }) }, features: [o._Bn([{ provide: a.JU, useExisting: $, multi: !0 }]), o.qOj] }), B.ctorParameters = () => [{ type: o.zs3 }, { type: o.SBq }], r([(0, o.L6J)("ionChange", ["$event.target"])], B.prototype, "_handleIonChange", null); let U = V = class extends O { constructor(e, t) { super(e, t) } _handleIonSelect(e) { this.handleChangeEvent(e, e.checked) } }; var j; U.\u0275fac = function (e) { return new (e || U)(o.Y36(o.zs3), o.Y36(o.SBq)) }, U.\u0275dir = o.lG2({ type: U, selectors: [["ion-radio"]], hostBindings: function (e, t) { 1 & e && o.NdJ("ionSelect", function (e) { return t._handleIonSelect(e.target) }) }, features: [o._Bn([{ provide: a.JU, useExisting: V, multi: !0 }]), o.qOj] }), U.ctorParameters = () => [{ type: o.zs3 }, { type: o.SBq }], r([(0, o.L6J)("ionSelect", ["$event.target"])], U.prototype, "_handleIonSelect", null); let q = j = class extends O { constructor(e, t) { super(e, t) } _handleChangeEvent(e) { this.handleChangeEvent(e, e.value) } }; var z; q.\u0275fac = function (e) { return new (e || q)(o.Y36(o.zs3), o.Y36(o.SBq)) }, q.\u0275dir = o.lG2({ type: q, selectors: [["ion-range"], ["ion-select"], ["ion-radio-group"], ["ion-segment"], ["ion-datetime"]], hostBindings: function (e, t) { 1 & e && o.NdJ("ionChange", function (e) { return t._handleChangeEvent(e.target) }) }, features: [o._Bn([{ provide: a.JU, useExisting: j, multi: !0 }]), o.qOj] }), q.ctorParameters = () => [{ type: o.zs3 }, { type: o.SBq }], r([(0, o.L6J)("ionChange", ["$event.target"])], q.prototype, "_handleChangeEvent", null); let H = z = class extends O { constructor(e, t) { super(e, t) } _handleInputEvent(e) { this.handleChangeEvent(e, e.value) } }; H.\u0275fac = function (e) { return new (e || H)(o.Y36(o.zs3), o.Y36(o.SBq)) }, H.\u0275dir = o.lG2({ type: H, selectors: [["ion-input", 3, "type", "number"], ["ion-textarea"], ["ion-searchbar"]], hostBindings: function (e, t) { 1 & e && o.NdJ("ionChange", function (e) { return t._handleInputEvent(e.target) }) }, features: [o._Bn([{ provide: a.JU, useExisting: z, multi: !0 }]), o.qOj] }), H.ctorParameters = () => [{ type: o.zs3 }, { type: o.SBq }], r([(0, o.L6J)("ionChange", ["$event.target"])], H.prototype, "_handleInputEvent", null); let G = class { constructor(e, t) { this.doc = e, this.backButton = new w.xQ, this.keyboardDidShow = new w.xQ, this.keyboardDidHide = new w.xQ, this.pause = new w.xQ, this.resume = new w.xQ, this.resize = new w.xQ, t.run(() => { let n; this.win = e.defaultView, this.backButton.subscribeWithPriority = function (e, n) { return this.subscribe(r => r.register(e, e => t.run(() => n(e)))) }, Y(this.pause, e, "pause"), Y(this.resume, e, "resume"), Y(this.backButton, e, "ionBackButton"), Y(this.resize, this.win, "resize"), Y(this.keyboardDidShow, this.win, "ionKeyboardDidShow"), Y(this.keyboardDidHide, this.win, "ionKeyboardDidHide"), this._readyPromise = new Promise(e => { n = e }), this.win && this.win.cordova ? e.addEventListener("deviceready", () => { n("cordova") }, { once: !0 }) : n("dom") }) } is(e) { return (0, f.a)(this.win, e) } platforms() { return (0, f.g)(this.win) } ready() { return this._readyPromise } get isRTL() { return "rtl" === this.doc.dir } getQueryParam(e) { return W(this.win.location.href, e) } isLandscape() { return !this.isPortrait() } isPortrait() { return this.win.matchMedia && this.win.matchMedia("(orientation: portrait)").matches } testUserAgent(e) { const t = this.win.navigator; return !!(t && t.userAgent && t.userAgent.indexOf(e) >= 0) } url() { return this.win.location.href } width() { return this.win.innerWidth } height() { return this.win.innerHeight } }; G.\u0275fac = function (e) { return new (e || G)(o.LFG(c.K0), o.LFG(o.R0b)) }, G.\u0275prov = o.Yz7({ token: G, factory: function (e) { return G.\u0275fac(e) }, providedIn: "root" }), G.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new G((0, o.LFG)(c.K0), (0, o.LFG)(o.R0b)) }, token: G, providedIn: "root" }), G = r([s(0, (0, o.tBr)(c.K0))], G); const W = (e, t) => { t = t.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]"); const n = new RegExp("[\\?&]" + t + "=([^&#]*)").exec(e); return n ? decodeURIComponent(n[1].replace(/\+/g, " ")) : null }, Y = (e, t, n) => { t && t.addEventListener(n, t => { e.next(null != t ? t.detail : void 0) }) }; let K = class { constructor(e, t, n, r) { this.location = t, this.serializer = n, this.router = r, this.direction = Z, this.animated = Q, this.guessDirection = "forward", this.lastNavId = -1, r && r.events.subscribe(e => { if (e instanceof l.OD) { const t = e.restoredState ? e.restoredState.navigationId : e.id; this.guessDirection = t < this.lastNavId ? "back" : "forward", this.guessAnimation = e.restoredState ? void 0 : this.guessDirection, this.lastNavId = "forward" === this.guessDirection ? e.id : t } }), e.backButton.subscribeWithPriority(0, e => { this.pop(), e() }) } navigateForward(e, t = {}) { return this.setDirection("forward", t.animated, t.animationDirection, t.animation), this.navigate(e, t) } navigateBack(e, t = {}) { return this.setDirection("back", t.animated, t.animationDirection, t.animation), this.navigate(e, t) } navigateRoot(e, t = {}) { return this.setDirection("root", t.animated, t.animationDirection, t.animation), this.navigate(e, t) } back(e = { animated: !0, animationDirection: "back" }) { return this.setDirection("back", e.animated, e.animationDirection, e.animation), this.location.back() } pop() { return i(this, void 0, void 0, function* () { let e = this.topOutlet; for (; e && !(yield e.pop());)e = e.parentOutlet }) } setDirection(e, t, n, r) { this.direction = e, this.animated = X(e, t, n), this.animationBuilder = r } setTopOutlet(e) { this.topOutlet = e } consumeTransition() { let e, t = "root"; const n = this.animationBuilder; return "auto" === this.direction ? (t = this.guessDirection, e = this.guessAnimation) : (e = this.animated, t = this.direction), this.direction = Z, this.animated = Q, this.animationBuilder = void 0, { direction: t, animation: e, animationBuilder: n } } navigate(e, t) { if (Array.isArray(e)) return this.router.navigate(e, t); { const n = this.serializer.parse(e.toString()); return void 0 !== t.queryParams && (n.queryParams = Object.assign({}, t.queryParams)), void 0 !== t.fragment && (n.fragment = t.fragment), this.router.navigateByUrl(n, t) } } }; K.\u0275fac = function (e) { return new (e || K)(o.LFG(G), o.LFG(c.Ye), o.LFG(l.Hx), o.LFG(l.F0, 8)) }, K.\u0275prov = o.Yz7({ token: K, factory: function (e) { return K.\u0275fac(e) }, providedIn: "root" }), K.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new K((0, o.LFG)(G), (0, o.LFG)(c.Ye), (0, o.LFG)(l.Hx), (0, o.LFG)(l.F0, 8)) }, token: K, providedIn: "root" }), K = r([s(3, (0, o.FiY)())], K); const X = (e, t, n) => { if (!1 !== t) return void 0 !== n ? n : "forward" === e || "back" === e ? e : "root" === e && !0 === t ? "forward" : void 0 }, Z = "auto", Q = void 0, J = (e, t) => { const n = e.prototype; t.forEach(e => { Object.defineProperty(n, e, { get() { return this.el[e] }, set(t) { this.z.runOutsideAngular(() => this.el[e] = t) } }) }) }, ee = (e, t) => { const n = e.prototype; t.forEach(e => { n[e] = function () { const t = arguments; return this.z.runOutsideAngular(() => this.el[e].apply(this.el, t)) } }) }, te = (e, t, n) => { n.forEach(n => e[n] = (0, b.R)(t, n)) }; function ne(e) { return function (t) { return e.inputs && J(t, e.inputs), e.methods && ee(t, e.methods), t } } let re = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-app"]], ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e })(), se = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-avatar"]], ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e })(), ie = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-back-button"]], inputs: { color: "color", defaultHref: "defaultHref", disabled: "disabled", icon: "icon", mode: "mode", routerAnimation: "routerAnimation", text: "text", type: "type" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "defaultHref", "disabled", "icon", "mode", "routerAnimation", "text", "type"] })], e), e })(), oe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionFocus", "ionBlur"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-button"]], inputs: { buttonType: "buttonType", color: "color", disabled: "disabled", download: "download", expand: "expand", fill: "fill", href: "href", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", shape: "shape", size: "size", strong: "strong", target: "target", type: "type" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["buttonType", "color", "disabled", "download", "expand", "fill", "href", "mode", "rel", "routerAnimation", "routerDirection", "shape", "size", "strong", "target", "type"] })], e), e })(), ae = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-buttons"]], inputs: { collapse: "collapse" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["collapse"] })], e), e })(), ce = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-card"]], inputs: { button: "button", color: "color", disabled: "disabled", download: "download", href: "href", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", target: "target", type: "type" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["button", "color", "disabled", "download", "href", "mode", "rel", "routerAnimation", "routerDirection", "target", "type"] })], e), e })(), le = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-card-content"]], inputs: { mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["mode"] })], e), e })(), ue = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-card-header"]], inputs: { color: "color", mode: "mode", translucent: "translucent" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode", "translucent"] })], e), e })(), he = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-card-subtitle"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode"] })], e), e })(), de = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-col"]], inputs: { offset: "offset", offsetLg: "offsetLg", offsetMd: "offsetMd", offsetSm: "offsetSm", offsetXl: "offsetXl", offsetXs: "offsetXs", pull: "pull", pullLg: "pullLg", pullMd: "pullMd", pullSm: "pullSm", pullXl: "pullXl", pullXs: "pullXs", push: "push", pushLg: "pushLg", pushMd: "pushMd", pushSm: "pushSm", pushXl: "pushXl", pushXs: "pushXs", size: "size", sizeLg: "sizeLg", sizeMd: "sizeMd", sizeSm: "sizeSm", sizeXl: "sizeXl", sizeXs: "sizeXs" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["offset", "offsetLg", "offsetMd", "offsetSm", "offsetXl", "offsetXs", "pull", "pullLg", "pullMd", "pullSm", "pullXl", "pullXs", "push", "pushLg", "pushMd", "pushSm", "pushXl", "pushXs", "size", "sizeLg", "sizeMd", "sizeSm", "sizeXl", "sizeXs"] })], e), e })(), fe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionScrollStart", "ionScroll", "ionScrollEnd"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-content"]], inputs: { color: "color", forceOverscroll: "forceOverscroll", fullscreen: "fullscreen", scrollEvents: "scrollEvents", scrollX: "scrollX", scrollY: "scrollY" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "forceOverscroll", "fullscreen", "scrollEvents", "scrollX", "scrollY"], methods: ["getScrollElement", "scrollToTop", "scrollToBottom", "scrollByPoint", "scrollToPoint"] })], e), e })(), pe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-footer"]], inputs: { mode: "mode", translucent: "translucent" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["mode", "translucent"] })], e), e })(), me = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-header"]], inputs: { collapse: "collapse", mode: "mode", translucent: "translucent" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["collapse", "mode", "translucent"] })], e), e })(), ge = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-icon"]], inputs: { ariaHidden: "ariaHidden", ariaLabel: "ariaLabel", color: "color", flipRtl: "flipRtl", icon: "icon", ios: "ios", lazy: "lazy", md: "md", mode: "mode", name: "name", sanitize: "sanitize", size: "size", src: "src" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["ariaHidden", "ariaLabel", "color", "flipRtl", "icon", "ios", "lazy", "md", "mode", "name", "sanitize", "size", "src"] })], e), e })(), ye = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionInput", "ionChange", "ionBlur", "ionFocus"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-input"]], inputs: { accept: "accept", autocapitalize: "autocapitalize", autocomplete: "autocomplete", autocorrect: "autocorrect", autofocus: "autofocus", clearInput: "clearInput", clearOnEdit: "clearOnEdit", color: "color", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", inputmode: "inputmode", max: "max", maxlength: "maxlength", min: "min", minlength: "minlength", mode: "mode", multiple: "multiple", name: "name", pattern: "pattern", placeholder: "placeholder", readonly: "readonly", required: "required", size: "size", spellcheck: "spellcheck", step: "step", type: "type", value: "value" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["accept", "autocapitalize", "autocomplete", "autocorrect", "autofocus", "clearInput", "clearOnEdit", "color", "debounce", "disabled", "enterkeyhint", "inputmode", "max", "maxlength", "min", "minlength", "mode", "multiple", "name", "pattern", "placeholder", "readonly", "required", "size", "spellcheck", "step", "type", "value"], methods: ["setFocus", "getInputElement"] })], e), e })(), ve = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-item"]], inputs: { button: "button", color: "color", detail: "detail", detailIcon: "detailIcon", disabled: "disabled", download: "download", href: "href", lines: "lines", mode: "mode", rel: "rel", routerAnimation: "routerAnimation", routerDirection: "routerDirection", target: "target", type: "type" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["button", "color", "detail", "detailIcon", "disabled", "download", "href", "lines", "mode", "rel", "routerAnimation", "routerDirection", "target", "type"] })], e), e })(), we = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-label"]], inputs: { color: "color", mode: "mode", position: "position" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode", "position"] })], e), e })(), be = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-list"]], inputs: { inset: "inset", lines: "lines", mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["inset", "lines", "mode"], methods: ["closeSlidingItems"] })], e), e })(), _e = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-list-header"]], inputs: { color: "color", lines: "lines", mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "lines", "mode"] })], e), e })(), Ee = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionWillOpen", "ionWillClose", "ionDidOpen", "ionDidClose"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-menu"]], inputs: { contentId: "contentId", disabled: "disabled", maxEdgeStart: "maxEdgeStart", menuId: "menuId", side: "side", swipeGesture: "swipeGesture", type: "type" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["contentId", "disabled", "maxEdgeStart", "menuId", "side", "swipeGesture", "type"], methods: ["isOpen", "isActive", "open", "close", "toggle", "setOpen"] })], e), e })(), Ce = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-menu-button"]], inputs: { autoHide: "autoHide", color: "color", disabled: "disabled", menu: "menu", mode: "mode", type: "type" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["autoHide", "color", "disabled", "menu", "mode", "type"] })], e), e })(), Se = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-note"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode"] })], e), e })(), Te = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-row"]], ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e })(), Ie = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionInput", "ionChange", "ionCancel", "ionClear", "ionBlur", "ionFocus"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-searchbar"]], inputs: { animated: "animated", autocomplete: "autocomplete", autocorrect: "autocorrect", cancelButtonIcon: "cancelButtonIcon", cancelButtonText: "cancelButtonText", clearIcon: "clearIcon", color: "color", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", inputmode: "inputmode", mode: "mode", placeholder: "placeholder", searchIcon: "searchIcon", showCancelButton: "showCancelButton", showClearButton: "showClearButton", spellcheck: "spellcheck", type: "type", value: "value" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["animated", "autocomplete", "autocorrect", "cancelButtonIcon", "cancelButtonText", "clearIcon", "color", "debounce", "disabled", "enterkeyhint", "inputmode", "mode", "placeholder", "searchIcon", "showCancelButton", "showClearButton", "spellcheck", "type", "value"], methods: ["setFocus", "getInputElement"] })], e), e })(), ke = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionChange", "ionCancel", "ionFocus", "ionBlur"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-select"]], inputs: { cancelText: "cancelText", compareWith: "compareWith", disabled: "disabled", interface: "interface", interfaceOptions: "interfaceOptions", mode: "mode", multiple: "multiple", name: "name", okText: "okText", placeholder: "placeholder", selectedText: "selectedText", value: "value" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["cancelText", "compareWith", "disabled", "interface", "interfaceOptions", "mode", "multiple", "name", "okText", "placeholder", "selectedText", "value"], methods: ["open"] })], e), e })(), Ae = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-select-option"]], inputs: { disabled: "disabled", value: "value" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["disabled", "value"] })], e), e })(), xe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-slide"]], ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e })(), De = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionSlidesDidLoad", "ionSlideTap", "ionSlideDoubleTap", "ionSlideWillChange", "ionSlideDidChange", "ionSlideNextStart", "ionSlidePrevStart", "ionSlideNextEnd", "ionSlidePrevEnd", "ionSlideTransitionStart", "ionSlideTransitionEnd", "ionSlideDrag", "ionSlideReachStart", "ionSlideReachEnd", "ionSlideTouchStart", "ionSlideTouchEnd"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-slides"]], inputs: { mode: "mode", options: "options", pager: "pager", scrollbar: "scrollbar" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["mode", "options", "pager", "scrollbar"], methods: ["update", "updateAutoHeight", "slideTo", "slideNext", "slidePrev", "getActiveIndex", "getPreviousIndex", "length", "isEnd", "isBeginning", "startAutoplay", "stopAutoplay", "lockSwipeToNext", "lockSwipeToPrev", "lockSwipes", "getSwiper"] })], e), e })(), Oe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-tab-bar"]], inputs: { color: "color", mode: "mode", selectedTab: "selectedTab", translucent: "translucent" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode", "selectedTab", "translucent"] })], e), e })(), Re = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-tab-button"]], inputs: { disabled: "disabled", download: "download", href: "href", layout: "layout", mode: "mode", rel: "rel", selected: "selected", tab: "tab", target: "target" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["disabled", "download", "href", "layout", "mode", "rel", "selected", "tab", "target"] })], e), e })(), Ne = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-text"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode"] })], e), e })(), Pe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement, te(this, this.el, ["ionChange", "ionInput", "ionBlur", "ionFocus"]) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-textarea"]], inputs: { autoGrow: "autoGrow", autocapitalize: "autocapitalize", autofocus: "autofocus", clearOnEdit: "clearOnEdit", color: "color", cols: "cols", debounce: "debounce", disabled: "disabled", enterkeyhint: "enterkeyhint", inputmode: "inputmode", maxlength: "maxlength", minlength: "minlength", mode: "mode", name: "name", placeholder: "placeholder", readonly: "readonly", required: "required", rows: "rows", spellcheck: "spellcheck", value: "value", wrap: "wrap" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["autoGrow", "autocapitalize", "autofocus", "clearOnEdit", "color", "cols", "debounce", "disabled", "enterkeyhint", "inputmode", "maxlength", "minlength", "mode", "name", "placeholder", "readonly", "required", "rows", "spellcheck", "value", "wrap"], methods: ["setFocus", "getInputElement"] })], e), e })(), Fe = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-title"]], inputs: { color: "color", size: "size" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "size"] })], e), e })(), Le = (() => { let e = class { constructor(e, t, n) { this.z = n, e.detach(), this.el = t.nativeElement } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(o.sBO), o.Y36(o.SBq), o.Y36(o.R0b)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-toolbar"]], inputs: { color: "color", mode: "mode" }, ngContentSelectors: I, decls: 1, vars: 0, template: function (e, t) { 1 & e && (o.F$t(), o.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), e = r([ne({ inputs: ["color", "mode"] })], e), e })(), Me = class { get(e, t) { const n = Be(); return n ? n.get(e, t) : null } getBoolean(e, t) { const n = Be(); return !!n && n.getBoolean(e, t) } getNumber(e, t) { const n = Be(); return n ? n.getNumber(e, t) : 0 } set(e, t) { console.warn("[DEPRECATION][Config]: The Config.set() method is deprecated and will be removed in Ionic Framework 6.0. Please see https://ionicframework.com/docs/angular/config for alternatives."); const n = Be(); n && n.set(e, t) } }; Me.\u0275fac = function (e) { return new (e || Me) }, Me.\u0275prov = o.Yz7({ token: Me, factory: function (e) { return Me.\u0275fac(e) }, providedIn: "root" }), Me.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new Me }, token: Me, providedIn: "root" }); const $e = new o.OlP("USERCONFIG"), Be = () => { if ("undefined" != typeof window) { const e = window.Ionic; if (e && e.config) return e.config } return null }; class Ve { constructor(e = {}) { this.data = e } get(e) { return this.data[e] } } let Ue = (() => { let e = class { constructor(e, t) { this.zone = e, this.appRef = t } create(e, t, n) { return new je(e, t, n, this.appRef, this.zone) } }; return e.\u0275fac = function (t) { return new (t || e)(o.LFG(o.R0b), o.LFG(o.z2F)) }, e.\u0275prov = o.Yz7({ token: e, factory: function (t) { return e.\u0275fac(t) } }), e })(); class je { constructor(e, t, n, r, s) { this.resolver = e, this.injector = t, this.location = n, this.appRef = r, this.zone = s, this.elRefMap = new WeakMap, this.elEventsMap = new WeakMap } attachViewToDom(e, t, n, r) { return this.zone.run(() => new Promise(s => { s(qe(this.zone, this.resolver, this.injector, this.location, this.appRef, this.elRefMap, this.elEventsMap, e, t, n, r)) })) } removeViewFromDom(e, t) { return this.zone.run(() => new Promise(e => { const n = this.elRefMap.get(t); if (n) { n.destroy(), this.elRefMap.delete(t); const e = this.elEventsMap.get(t); e && (e(), this.elEventsMap.delete(t)) } e() })) } } const qe = (e, t, n, r, s, i, a, c, l, u, h) => { const d = t.resolveComponentFactory(l), f = o.zs3.create({ providers: We(u), parent: n }), p = r ? r.createComponent(d, r.length, f) : d.create(f), m = p.instance, g = p.location.nativeElement; if (u && Object.assign(m, u), h) for (const o of h) g.classList.add(o); const y = He(e, m, g); return c.appendChild(g), r || s.attachView(p.hostView), p.changeDetectorRef.reattach(), i.set(g, p), a.set(g, y), g }, ze = [m.L, m.a, m.b, m.c, m.d], He = (e, t, n) => e.run(() => { const e = ze.filter(e => "function" == typeof t[e]).map(e => { const r = n => t[e](n.detail); return n.addEventListener(e, r), () => n.removeEventListener(e, r) }); return () => e.forEach(e => e()) }), Ge = new o.OlP("NavParamsToken"), We = e => [{ provide: Ge, useValue: e }, { provide: Ve, useFactory: Ye, deps: [Ge] }], Ye = e => new Ve(e), Ke = (e, t) => ((e = e.filter(e => e.stackId !== t.stackId)).push(t), e), Xe = (e, t) => { const n = e.createUrlTree(["."], { relativeTo: t }); return e.serializeUrl(n) }, Ze = (e, t) => { if (!e) return; const n = Qe(t); for (let r = 0; r < n.length; r++) { if (r >= e.length) return n[r]; if (n[r] !== e[r]) return } }, Qe = e => e.split("/").map(e => e.trim()).filter(e => "" !== e), Je = e => { e && (e.ref.destroy(), e.unlistenEvents()) }; class et { constructor(e, t, n, r, s, i) { this.containerEl = t, this.router = n, this.navCtrl = r, this.zone = s, this.location = i, this.views = [], this.skipTransition = !1, this.nextId = 0, this.tabsPrefix = void 0 !== e ? Qe(e) : void 0 } createView(e, t) { const n = Xe(this.router, t), r = e && e.location && e.location.nativeElement, s = He(this.zone, e.instance, r); return { id: this.nextId++, stackId: Ze(this.tabsPrefix, n), unlistenEvents: s, element: r, ref: e, url: n } } getExistingView(e) { const t = Xe(this.router, e), n = this.views.find(e => e.url === t); return n && n.ref.changeDetectorRef.reattach(), n } setActive(e) { const t = this.navCtrl.consumeTransition(); let { direction: n, animation: r, animationBuilder: s } = t; const i = this.activeView, o = ((e, t) => !t || e.stackId !== t.stackId)(e, i); o && (n = "back", r = void 0); const a = this.views.slice(); let c; const l = this.router; l.getCurrentNavigation ? c = l.getCurrentNavigation() : l.navigations && l.navigations.value && (c = l.navigations.value), c && c.extras && c.extras.replaceUrl && this.views.length > 0 && this.views.splice(-1, 1); const u = this.views.includes(e), h = this.insertView(e, n); u || e.ref.changeDetectorRef.detectChanges(); const d = e.animationBuilder; return void 0 !== s || "back" !== n || o || void 0 === d || (s = d), i && (i.animationBuilder = s), this.zone.runOutsideAngular(() => this.wait(() => (i && i.ref.changeDetectorRef.detach(), e.ref.changeDetectorRef.reattach(), this.transition(e, i, r, this.canGoBack(1), !1, s).then(() => tt(e, h, a, this.location)).then(() => ({ enteringView: e, direction: n, animation: r, tabSwitch: o }))))) } canGoBack(e, t = this.getActiveStackId()) { return this.getStack(t).length > e } pop(e, t = this.getActiveStackId()) { return this.zone.run(() => { const n = this.getStack(t); if (n.length <= e) return Promise.resolve(!1); const r = n[n.length - e - 1]; let s = r.url; const i = r.savedData; if (i) { const e = i.get("primary"); e && e.route && e.route._routerState && e.route._routerState.snapshot && e.route._routerState.snapshot.url && (s = e.route._routerState.snapshot.url) } const { animationBuilder: o } = this.navCtrl.consumeTransition(); return this.navCtrl.navigateBack(s, Object.assign({}, r.savedExtras, { animation: o })).then(() => !0) }) } startBackTransition() { const e = this.activeView; if (e) { const t = this.getStack(e.stackId), n = t[t.length - 2], r = n.animationBuilder; return this.wait(() => this.transition(n, e, "back", this.canGoBack(2), !0, r)) } return Promise.resolve() } endBackTransition(e) { e ? (this.skipTransition = !0, this.pop(1)) : this.activeView && nt(this.activeView, this.views, this.views, this.location) } getLastUrl(e) { const t = this.getStack(e); return t.length > 0 ? t[t.length - 1] : void 0 } getRootUrl(e) { const t = this.getStack(e); return t.length > 0 ? t[0] : void 0 } getActiveStackId() { return this.activeView ? this.activeView.stackId : void 0 } hasRunningTask() { return void 0 !== this.runningTask } destroy() { this.containerEl = void 0, this.views.forEach(Je), this.activeView = void 0, this.views = [] } getStack(e) { return this.views.filter(t => t.stackId === e) } insertView(e, t) { return this.activeView = e, this.views = ((e, t, n) => "root" === n ? Ke(e, t) : "forward" === n ? ((e, t) => (e.indexOf(t) >= 0 ? e = e.filter(e => e.stackId !== t.stackId || e.id <= t.id) : e.push(t), e))(e, t) : ((e, t) => e.indexOf(t) >= 0 ? e.filter(e => e.stackId !== t.stackId || e.id <= t.id) : Ke(e, t))(e, t))(this.views, e, t), this.views.slice() } transition(e, t, n, r, s, i) { if (this.skipTransition) return this.skipTransition = !1, Promise.resolve(!1); if (t === e) return Promise.resolve(!1); const o = e ? e.element : void 0, a = t ? t.element : void 0, c = this.containerEl; return o && o !== a && (o.classList.add("ion-page"), o.classList.add("ion-page-invisible"), o.parentElement !== c && c.appendChild(o), c.commit) ? c.commit(o, a, { deepWait: !0, duration: void 0 === n ? 0 : void 0, direction: n, showGoBack: r, progressAnimation: s, animationBuilder: i }) : Promise.resolve(!1) } wait(e) { return i(this, void 0, void 0, function* () { void 0 !== this.runningTask && (yield this.runningTask, this.runningTask = void 0); const t = this.runningTask = e(); return t.finally(() => this.runningTask = void 0), t }) } } const tt = (e, t, n, r) => "function" == typeof requestAnimationFrame ? new Promise(s => { requestAnimationFrame(() => { nt(e, t, n, r), s() }) }) : Promise.resolve(), nt = (e, t, n, r) => { n.filter(e => !t.includes(e)).forEach(Je), t.forEach(t => { const n = r.path().split("?")[0].split("#")[0]; if (t !== e && t.url !== n) { const e = t.element; e.setAttribute("aria-hidden", "true"), e.classList.add("ion-page-hidden"), t.ref.changeDetectorRef.detach() } }) }; let rt = (() => { let e = class { constructor(e, t, n, r, s, i, a, c, u, h, d, f, p) { this.parentContexts = e, this.location = t, this.resolver = n, this.config = i, this.navCtrl = a, this.parentOutlet = p, this.activated = null, this.activatedView = null, this._activatedRoute = null, this.proxyMap = new WeakMap, this.currentActivatedRoute$ = new _.X(null), this.stackEvents = new o.vpe, this.activateEvents = new o.vpe, this.deactivateEvents = new o.vpe, this.nativeEl = u.nativeElement, this.name = r || l.eC, this.tabsPrefix = "true" === s ? Xe(h, f) : void 0, this.stackCtrl = new et(this.tabsPrefix, this.nativeEl, h, a, d, c), e.onChildOutletCreated(this.name, this) } set animation(e) { this.nativeEl.animation = e } set animated(e) { this.nativeEl.animated = e } set swipeGesture(e) { this._swipeGesture = e, this.nativeEl.swipeHandler = e ? { canStart: () => this.stackCtrl.canGoBack(1) && !this.stackCtrl.hasRunningTask(), onStart: () => this.stackCtrl.startBackTransition(), onEnd: e => this.stackCtrl.endBackTransition(e) } : void 0 } ngOnDestroy() { this.stackCtrl.destroy() } getContext() { return this.parentContexts.getContext(this.name) } ngOnInit() { if (!this.activated) { const e = this.getContext(); e && e.route && this.activateWith(e.route, e.resolver || null) } new Promise(e => (0, p.c)(this.nativeEl, e)).then(() => { void 0 === this._swipeGesture && (this.swipeGesture = this.config.getBoolean("swipeBackEnabled", "ios" === this.nativeEl.mode)) }) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { throw new Error("incompatible reuse strategy") } attach(e, t) { throw new Error("incompatible reuse strategy") } deactivate() { if (this.activated) { if (this.activatedView) { const e = this.getContext(); this.activatedView.savedData = new Map(e.children.contexts); const t = this.activatedView.savedData.get("primary"); if (t && e.route && (t.route = Object.assign({}, e.route)), this.activatedView.savedExtras = {}, e.route) { const t = e.route.snapshot; this.activatedView.savedExtras.queryParams = t.queryParams, this.activatedView.savedExtras.fragment = t.fragment } } const e = this.component; this.activatedView = null, this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(e) } } activateWith(e, t) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); let n; this._activatedRoute = e; let r = this.stackCtrl.getExistingView(e); if (r) { n = this.activated = r.ref; const t = r.savedData; t && (this.getContext().children.contexts = t), this.updateActivatedRouteProxy(n.instance, e) } else { const s = (t = t || this.resolver).resolveComponentFactory(e._futureSnapshot.routeConfig.component), i = this.parentContexts.getOrCreateContext(this.name).children, o = new _.X(null), a = this.createActivatedRouteProxy(o, e), c = new st(a, i, this.location.injector); n = this.activated = this.location.createComponent(s, this.location.length, c), o.next(n.instance), r = this.stackCtrl.createView(this.activated, e), this.proxyMap.set(n.instance, a), this.currentActivatedRoute$.next({ component: n.instance, activatedRoute: e }) } this.activatedView = r, this.stackCtrl.setActive(r).then(e => { this.navCtrl.setTopOutlet(this), this.activateEvents.emit(n.instance), this.stackEvents.emit(e) }) } canGoBack(e = 1, t) { return this.stackCtrl.canGoBack(e, t) } pop(e = 1, t) { return this.stackCtrl.pop(e, t) } getLastUrl(e) { const t = this.stackCtrl.getLastUrl(e); return t ? t.url : void 0 } getLastRouteView(e) { return this.stackCtrl.getLastUrl(e) } getRootView(e) { return this.stackCtrl.getRootUrl(e) } getActiveStackId() { return this.stackCtrl.getActiveStackId() } createActivatedRouteProxy(e, t) { const n = new l.gz; return n._futureSnapshot = t._futureSnapshot, n._routerState = t._routerState, n.snapshot = t.snapshot, n.outlet = t.outlet, n.component = t.component, n._paramMap = this.proxyObservable(e, "paramMap"), n._queryParamMap = this.proxyObservable(e, "queryParamMap"), n.url = this.proxyObservable(e, "url"), n.params = this.proxyObservable(e, "params"), n.queryParams = this.proxyObservable(e, "queryParams"), n.fragment = this.proxyObservable(e, "fragment"), n.data = this.proxyObservable(e, "data"), n } proxyObservable(e, t) { return e.pipe((0, E.h)(e => !!e), (0, C.w)(e => this.currentActivatedRoute$.pipe((0, E.h)(t => null !== t && t.component === e), (0, C.w)(e => e && e.activatedRoute[t]), (0, S.x)()))) } updateActivatedRouteProxy(e, t) { const n = this.proxyMap.get(e); if (!n) throw new Error("Could not find activated route proxy for view"); n._futureSnapshot = t._futureSnapshot, n._routerState = t._routerState, n.snapshot = t.snapshot, n.outlet = t.outlet, n.component = t.component, this.currentActivatedRoute$.next({ component: e, activatedRoute: t }) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(l.y6), o.Y36(o.s_b), o.Y36(o._Vd), o.$8M("name"), o.$8M("tabs"), o.Y36(Me), o.Y36(K), o.Y36(c.Ye), o.Y36(o.SBq), o.Y36(l.F0), o.Y36(o.R0b), o.Y36(l.gz), o.Y36(e, 12)) }, e.\u0275dir = o.lG2({ type: e, selectors: [["ion-router-outlet"]], inputs: { animated: "animated", animation: "animation", swipeGesture: "swipeGesture" }, outputs: { stackEvents: "stackEvents", activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), r([(0, o.r_U)()], e.prototype, "stackEvents", void 0), r([(0, o.r_U)("activate")], e.prototype, "activateEvents", void 0), r([(0, o.r_U)("deactivate")], e.prototype, "deactivateEvents", void 0), e = r([s(3, (0, o.ahi)("name")), s(4, (0, o.FiY)()), s(4, (0, o.ahi)("tabs")), s(12, (0, o.tp0)()), s(12, (0, o.FiY)())], e), e })(); class st { constructor(e, t, n) { this.route = e, this.childContexts = t, this.parent = n } get(e, t) { return e === l.gz ? this.route : e === l.y6 ? this.childContexts : this.parent.get(e, t) } } let it = (() => { let e = class { constructor(e) { this.navCtrl = e, this.ionTabsWillChange = new o.vpe, this.ionTabsDidChange = new o.vpe } onPageSelected(e) { const t = e.enteringView.stackId; e.tabSwitch && void 0 !== t && (this.tabBar && (this.tabBar.selectedTab = t), this.ionTabsWillChange.emit({ tab: t }), this.ionTabsDidChange.emit({ tab: t })) } select(e) { const t = "string" == typeof e, n = t ? e : e.detail.tab, r = this.outlet.getActiveStackId() === n, s = `${this.outlet.tabsPrefix}/${n}`; if (t || e.stopPropagation(), r) { const e = this.outlet.getActiveStackId(); if (this.outlet.getLastRouteView(e).url === s) return; const t = this.outlet.getRootView(n); return this.navCtrl.navigateRoot(s, Object.assign({}, t && s === t.url && t.savedExtras, { animated: !0, animationDirection: "back" })) } { const e = this.outlet.getLastRouteView(n); return this.navCtrl.navigateRoot(e && e.url || s, Object.assign({}, e && e.savedExtras, { animated: !0, animationDirection: "back" })) } } getSelected() { return this.outlet.getActiveStackId() } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(K)) }, e.\u0275cmp = o.Xpm({ type: e, selectors: [["ion-tabs"]], contentQueries: function (e, t, n) { if (1 & e && o.Suo(n, Oe, 5), 2 & e) { let e; o.iGM(e = o.CRH()) && (t.tabBar = e.first) } }, viewQuery: function (e, t) { if (1 & e && o.Gf(k, 5, rt), 2 & e) { let e; o.iGM(e = o.CRH()) && (t.outlet = e.first) } }, hostBindings: function (e, t) { 1 & e && o.NdJ("ionTabButtonClick", function (e) { return t.select(e) }) }, outputs: { ionTabsWillChange: "ionTabsWillChange", ionTabsDidChange: "ionTabsDidChange" }, ngContentSelectors: x, decls: 5, vars: 0, consts: [[1, "tabs-inner"], ["tabs", "true", 3, "stackEvents"], ["outlet", ""]], template: function (e, t) { 1 & e && (o.F$t(A), o.Hsn(0), o.TgZ(1, "div", 0), o.TgZ(2, "ion-router-outlet", 1, 2), o.NdJ("stackEvents", function (e) { return t.onPageSelected(e) }), o.qZA(), o.qZA(), o.Hsn(4, 1)) }, directives: [rt], styles: ["[_nghost-%COMP%] {\n      display: flex;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n\n      flex-direction: column;\n\n      width: 100%;\n      height: 100%;\n\n      contain: layout size style;\n      z-index: $z-index-page-container;\n    }\n    .tabs-inner[_ngcontent-%COMP%] {\n      position: relative;\n\n      flex: 1;\n\n      contain: layout size style;\n    }"] }), r([(0, o.i9L)("outlet", { read: rt, static: !1 })], e.prototype, "outlet", void 0), r([(0, o.aQ5)(Oe, { static: !1 })], e.prototype, "tabBar", void 0), r([(0, o.r_U)()], e.prototype, "ionTabsWillChange", void 0), r([(0, o.r_U)()], e.prototype, "ionTabsDidChange", void 0), r([(0, o.L6J)("ionTabButtonClick", ["$event"])], e.prototype, "select", null), e })(), ot = (() => { let e = class { constructor(e, t, n) { this.routerOutlet = e, this.navCtrl = t, this.config = n } onClick(e) { const t = this.defaultHref || this.config.get("backButtonDefaultHref"); this.routerOutlet && this.routerOutlet.canGoBack() ? (this.navCtrl.setDirection("back", void 0, void 0, this.routerAnimation), this.routerOutlet.pop(), e.preventDefault()) : null != t && (this.navCtrl.navigateBack(t, { animation: this.routerAnimation }), e.preventDefault()) } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(rt, 8), o.Y36(K), o.Y36(Me)) }, e.\u0275dir = o.lG2({ type: e, selectors: [["ion-back-button"]], hostBindings: function (e, t) { 1 & e && o.NdJ("click", function (e) { return t.onClick(e) }) }, inputs: { defaultHref: "defaultHref", routerAnimation: "routerAnimation" } }), r([(0, o.L6J)("click", ["$event"])], e.prototype, "onClick", null), e = r([s(0, (0, o.FiY)())], e), e })(), at = (() => { let e = class { constructor(e, t, n, r, s) { this.locationStrategy = e, this.navCtrl = t, this.elementRef = n, this.router = r, this.routerLink = s, this.routerDirection = "forward" } ngOnInit() { this.updateTargetUrlAndHref() } ngOnChanges() { this.updateTargetUrlAndHref() } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } updateTargetUrlAndHref() { if (this.routerLink) { const e = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree)); this.elementRef.nativeElement.href = e } } onClick(e) { this.navCtrl.setDirection(this.routerDirection, void 0, void 0, this.routerAnimation), e.preventDefault() } }; return e.\u0275fac = function (t) { return new (t || e)(o.Y36(c.S$), o.Y36(K), o.Y36(o.SBq), o.Y36(l.F0), o.Y36(l.rH, 8)) }, e.\u0275dir = o.lG2({ type: e, selectors: [["", "routerLink", ""]], hostBindings: function (e, t) { 1 & e && o.NdJ("click", function (e) { return t.onClick(e) }) }, inputs: { routerDirection: "routerDirection", routerAnimation: "routerAnimation" }, features: [o.TTD] }), r([(0, o.L6J)("click", ["$event"])], e.prototype, "onClick", null), e = r([s(4, (0, o.FiY)())], e), e })(); class ct { constructor(e) { this.ctrl = e } create(e) { return this.ctrl.create(e || {}) } dismiss(e, t, n) { return this.ctrl.dismiss(e, t, n) } getTop() { return this.ctrl.getTop() } } let lt = class extends ct { constructor() { super(y.b) } }; lt.\u0275fac = function (e) { return new (e || lt) }, lt.\u0275prov = o.Yz7({ token: lt, factory: function (e) { return lt.\u0275fac(e) }, providedIn: "root" }), lt.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new lt }, token: lt, providedIn: "root" }); let ut = class extends ct { constructor() { super(y.a) } }; ut.\u0275fac = function (e) { return new (e || ut) }, ut.\u0275prov = o.Yz7({ token: ut, factory: function (e) { return ut.\u0275fac(e) }, providedIn: "root" }), ut.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new ut }, token: ut, providedIn: "root" }); let ht = class extends ct { constructor() { super(y.l) } }; ht.\u0275fac = function (e) { return new (e || ht) }, ht.\u0275prov = o.Yz7({ token: ht, factory: function (e) { return ht.\u0275fac(e) }, providedIn: "root" }), ht.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new ht }, token: ht, providedIn: "root" }); let dt = class { open(e) { return g.m.open(e) } close(e) { return g.m.close(e) } toggle(e) { return g.m.toggle(e) } enable(e, t) { return g.m.enable(e, t) } swipeGesture(e, t) { return g.m.swipeGesture(e, t) } isOpen(e) { return g.m.isOpen(e) } isEnabled(e) { return g.m.isEnabled(e) } get(e) { return g.m.get(e) } getOpen() { return g.m.getOpen() } getMenus() { return g.m.getMenus() } }; dt.\u0275fac = function (e) { return new (e || dt) }, dt.\u0275prov = o.Yz7({ token: dt, factory: function (e) { return dt.\u0275fac(e) }, providedIn: "root" }), dt.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new dt }, token: dt, providedIn: "root" }); let ft = class extends ct { constructor() { super(y.p) } }; ft.\u0275fac = function (e) { return new (e || ft) }, ft.\u0275prov = o.Yz7({ token: ft, factory: function (e) { return ft.\u0275fac(e) }, providedIn: "root" }), ft.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new ft }, token: ft, providedIn: "root" }); let pt = (() => { let e = class extends ct { constructor(e, t, n) { super(y.m), this.angularDelegate = e, this.resolver = t, this.injector = n } create(e) { return super.create(Object.assign({}, e, { delegate: this.angularDelegate.create(this.resolver, this.injector) })) } }; return e.\u0275fac = function (t) { return new (t || e)(o.LFG(Ue), o.LFG(o._Vd), o.LFG(o.zs3)) }, e.\u0275prov = o.Yz7({ token: e, factory: function (t) { return e.\u0275fac(t) } }), e })(), mt = (() => { let e = class extends ct { constructor(e, t, n) { super(y.c), this.angularDelegate = e, this.resolver = t, this.injector = n } create(e) { return super.create(Object.assign({}, e, { delegate: this.angularDelegate.create(this.resolver, this.injector) })) } }; return e.\u0275fac = function (t) { return new (t || e)(o.LFG(Ue), o.LFG(o._Vd), o.LFG(o.zs3)) }, e.\u0275prov = o.Yz7({ token: e, factory: function (t) { return e.\u0275fac(t) } }), e })(), gt = class extends ct { constructor() { super(y.t) } }; gt.\u0275fac = function (e) { return new (e || gt) }, gt.\u0275prov = o.Yz7({ token: gt, factory: function (e) { return gt.\u0275fac(e) }, providedIn: "root" }), gt.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new gt }, token: gt, providedIn: "root" }); let yt = class { read(e) { vt().read(e) } write(e) { vt().write(e) } }; yt.\u0275fac = function (e) { return new (e || yt) }, yt.\u0275prov = o.Yz7({ token: yt, factory: function (e) { return yt.\u0275fac(e) }, providedIn: "root" }), yt.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new yt }, token: yt, providedIn: "root" }); const vt = () => { const e = "undefined" != typeof window ? window : null; if (null != e) { const t = e.Ionic; return t && t.queue ? t.queue : { read: t => e.requestAnimationFrame(t), write: t => e.requestAnimationFrame(t) } } return { read: e => e(), write: e => e() } }; let wt = class { create(e) { return (0, u.c)(e) } easingTime(e, t, n, r, s) { return (0, h.g)(e, t, n, r, s) } }; wt.\u0275fac = function (e) { return new (e || wt) }, wt.\u0275prov = o.Yz7({ token: wt, factory: function (e) { return wt.\u0275fac(e) }, providedIn: "root" }), wt.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new wt }, token: wt, providedIn: "root" }); let bt = class { constructor(e) { this.zone = e } create(e, t = !1) { return t && Object.getOwnPropertyNames(e).forEach(t => { if ("function" == typeof e[t]) { const n = e[t]; e[t] = (...e) => this.zone.run(() => n(...e)) } }), (0, d.createGesture)(e) } }; bt.\u0275fac = function (e) { return new (e || bt)(o.LFG(o.R0b)) }, bt.\u0275prov = o.Yz7({ token: bt, factory: function (e) { return bt.\u0275fac(e) }, providedIn: "root" }), bt.ngInjectableDef = (0, o.Yz7)({ factory: function () { return new bt((0, o.LFG)(o.R0b)) }, token: bt, providedIn: "root" }); class _t { shouldDetach(e) { return !1 } shouldAttach(e) { return !1 } store(e, t) { } retrieve(e) { return null } shouldReuseRoute(e, t) { if (e.routeConfig !== t.routeConfig) return !1; const n = e.params, r = t.params, s = Object.keys(n), i = Object.keys(r); if (s.length !== i.length) return !1; for (const o of s) if (r[o] !== n[o]) return !1; return !0 } } const Et = (e, t, r) => () => { if (t.defaultView && "undefined" != typeof window) { (e => { const t = window, n = t.Ionic; n && n.config && "Object" !== n.config.constructor.name || (t.Ionic = t.Ionic || {}, t.Ionic.config = Object.assign(Object.assign({}, t.Ionic.config), e)) })(Object.assign({}, e, { _zoneGate: e => r.run(e) })); const s = "__zone_symbol__addEventListener" in t.body ? "__zone_symbol__addEventListener" : "addEventListener"; return function () { var e = []; if ("undefined" != typeof window) { var t = window; t.customElements && (!t.Element || t.Element.prototype.closest && t.Element.prototype.matches && t.Element.prototype.remove && t.Element.prototype.getRootNode) || e.push(n.e(6748).then(n.t.bind(n, 5141, 23))), "function" == typeof Object.assign && Object.entries && Array.prototype.find && Array.prototype.includes && String.prototype.startsWith && String.prototype.endsWith && (!t.NodeList || t.NodeList.prototype.forEach) && t.fetch && function () { try { var e = new URL("b", "http://a"); return e.pathname = "c%20d", "http://a/c%20d" === e.href && e.searchParams } catch (t) { return !1 } }() && "undefined" != typeof WeakMap || e.push(n.e(2214).then(n.t.bind(n, 7656, 23))) } return Promise.all(e) }().then(() => { return e = { exclude: ["ion-tabs", "ion-tab"], syncQueue: !0, raf: D, jmp: e => r.runOutsideAngular(e), ael(e, t, n, r) { e[s](t, n, r) }, rel(e, t, n, r) { e.removeEventListener(t, n, r) } }, "undefined" == typeof window ? Promise.resolve() : (v.C && v.C.supports && v.C.supports("color", "var(--c)") ? (0, v.a)() : n.e(1843).then(n.t.bind(n, 5902, 23)).then(() => (v.p.$cssShim$ = v.w.__cssshim) ? v.p.$cssShim$.i() : 0)).then(() => (T(), (0, v.b)(JSON.parse('[["ion-select_3",[[2,"ion-select-popover",{"header":[1],"subHeader":[1,"sub-header"],"message":[1],"options":[16]},[[0,"ionChange","onSelect"]]],[33,"ion-select",{"disabled":[4],"cancelText":[1,"cancel-text"],"okText":[1,"ok-text"],"placeholder":[1],"name":[1],"selectedText":[1,"selected-text"],"multiple":[4],"interface":[1],"interfaceOptions":[8,"interface-options"],"compareWith":[1,"compare-with"],"value":[1032],"isExpanded":[32],"open":[64]}],[1,"ion-select-option",{"disabled":[4],"value":[8]}]]],["ion-menu_3",[[33,"ion-menu-button",{"color":[513],"disabled":[4],"menu":[1],"autoHide":[4,"auto-hide"],"type":[1],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]],[33,"ion-menu",{"contentId":[513,"content-id"],"menuId":[513,"menu-id"],"type":[1025],"disabled":[1028],"side":[513],"swipeGesture":[4,"swipe-gesture"],"maxEdgeStart":[2,"max-edge-start"],"isPaneVisible":[32],"isEndSide":[32],"isOpen":[64],"isActive":[64],"open":[64],"close":[64],"toggle":[64],"setOpen":[64]},[[16,"ionSplitPaneVisible","onSplitPaneChanged"],[2,"click","onBackdropClick"],[0,"keydown","onKeydown"]]],[1,"ion-menu-toggle",{"menu":[1],"autoHide":[4,"auto-hide"],"visible":[32]},[[16,"ionMenuChange","visibilityChanged"],[16,"ionSplitPaneVisible","visibilityChanged"]]]]],["ion-action-sheet",[[34,"ion-action-sheet",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"header":[1],"subHeader":[1,"sub-header"],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-fab_3",[[33,"ion-fab-button",{"color":[513],"activated":[4],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1],"show":[4],"translucent":[4],"type":[1],"size":[1],"closeIcon":[1,"close-icon"]}],[1,"ion-fab",{"horizontal":[1],"vertical":[1],"edge":[4],"activated":[1028],"close":[64]}],[1,"ion-fab-list",{"activated":[4],"side":[1]}]]],["ion-refresher_2",[[0,"ion-refresher-content",{"pullingIcon":[1025,"pulling-icon"],"pullingText":[1,"pulling-text"],"refreshingSpinner":[1025,"refreshing-spinner"],"refreshingText":[1,"refreshing-text"]}],[32,"ion-refresher",{"pullMin":[2,"pull-min"],"pullMax":[2,"pull-max"],"closeDuration":[1,"close-duration"],"snapbackDuration":[1,"snapback-duration"],"pullFactor":[2,"pull-factor"],"disabled":[4],"nativeRefresher":[32],"state":[32],"complete":[64],"cancel":[64],"getProgress":[64]}]]],["ion-alert",[[34,"ion-alert",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"header":[1],"subHeader":[1,"sub-header"],"message":[1],"buttons":[16],"inputs":[1040],"backdropDismiss":[4,"backdrop-dismiss"],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]},[[4,"keydown","onKeydown"]]]]],["ion-back-button",[[33,"ion-back-button",{"color":[513],"defaultHref":[1025,"default-href"],"disabled":[516],"icon":[1],"text":[1],"type":[1],"routerAnimation":[16]}]]],["ion-loading",[[34,"ion-loading",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"message":[1],"cssClass":[1,"css-class"],"duration":[2],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"spinner":[1025],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-toast",[[33,"ion-toast",{"overlayIndex":[2,"overlay-index"],"color":[513],"enterAnimation":[16],"leaveAnimation":[16],"cssClass":[1,"css-class"],"duration":[2],"header":[1],"message":[1],"keyboardClose":[4,"keyboard-close"],"position":[1],"buttons":[16],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-card_5",[[33,"ion-card",{"color":[513],"button":[4],"type":[1],"disabled":[4],"download":[1],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}],[32,"ion-card-content"],[33,"ion-card-header",{"color":[513],"translucent":[4]}],[33,"ion-card-subtitle",{"color":[513]}],[33,"ion-card-title",{"color":[513]}]]],["ion-item-option_3",[[33,"ion-item-option",{"color":[513],"disabled":[4],"download":[1],"expandable":[4],"href":[1],"rel":[1],"target":[1],"type":[1]}],[32,"ion-item-options",{"side":[1],"fireSwipeEvent":[64]}],[0,"ion-item-sliding",{"disabled":[4],"state":[32],"getOpenAmount":[64],"getSlidingRatio":[64],"open":[64],"close":[64],"closeOpened":[64]}]]],["ion-infinite-scroll_2",[[32,"ion-infinite-scroll-content",{"loadingSpinner":[1025,"loading-spinner"],"loadingText":[1,"loading-text"]}],[0,"ion-infinite-scroll",{"threshold":[1],"disabled":[4],"position":[1],"isLoading":[32],"complete":[64]}]]],["ion-reorder_2",[[33,"ion-reorder",null,[[2,"click","onClick"]]],[0,"ion-reorder-group",{"disabled":[4],"state":[32],"complete":[64]}]]],["ion-segment_2",[[33,"ion-segment-button",{"disabled":[4],"layout":[1],"type":[1],"value":[1],"checked":[32]}],[33,"ion-segment",{"color":[513],"disabled":[4],"scrollable":[4],"swipeGesture":[4,"swipe-gesture"],"value":[1025],"activated":[32]}]]],["ion-tab-bar_2",[[33,"ion-tab-button",{"disabled":[4],"download":[1],"href":[1],"rel":[1],"layout":[1025],"selected":[1028],"tab":[1],"target":[1]},[[8,"ionTabBarChanged","onTabBarChanged"]]],[33,"ion-tab-bar",{"color":[513],"selectedTab":[1,"selected-tab"],"translucent":[4],"keyboardVisible":[32]}]]],["ion-chip",[[33,"ion-chip",{"color":[513],"outline":[4],"disabled":[4]}]]],["ion-modal",[[34,"ion-modal",{"overlayIndex":[2,"overlay-index"],"delegate":[16],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"showBackdrop":[4,"show-backdrop"],"animated":[4],"swipeToClose":[4,"swipe-to-close"],"presentingElement":[16],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-popover",[[34,"ion-popover",{"delegate":[16],"overlayIndex":[2,"overlay-index"],"enterAnimation":[16],"leaveAnimation":[16],"component":[1],"componentProps":[16],"keyboardClose":[4,"keyboard-close"],"cssClass":[1,"css-class"],"backdropDismiss":[4,"backdrop-dismiss"],"event":[8],"showBackdrop":[4,"show-backdrop"],"translucent":[4],"animated":[4],"htmlAttributes":[16],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64]}]]],["ion-searchbar",[[34,"ion-searchbar",{"color":[513],"animated":[4],"autocomplete":[1],"autocorrect":[1],"cancelButtonIcon":[1,"cancel-button-icon"],"cancelButtonText":[1,"cancel-button-text"],"clearIcon":[1,"clear-icon"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"placeholder":[1],"searchIcon":[1,"search-icon"],"showCancelButton":[1,"show-cancel-button"],"showClearButton":[1,"show-clear-button"],"spellcheck":[4],"type":[1],"value":[1025],"focused":[32],"noAnimate":[32],"setFocus":[64],"getInputElement":[64]}]]],["ion-app_8",[[0,"ion-app"],[34,"ion-buttons",{"collapse":[4]}],[1,"ion-content",{"color":[513],"fullscreen":[4],"forceOverscroll":[1028,"force-overscroll"],"scrollX":[4,"scroll-x"],"scrollY":[4,"scroll-y"],"scrollEvents":[4,"scroll-events"],"getScrollElement":[64],"scrollToTop":[64],"scrollToBottom":[64],"scrollByPoint":[64],"scrollToPoint":[64]},[[8,"appload","onAppLoad"],[2,"click","onClick"]]],[36,"ion-footer",{"translucent":[4]}],[36,"ion-header",{"collapse":[1],"translucent":[4]}],[1,"ion-router-outlet",{"mode":[1025],"delegate":[16],"animated":[4],"animation":[16],"swipeHandler":[16],"commit":[64],"setRouteId":[64],"getRouteId":[64]}],[33,"ion-title",{"color":[513],"size":[1]}],[33,"ion-toolbar",{"color":[513]},[[0,"ionStyle","childrenStyle"]]]]],["ion-route_4",[[0,"ion-route",{"url":[1],"component":[1],"componentProps":[16],"beforeLeave":[16],"beforeEnter":[16]}],[0,"ion-route-redirect",{"from":[1],"to":[1]}],[0,"ion-router",{"root":[1],"useHash":[4,"use-hash"],"canTransition":[64],"push":[64],"back":[64],"printDebug":[64],"navChanged":[64]},[[8,"popstate","onPopState"],[4,"ionBackButton","onBackButton"]]],[1,"ion-router-link",{"color":[513],"href":[1],"rel":[1],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"target":[1]}]]],["ion-avatar_3",[[33,"ion-avatar"],[33,"ion-badge",{"color":[513]}],[1,"ion-thumbnail"]]],["ion-col_3",[[1,"ion-col",{"offset":[1],"offsetXs":[1,"offset-xs"],"offsetSm":[1,"offset-sm"],"offsetMd":[1,"offset-md"],"offsetLg":[1,"offset-lg"],"offsetXl":[1,"offset-xl"],"pull":[1],"pullXs":[1,"pull-xs"],"pullSm":[1,"pull-sm"],"pullMd":[1,"pull-md"],"pullLg":[1,"pull-lg"],"pullXl":[1,"pull-xl"],"push":[1],"pushXs":[1,"push-xs"],"pushSm":[1,"push-sm"],"pushMd":[1,"push-md"],"pushLg":[1,"push-lg"],"pushXl":[1,"push-xl"],"size":[1],"sizeXs":[1,"size-xs"],"sizeSm":[1,"size-sm"],"sizeMd":[1,"size-md"],"sizeLg":[1,"size-lg"],"sizeXl":[1,"size-xl"]},[[9,"resize","onResize"]]],[1,"ion-grid",{"fixed":[4]}],[1,"ion-row"]]],["ion-nav_2",[[1,"ion-nav",{"delegate":[16],"swipeGesture":[1028,"swipe-gesture"],"animated":[4],"animation":[16],"rootParams":[16],"root":[1],"push":[64],"insert":[64],"insertPages":[64],"pop":[64],"popTo":[64],"popToRoot":[64],"removeIndex":[64],"setRoot":[64],"setPages":[64],"setRouteId":[64],"getRouteId":[64],"getActive":[64],"getByIndex":[64],"canGoBack":[64],"getPrevious":[64]}],[0,"ion-nav-link",{"component":[1],"componentProps":[16],"routerDirection":[1,"router-direction"],"routerAnimation":[16]}]]],["ion-slide_2",[[0,"ion-slide"],[36,"ion-slides",{"options":[8],"pager":[4],"scrollbar":[4],"update":[64],"updateAutoHeight":[64],"slideTo":[64],"slideNext":[64],"slidePrev":[64],"getActiveIndex":[64],"getPreviousIndex":[64],"length":[64],"isEnd":[64],"isBeginning":[64],"startAutoplay":[64],"stopAutoplay":[64],"lockSwipeToNext":[64],"lockSwipeToPrev":[64],"lockSwipes":[64],"getSwiper":[64]}]]],["ion-tab_2",[[1,"ion-tab",{"active":[1028],"delegate":[16],"tab":[1],"component":[1],"setActive":[64]}],[1,"ion-tabs",{"useRouter":[1028,"use-router"],"selectedTab":[32],"select":[64],"getTab":[64],"getSelected":[64],"setRouteId":[64],"getRouteId":[64]}]]],["ion-checkbox",[[33,"ion-checkbox",{"color":[513],"name":[1],"checked":[1028],"indeterminate":[1028],"disabled":[4],"value":[1]}]]],["ion-img",[[1,"ion-img",{"alt":[1],"src":[1],"loadSrc":[32],"loadError":[32]}]]],["ion-input",[[34,"ion-input",{"fireFocusEvents":[4,"fire-focus-events"],"color":[513],"accept":[1],"autocapitalize":[1],"autocomplete":[1],"autocorrect":[1],"autofocus":[4],"clearInput":[4,"clear-input"],"clearOnEdit":[4,"clear-on-edit"],"debounce":[2],"disabled":[4],"enterkeyhint":[1],"inputmode":[1],"max":[1],"maxlength":[2],"min":[1],"minlength":[2],"multiple":[4],"name":[1],"pattern":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"step":[1],"size":[2],"type":[1],"value":[1032],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-progress-bar",[[33,"ion-progress-bar",{"type":[1],"reversed":[4],"value":[2],"buffer":[2],"color":[513]}]]],["ion-range",[[33,"ion-range",{"color":[513],"debounce":[2],"name":[1],"dualKnobs":[4,"dual-knobs"],"min":[2],"max":[2],"pin":[4],"snaps":[4],"step":[2],"ticks":[4],"disabled":[4],"value":[1026],"ratioA":[32],"ratioB":[32],"pressedKnob":[32]}]]],["ion-split-pane",[[33,"ion-split-pane",{"contentId":[513,"content-id"],"disabled":[4],"when":[8],"visible":[32]}]]],["ion-text",[[1,"ion-text",{"color":[513]}]]],["ion-textarea",[[34,"ion-textarea",{"fireFocusEvents":[4,"fire-focus-events"],"color":[513],"autocapitalize":[1],"autofocus":[4],"clearOnEdit":[1028,"clear-on-edit"],"debounce":[2],"disabled":[4],"inputmode":[1],"enterkeyhint":[1],"maxlength":[2],"minlength":[2],"name":[1],"placeholder":[1],"readonly":[4],"required":[4],"spellcheck":[4],"cols":[2],"rows":[2],"wrap":[1],"autoGrow":[4,"auto-grow"],"value":[1025],"hasFocus":[32],"setFocus":[64],"setBlur":[64],"getInputElement":[64]}]]],["ion-toggle",[[33,"ion-toggle",{"color":[513],"name":[1],"checked":[1028],"disabled":[4],"value":[1],"activated":[32]}]]],["ion-virtual-scroll",[[0,"ion-virtual-scroll",{"approxItemHeight":[2,"approx-item-height"],"approxHeaderHeight":[2,"approx-header-height"],"approxFooterHeight":[2,"approx-footer-height"],"headerFn":[16],"footerFn":[16],"items":[16],"itemHeight":[16],"headerHeight":[16],"footerHeight":[16],"renderItem":[16],"renderHeader":[16],"renderFooter":[16],"nodeRender":[16],"domRender":[16],"totalHeight":[32],"positionForItem":[64],"checkRange":[64],"checkEnd":[64]},[[9,"resize","onResize"]]]]],["ion-datetime_3",[[34,"ion-picker",{"overlayIndex":[2,"overlay-index"],"keyboardClose":[4,"keyboard-close"],"enterAnimation":[16],"leaveAnimation":[16],"buttons":[16],"columns":[16],"cssClass":[1,"css-class"],"duration":[2],"showBackdrop":[4,"show-backdrop"],"backdropDismiss":[4,"backdrop-dismiss"],"animated":[4],"htmlAttributes":[16],"presented":[32],"present":[64],"dismiss":[64],"onDidDismiss":[64],"onWillDismiss":[64],"getColumn":[64]}],[33,"ion-datetime",{"name":[1],"disabled":[4],"readonly":[4],"min":[1025],"max":[1025],"displayFormat":[1,"display-format"],"displayTimezone":[1,"display-timezone"],"pickerFormat":[1,"picker-format"],"cancelText":[1,"cancel-text"],"doneText":[1,"done-text"],"yearValues":[8,"year-values"],"monthValues":[8,"month-values"],"dayValues":[8,"day-values"],"hourValues":[8,"hour-values"],"minuteValues":[8,"minute-values"],"monthNames":[1,"month-names"],"monthShortNames":[1,"month-short-names"],"dayNames":[1,"day-names"],"dayShortNames":[1,"day-short-names"],"pickerOptions":[16],"placeholder":[1],"value":[1025],"isExpanded":[32],"open":[64]}],[32,"ion-picker-column",{"col":[16]}]]],["ion-radio_2",[[33,"ion-radio",{"color":[513],"name":[1],"disabled":[4],"value":[8],"checked":[32],"buttonTabindex":[32],"setFocus":[64],"setButtonTabindex":[64]}],[0,"ion-radio-group",{"allowEmptySelection":[4,"allow-empty-selection"],"name":[1],"value":[1032]},[[4,"keydown","onKeydown"]]]]],["ion-spinner",[[1,"ion-spinner",{"color":[513],"duration":[2],"name":[1],"paused":[4]}]]],["ion-backdrop",[[33,"ion-backdrop",{"visible":[4],"tappable":[4],"stopPropagation":[4,"stop-propagation"]},[[2,"click","onMouseDown"]]]]],["ion-ripple-effect",[[1,"ion-ripple-effect",{"type":[1],"addRipple":[64]}]]],["ion-button_2",[[33,"ion-button",{"color":[513],"buttonType":[1025,"button-type"],"disabled":[516],"expand":[513],"fill":[1537],"routerDirection":[1,"router-direction"],"routerAnimation":[16],"download":[1],"href":[1],"rel":[1],"shape":[513],"size":[513],"strong":[4],"target":[1],"type":[1]}],[1,"ion-icon",{"mode":[1025],"color":[1],"ariaLabel":[1537,"aria-label"],"ariaHidden":[513,"aria-hidden"],"ios":[1],"md":[1],"flipRtl":[4,"flip-rtl"],"name":[513],"src":[1],"icon":[8],"size":[1],"lazy":[4],"sanitize":[4],"svgContent":[32],"isVisible":[32]}]]],["ion-item_8",[[33,"ion-item-divider",{"color":[513],"sticky":[4]}],[32,"ion-item-group"],[33,"ion-note",{"color":[513]}],[1,"ion-skeleton-text",{"animated":[4]}],[49,"ion-item",{"color":[513],"button":[4],"detail":[4],"detailIcon":[1,"detail-icon"],"disabled":[4],"download":[1],"href":[1],"rel":[1],"lines":[1],"routerAnimation":[16],"routerDirection":[1,"router-direction"],"target":[1],"type":[1],"multipleInputs":[32],"focusable":[32]},[[0,"ionColor","labelColorChanged"],[0,"ionStyle","itemStyle"]]],[34,"ion-label",{"color":[513],"position":[1],"noAnimate":[32]}],[32,"ion-list",{"lines":[1],"inset":[4],"closeSlidingItems":[64]}],[33,"ion-list-header",{"color":[513],"lines":[1]}]]]]'), e))); var e }) } }; var Ct; let St = Ct = class { static forRoot(e) { return { ngModule: Ct, providers: [{ provide: $e, useValue: e }, { provide: o.ip1, useFactory: Et, multi: !0, deps: [$e, c.K0, o.R0b] }] } } }; St.\u0275fac = function (e) { return new (e || St) }, St.\u0275mod = o.oAB({ type: St }), St.\u0275inj = o.cJS({ providers: [Ue, pt, mt], imports: [[c.ez]] }) }, 4086: (e, t, n) => { "use strict"; n.d(t, { c: () => u }); var r = n(2377); let s; const i = e => { if (void 0 === s) { const t = void 0 !== e.style.webkitAnimationName; s = void 0 === e.style.animationName && t ? "-webkit-" : "" } return s }, o = (e, t, n) => { const r = t.startsWith("animation") ? i(e) : ""; e.style.setProperty(r + t, n) }, a = (e, t) => { const n = t.startsWith("animation") ? i(e) : ""; e.style.removeProperty(n + t) }, c = [], l = (e = [], t) => { if (void 0 !== t) { const n = Array.isArray(t) ? t : [t]; return [...e, ...n] } return e }, u = e => { let t, n, s, u, h, d, f, p, m, g, y, v, w, b = [], _ = [], E = [], C = !1, S = {}, T = [], I = [], k = {}, A = 0, x = !1, D = !1, O = !0, R = !1, N = !0; const P = e, F = [], L = [], M = [], $ = [], B = [], V = [], U = [], j = [], q = [], z = [], H = "function" == typeof AnimationEffect || "function" == typeof window.AnimationEffect, G = "function" == typeof Element && "function" == typeof Element.prototype.animate && H, W = (e, t) => ((t && t.oneTimeCallback ? L : F).push({ c: e, o: t }), w), Y = () => { if (G) z.forEach(e => { e.cancel() }), z.length = 0; else { const e = M.slice(); (0, r.r)(() => { e.forEach(e => { a(e, "animation-name"), a(e, "animation-duration"), a(e, "animation-timing-function"), a(e, "animation-iteration-count"), a(e, "animation-delay"), a(e, "animation-play-state"), a(e, "animation-fill-mode"), a(e, "animation-direction") }) }) } }, K = () => { B.forEach(e => { e && e.parentNode && e.parentNode.removeChild(e) }), B.length = 0 }, X = () => void 0 !== h ? h : f ? f.getFill() : "both", Z = () => void 0 !== m ? m : void 0 !== d ? d : f ? f.getDirection() : "normal", Q = () => x ? "linear" : void 0 !== s ? s : f ? f.getEasing() : "linear", J = () => D ? 0 : void 0 !== g ? g : void 0 !== n ? n : f ? f.getDuration() : 0, ee = () => void 0 !== u ? u : f ? f.getIterations() : 1, te = () => void 0 !== y ? y : void 0 !== t ? t : f ? f.getDelay() : 0, ne = () => { 0 !== A && (A--, 0 === A && ((() => { ue(), j.forEach(e => e()), q.forEach(e => e()); const e = O ? 1 : 0, t = T, n = I, r = k; M.forEach(e => { const s = e.classList; t.forEach(e => s.add(e)), n.forEach(e => s.remove(e)); for (const t in r) r.hasOwnProperty(t) && o(e, t, r[t]) }), F.forEach(t => t.c(e, w)), L.forEach(t => t.c(e, w)), L.length = 0, N = !0, O && (R = !0), O = !0 })(), f && f.animationFinish())) }, re = (t = !0) => { (() => { V.forEach(e => e()), U.forEach(e => e()); const e = _, t = E, n = S; M.forEach(r => { const s = r.classList; e.forEach(e => s.add(e)), t.forEach(e => s.remove(e)); for (const e in n) n.hasOwnProperty(e) && o(r, e, n[e]) }) })(), b.length > 0 && (G ? (M.forEach(e => { const t = e.animate(b, { id: P, delay: te(), duration: J(), easing: Q(), iterations: ee(), fill: X(), direction: Z() }); t.pause(), z.push(t) }), z.length > 0 && (z[0].onfinish = () => { ne() })) : ((t = !0) => { K(); const n = ((s = b).forEach(e => { for (const t in e) if (e.hasOwnProperty(t)) { const n = e[t]; if ("easing" === t) e["animation-timing-function"] = n, delete e[t]; else { const r = t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(); r !== t && (e[r] = n, delete e[t]) } } }), s); var s; M.forEach(s => { if (n.length > 0) { const a = ((e = []) => e.map(e => { const t = e.offset, n = []; for (const r in e) e.hasOwnProperty(r) && "offset" !== r && n.push(`${r}: ${e[r]};`); return `${100 * t}% { ${n.join(" ")} }` }).join(" "))(n); v = void 0 !== e ? e : (e => { let t = c.indexOf(e); return t < 0 && (t = c.push(e) - 1), `ion-animation-${t}` })(a); const l = ((e, t, n) => { const r = (e => { const t = e.getRootNode(); return t.head || t })(n), s = i(n), o = r.querySelector("#" + e); if (o) return o; const a = (n.ownerDocument || document).createElement("style"); return a.id = e, a.textContent = `@${s}keyframes ${e} { ${t} } @${s}keyframes ${e}-alt { ${t} }`, r.appendChild(a), a })(v, a, s); B.push(l), o(s, "animation-duration", `${J()}ms`), o(s, "animation-timing-function", Q()), o(s, "animation-delay", `${te()}ms`), o(s, "animation-fill-mode", X()), o(s, "animation-direction", Z()); const u = ee() === 1 / 0 ? "infinite" : ee().toString(); o(s, "animation-iteration-count", u), o(s, "animation-play-state", "paused"), t && o(s, "animation-name", `${l.id}-alt`), (0, r.r)(() => { o(s, "animation-name", l.id || null) }) } }) })(t)), C = !0 }, se = e => { if (e = Math.min(Math.max(e, 0), .9999), G) z.forEach(t => { t.currentTime = t.effect.getComputedTiming().delay + J() * e, t.pause() }); else { const t = `-${J() * e}ms`; M.forEach(e => { b.length > 0 && (o(e, "animation-delay", t), o(e, "animation-play-state", "paused")) }) } }, ie = e => { z.forEach(e => { e.effect.updateTiming({ delay: te(), duration: J(), easing: Q(), iterations: ee(), fill: X(), direction: Z() }) }), void 0 !== e && se(e) }, oe = (e = !0, t) => { (0, r.r)(() => { M.forEach(n => { o(n, "animation-name", v || null), o(n, "animation-duration", `${J()}ms`), o(n, "animation-timing-function", Q()), o(n, "animation-delay", void 0 !== t ? `-${t * J()}ms` : `${te()}ms`), o(n, "animation-fill-mode", X() || null), o(n, "animation-direction", Z() || null); const s = ee() === 1 / 0 ? "infinite" : ee().toString(); o(n, "animation-iteration-count", s), e && o(n, "animation-name", `${v}-alt`), (0, r.r)(() => { o(n, "animation-name", v || null) }) }) }) }, ae = (e = !1, t = !0, n) => (e && $.forEach(r => { r.update(e, t, n) }), G ? ie(n) : oe(t, n), w), ce = () => { C && (G ? z.forEach(e => { e.pause() }) : M.forEach(e => { o(e, "animation-play-state", "paused") })) }, le = () => { p = void 0, ne() }, ue = () => { p && clearTimeout(p) }, he = e => new Promise(t => { e && e.sync && (D = !0, W(() => D = !1, { oneTimeCallback: !0 })), C || re(), R && (G ? (se(0), ie()) : oe(), R = !1), N && (A = $.length + 1, N = !1), W(() => t(), { oneTimeCallback: !0 }), $.forEach(e => { e.play() }), G ? (z.forEach(e => { e.play() }), 0 !== b.length && 0 !== M.length || ne()) : (() => { if (ue(), (0, r.r)(() => { M.forEach(e => { b.length > 0 && o(e, "animation-play-state", "running") }) }), 0 === b.length || 0 === M.length) ne(); else { const e = te() || 0, t = J() || 0, n = ee() || 1; isFinite(n) && (p = setTimeout(le, e + t * n + 100)), ((e, t) => { let n; const s = { passive: !0 }, i = t => { e === t.target && (n && n(), ue(), (0, r.r)(() => { M.forEach(e => { a(e, "animation-duration"), a(e, "animation-delay"), a(e, "animation-play-state") }), (0, r.r)(ne) })) }; e && (e.addEventListener("webkitAnimationEnd", i, s), e.addEventListener("animationend", i, s), n = () => { e.removeEventListener("webkitAnimationEnd", i, s), e.removeEventListener("animationend", i, s) }) })(M[0]) } })() }), de = (e, t) => { const n = b[0]; return void 0 === n || void 0 !== n.offset && 0 !== n.offset ? b = [{ offset: 0, [e]: t }, ...b] : n[e] = t, w }; return w = { parentAnimation: f, elements: M, childAnimations: $, id: P, animationFinish: ne, from: de, to: (e, t) => { const n = b[b.length - 1]; return void 0 === n || void 0 !== n.offset && 1 !== n.offset ? b = [...b, { offset: 1, [e]: t }] : n[e] = t, w }, fromTo: (e, t, n) => de(e, t).to(e, n), parent: e => (f = e, w), play: he, pause: () => ($.forEach(e => { e.pause() }), ce(), w), stop: () => { $.forEach(e => { e.stop() }), C && (Y(), C = !1), x = !1, D = !1, N = !0, m = void 0, g = void 0, y = void 0, A = 0, R = !1, O = !0 }, destroy: e => ($.forEach(t => { t.destroy(e) }), (e => { Y(), e && K() })(e), M.length = 0, $.length = 0, b.length = 0, F.length = 0, L.length = 0, C = !1, N = !0, w), keyframes: e => (b = e, w), addAnimation: e => { if (null != e) if (Array.isArray(e)) for (const t of e) t.parent(w), $.push(t); else e.parent(w), $.push(e); return w }, addElement: e => { if (null != e) if (1 === e.nodeType) M.push(e); else if (e.length >= 0) for (let t = 0; t < e.length; t++)M.push(e[t]); else console.error("Invalid addElement value"); return w }, update: ae, fill: e => (h = e, ae(!0), w), direction: e => (d = e, ae(!0), w), iterations: e => (u = e, ae(!0), w), duration: e => (G || 0 !== e || (e = 1), n = e, ae(!0), w), easing: e => (s = e, ae(!0), w), delay: e => (t = e, ae(!0), w), getWebAnimations: () => z, getKeyframes: () => b, getFill: X, getDirection: Z, getDelay: te, getIterations: ee, getEasing: Q, getDuration: J, afterAddRead: e => (j.push(e), w), afterAddWrite: e => (q.push(e), w), afterClearStyles: (e = []) => { for (const t of e) k[t] = ""; return w }, afterStyles: (e = {}) => (k = e, w), afterRemoveClass: e => (I = l(I, e), w), afterAddClass: e => (T = l(T, e), w), beforeAddRead: e => (V.push(e), w), beforeAddWrite: e => (U.push(e), w), beforeClearStyles: (e = []) => { for (const t of e) S[t] = ""; return w }, beforeStyles: (e = {}) => (S = e, w), beforeRemoveClass: e => (E = l(E, e), w), beforeAddClass: e => (_ = l(_, e), w), onFinish: W, progressStart: (e = !1, t) => ($.forEach(n => { n.progressStart(e, t) }), ce(), x = e, C ? ae(!1, !0, t) : re(), w), progressStep: e => ($.forEach(t => { t.progressStep(e) }), se(e), w), progressEnd: (e, t, n) => (x = !1, $.forEach(r => { r.progressEnd(e, t, n) }), void 0 !== n && (g = n), R = !1, O = !0, 0 === e ? (m = "reverse" === Z() ? "normal" : "reverse", "reverse" === m && (O = !1), G ? (ae(), se(1 - t)) : (y = (1 - t) * J() * -1, ae(!1, !1))) : 1 === e && (G ? (ae(), se(t)) : (y = t * J() * -1, ae(!1, !1))), void 0 !== e && (W(() => { g = void 0, m = void 0, y = void 0 }, { oneTimeCallback: !0 }), f || he()), w) } } }, 7807: (e, t, n) => { "use strict"; n.d(t, { g: () => r }); const r = (e, t, n, r, o) => i(e[1], t[1], n[1], r[1], o).map(i => s(e[0], t[0], n[0], r[0], i)), s = (e, t, n, r, s) => s * (3 * t * Math.pow(s - 1, 2) + s * (-3 * n * s + 3 * n + r * s)) - e * Math.pow(s - 1, 3), i = (e, t, n, r, s) => o((r -= s) - 3 * (n -= s) + 3 * (t -= s) - (e -= s), 3 * n - 6 * t + 3 * e, 3 * t - 3 * e, e).filter(e => e >= 0 && e <= 1), o = (e, t, n, r) => { if (0 === e) return ((e, t, n) => { const r = t * t - 4 * e * n; return r < 0 ? [] : [(-t + Math.sqrt(r)) / (2 * e), (-t - Math.sqrt(r)) / (2 * e)] })(t, n, r); const s = (3 * (n /= e) - (t /= e) * t) / 3, i = (2 * t * t * t - 9 * t * n + 27 * (r /= e)) / 27; if (0 === s) return [Math.pow(-i, 1 / 3)]; if (0 === i) return [Math.sqrt(-s), -Math.sqrt(-s)]; const o = Math.pow(i / 2, 2) + Math.pow(s / 3, 3); if (0 === o) return [Math.pow(i / 2, .5) - t / 3]; if (o > 0) return [Math.pow(-i / 2 + Math.sqrt(o), 1 / 3) - Math.pow(i / 2 + Math.sqrt(o), 1 / 3) - t / 3]; const a = Math.sqrt(Math.pow(-s / 3, 3)), c = Math.acos(-i / (2 * Math.sqrt(Math.pow(-s / 3, 3)))), l = 2 * Math.pow(a, 1 / 3); return [l * Math.cos(c / 3) - t / 3, l * Math.cos((c + 2 * Math.PI) / 3) - t / 3, l * Math.cos((c + 4 * Math.PI) / 3) - t / 3] } }, 960: (e, t, n) => { "use strict"; n.d(t, { G: () => o }); class r { constructor(e, t, n, r, s) { this.id = t, this.name = n, this.disableScroll = s, this.priority = 1e6 * r + t, this.ctrl = e } canStart() { return !!this.ctrl && this.ctrl.canStart(this.name) } start() { return !!this.ctrl && this.ctrl.start(this.name, this.id, this.priority) } capture() { if (!this.ctrl) return !1; const e = this.ctrl.capture(this.name, this.id, this.priority); return e && this.disableScroll && this.ctrl.disableScroll(this.id), e } release() { this.ctrl && (this.ctrl.release(this.id), this.disableScroll && this.ctrl.enableScroll(this.id)) } destroy() { this.release(), this.ctrl = void 0 } } class s { constructor(e, t, n, r) { this.id = t, this.disable = n, this.disableScroll = r, this.ctrl = e } block() { if (this.ctrl) { if (this.disable) for (const e of this.disable) this.ctrl.disableGesture(e, this.id); this.disableScroll && this.ctrl.disableScroll(this.id) } } unblock() { if (this.ctrl) { if (this.disable) for (const e of this.disable) this.ctrl.enableGesture(e, this.id); this.disableScroll && this.ctrl.enableScroll(this.id) } } destroy() { this.unblock(), this.ctrl = void 0 } } const i = "backdrop-no-scroll", o = new class { constructor() { this.gestureId = 0, this.requestedStart = new Map, this.disabledGestures = new Map, this.disabledScroll = new Set } createGesture(e) { return new r(this, this.newID(), e.name, e.priority || 0, !!e.disableScroll) } createBlocker(e = {}) { return new s(this, this.newID(), e.disable, !!e.disableScroll) } start(e, t, n) { return this.canStart(e) ? (this.requestedStart.set(t, n), !0) : (this.requestedStart.delete(t), !1) } capture(e, t, n) { if (!this.start(e, t, n)) return !1; const r = this.requestedStart; let s = -1e4; if (r.forEach(e => { s = Math.max(s, e) }), s === n) { this.capturedId = t, r.clear(); const n = new CustomEvent("ionGestureCaptured", { detail: { gestureName: e } }); return document.dispatchEvent(n), !0 } return r.delete(t), !1 } release(e) { this.requestedStart.delete(e), this.capturedId === e && (this.capturedId = void 0) } disableGesture(e, t) { let n = this.disabledGestures.get(e); void 0 === n && (n = new Set, this.disabledGestures.set(e, n)), n.add(t) } enableGesture(e, t) { const n = this.disabledGestures.get(e); void 0 !== n && n.delete(t) } disableScroll(e) { this.disabledScroll.add(e), 1 === this.disabledScroll.size && document.body.classList.add(i) } enableScroll(e) { this.disabledScroll.delete(e), 0 === this.disabledScroll.size && document.body.classList.remove(i) } canStart(e) { return void 0 === this.capturedId && !this.isDisabled(e) } isCaptured() { return void 0 !== this.capturedId } isScrollDisabled() { return this.disabledScroll.size > 0 } isDisabled(e) { const t = this.disabledGestures.get(e); return !!(t && t.size > 0) } newID() { return this.gestureId++, this.gestureId } } }, 3087: (e, t, n) => { "use strict"; n.r(t), n.d(t, { MENU_BACK_BUTTON_PRIORITY: () => o, OVERLAY_BACK_BUTTON_PRIORITY: () => i, blockHardwareBackButton: () => r, startHardwareBackButton: () => s }); const r = () => { document.addEventListener("backbutton", () => { }) }, s = () => { const e = document; let t = !1; e.addEventListener("backbutton", () => { if (t) return; let n = 0, r = []; const s = new CustomEvent("ionBackButton", { bubbles: !1, detail: { register(e, t) { r.push({ priority: e, handler: t, id: n++ }) } } }); e.dispatchEvent(s); const i = () => { if (r.length > 0) { let e = { priority: Number.MIN_SAFE_INTEGER, handler: () => { }, id: -1 }; r.forEach(t => { t.priority >= e.priority && (e = t) }), t = !0, r = r.filter(t => t.id !== e.id), (async e => { try { if (e && e.handler) { const t = e.handler(i); null != t && await t } } catch (t) { console.error(t) } })(e).then(() => t = !1) } }; i() }) }, i = 100, o = 99 }, 2377: (e, t, n) => { "use strict"; n.d(t, { a: () => i, b: () => o, c: () => r, d: () => h, e: () => d, f: () => v, g: () => a, h: () => u, i: () => s, j: () => f, k: () => l, l: () => p, m: () => y, n: () => w, o: () => m, p: () => g, r: () => c }); const r = (e, t) => { e.componentOnReady ? e.componentOnReady().then(e => t(e)) : c(() => t(e)) }, s = (e, t = []) => { const n = {}; return t.forEach(t => { e.hasAttribute(t) && (null !== e.getAttribute(t) && (n[t] = e.getAttribute(t)), e.removeAttribute(t)) }), n }, i = (e, t, n, r) => { if ("undefined" != typeof window) { const s = window, i = s && s.Ionic && s.Ionic.config; if (i) { const s = i.get("_ael"); if (s) return s(e, t, n, r); if (i._ael) return i._ael(e, t, n, r) } } return e.addEventListener(t, n, r) }, o = (e, t, n, r) => { if ("undefined" != typeof window) { const s = window, i = s && s.Ionic && s.Ionic.config; if (i) { const s = i.get("_rel"); if (s) return s(e, t, n, r); if (i._rel) return i._rel(e, t, n, r) } } return e.removeEventListener(t, n, r) }, a = (e, t = e) => e.shadowRoot || t, c = e => "function" == typeof __zone_symbol__requestAnimationFrame ? __zone_symbol__requestAnimationFrame(e) : "function" == typeof requestAnimationFrame ? requestAnimationFrame(e) : setTimeout(e), l = e => !!e.shadowRoot && !!e.attachShadow, u = e => { const t = e.closest("ion-item"); return t ? t.querySelector("ion-label") : null }, h = (e, t) => { let n; const r = e.getAttribute("aria-labelledby"), s = e.id; let i = null !== r && "" !== r.trim() ? r : t + "-lbl", o = null !== r && "" !== r.trim() ? document.getElementById(r) : u(e); return o ? (null === r && (o.id = i), n = o.textContent, o.setAttribute("aria-hidden", "true")) : "" !== s.trim() && (o = document.querySelector(`label[for="${s}"]`), o && ("" !== o.id ? i = o.id : o.id = i = `${s}-lbl`, n = o.textContent)), { label: o, labelId: i, labelText: n } }, d = (e, t, n, r, s) => { if (e || l(t)) { let e = t.querySelector("input.aux-input"); e || (e = t.ownerDocument.createElement("input"), e.type = "hidden", e.classList.add("aux-input"), t.appendChild(e)), e.disabled = s, e.name = n, e.value = r || "" } }, f = (e, t, n) => Math.max(e, Math.min(t, n)), p = (e, t) => { if (!e) { const e = "ASSERT: " + t; throw console.error(e), new Error(e) } }, m = e => e.timeStamp || Date.now(), g = e => { if (e) { const t = e.changedTouches; if (t && t.length > 0) { const e = t[0]; return { x: e.clientX, y: e.clientY } } if (void 0 !== e.pageX) return { x: e.pageX, y: e.pageY } } return { x: 0, y: 0 } }, y = e => { const t = "rtl" === document.dir; switch (e) { case "start": return t; case "end": return !t; default: throw new Error(`"${e}" is not a valid value for [side]. Use "start" or "end" instead.`) } }, v = (e, t) => { const n = e._original || e; return { _original: e, emit: w(n.emit.bind(n), t) } }, w = (e, t = 0) => { let n; return (...r) => { clearTimeout(n), n = setTimeout(e, t, ...r) } } }, 5554: (e, t, n) => { "use strict"; n.d(t, { m: () => h }); var r = n(3087), s = n(2377), i = n(7585), o = n(4086); const a = e => (0, o.c)().duration(e ? 400 : 300), c = e => { let t, n; const r = e.width + 8, s = (0, o.c)(), c = (0, o.c)(); e.isEndSide ? (t = r + "px", n = "0px") : (t = -r + "px", n = "0px"), s.addElement(e.menuInnerEl).fromTo("transform", `translateX(${t})`, `translateX(${n})`); const l = "ios" === (0, i.b)(e), u = l ? .2 : .25; return c.addElement(e.backdropEl).fromTo("opacity", .01, u), a(l).addAnimation([s, c]) }, l = e => { let t, n; const r = (0, i.b)(e), s = e.width; e.isEndSide ? (t = -s + "px", n = s + "px") : (t = s + "px", n = -s + "px"); const c = (0, o.c)().addElement(e.menuInnerEl).fromTo("transform", `translateX(${n})`, "translateX(0px)"), l = (0, o.c)().addElement(e.contentEl).fromTo("transform", "translateX(0px)", `translateX(${t})`), u = (0, o.c)().addElement(e.backdropEl).fromTo("opacity", .01, .32); return a("ios" === r).addAnimation([c, l, u]) }, u = e => { const t = (0, i.b)(e), n = e.width * (e.isEndSide ? -1 : 1) + "px", r = (0, o.c)().addElement(e.contentEl).fromTo("transform", "translateX(0px)", `translateX(${n})`); return a("ios" === t).addAnimation(r) }, h = (() => { const e = new Map, t = [], n = async e => (await p(), "start" === e || "end" === e ? f(t => t.side === e && !t.disabled) || f(t => t.side === e) : null != e ? f(t => t.menuId === e) : f(e => !e.disabled) || (t.length > 0 ? t[0].el : void 0)), i = async () => (await p(), h()), o = (t, n) => { e.set(t, n) }, a = e => { const n = e.side; t.filter(t => t.side === n && t !== e).forEach(e => e.disabled = !0) }, h = () => f(e => e._isOpen), d = () => t.some(e => e.isAnimating), f = e => { const n = t.find(e); if (void 0 !== n) return n.el }, p = () => Promise.all(Array.from(document.querySelectorAll("ion-menu")).map(e => new Promise(t => (0, s.c)(e, t)))); return o("reveal", u), o("push", l), o("overlay", c), "undefined" != typeof document && document.addEventListener("ionBackButton", e => { const t = h(); t && e.detail.register(r.MENU_BACK_BUTTON_PRIORITY, () => t.close()) }), { registerAnimation: o, get: n, getMenus: async () => (await p(), t.map(e => e.el)), getOpen: i, isEnabled: async e => { const t = await n(e); return !!t && !t.disabled }, swipeGesture: async (e, t) => { const r = await n(t); return r && (r.swipeGesture = e), r }, isAnimating: async () => (await p(), d()), isOpen: async e => { if (null != e) { const t = await n(e); return void 0 !== t && t.isOpen() } return void 0 !== await i() }, enable: async (e, t) => { const r = await n(t); return r && (r.disabled = !e), r }, toggle: async e => { const t = await n(e); return !!t && t.toggle() }, close: async e => { const t = await (void 0 !== e ? n(e) : i()); return void 0 !== t && t.close() }, open: async e => { const t = await n(e); return !!t && t.open() }, _getOpenSync: h, _createAnimation: (t, n) => { const r = e.get(t); if (!r) throw new Error("animation not registered"); return r(n) }, _register: e => { t.indexOf(e) < 0 && (e.disabled || a(e), t.push(e)) }, _unregister: e => { const n = t.indexOf(e); n > -1 && t.splice(n, 1) }, _setOpen: async (e, t, n) => { if (d()) return !1; if (t) { const t = await i(); t && e.el !== t && await t.setOpen(!1, !1) } return e._setOpen(t, n) }, _setActiveMenu: a } })() }, 9461: (e, t, n) => { "use strict"; n.r(t), n.d(t, { GESTURE_CONTROLLER: () => r.G, createGesture: () => c }); var r = n(960); const s = (e, t, n, r) => { const s = i(e) ? { capture: !!r.capture, passive: !!r.passive } : !!r.capture; let o, a; return e.__zone_symbol__addEventListener ? (o = "__zone_symbol__addEventListener", a = "__zone_symbol__removeEventListener") : (o = "addEventListener", a = "removeEventListener"), e[o](t, n, s), () => { e[a](t, n, s) } }, i = e => { if (void 0 === o) try { const t = Object.defineProperty({}, "passive", { get: () => { o = !0 } }); e.addEventListener("optsTest", () => { }, t) } catch (t) { o = !1 } return !!o }; let o; const a = e => e instanceof Document ? e : e.ownerDocument, c = e => { let t = !1, n = !1, i = !0, o = !1; const c = Object.assign({ disableScroll: !1, direction: "x", gesturePriority: 0, passive: !0, maxAngle: 40, threshold: 10 }, e), d = c.canStart, f = c.onWillStart, p = c.onStart, m = c.onEnd, g = c.notCaptured, y = c.onMove, v = c.threshold, w = c.passive, b = c.blurOnStart, _ = { type: "pan", startX: 0, startY: 0, startTime: 0, currentX: 0, currentY: 0, velocityX: 0, velocityY: 0, deltaX: 0, deltaY: 0, currentTime: 0, event: void 0, data: void 0 }, E = ((e, t, n) => { const r = n * (Math.PI / 180), s = "x" === e, i = Math.cos(r), o = t * t; let a = 0, c = 0, l = !1, u = 0; return { start(e, t) { a = e, c = t, u = 0, l = !0 }, detect(e, t) { if (!l) return !1; const n = e - a, r = t - c, h = n * n + r * r; if (h < o) return !1; const d = Math.sqrt(h), f = (s ? n : r) / d; return u = f > i ? 1 : f < -i ? -1 : 0, l = !1, !0 }, isGesture: () => 0 !== u, getDirection: () => u } })(c.direction, c.threshold, c.maxAngle), C = r.G.createGesture({ name: e.gestureName, priority: e.gesturePriority, disableScroll: e.disableScroll }), S = () => { t && (o = !1, y && y(_)) }, T = () => !(C && !C.capture() || (t = !0, i = !1, _.startX = _.currentX, _.startY = _.currentY, _.startTime = _.currentTime, f ? f(_).then(I) : I(), 0)), I = () => { b && (() => { if ("undefined" != typeof document) { const e = document.activeElement; null !== e && e.blur && e.blur() } })(), p && p(_), i = !0 }, k = () => { t = !1, n = !1, o = !1, i = !0, C.release() }, A = e => { const n = t, r = i; k(), r && (l(_, e), n ? m && m(_) : g && g(_)) }, x = ((e, t, n, r, i) => { let o, c, l, u, h, d, f, p = 0; const m = r => { p = Date.now() + 2e3, t(r) && (!c && n && (c = s(e, "touchmove", n, i)), l || (l = s(r.target, "touchend", y, i)), u || (u = s(r.target, "touchcancel", y, i))) }, g = r => { p > Date.now() || t(r) && (!d && n && (d = s(a(e), "mousemove", n, i)), f || (f = s(a(e), "mouseup", v, i))) }, y = e => { w(), r && r(e) }, v = e => { b(), r && r(e) }, w = () => { c && c(), l && l(), u && u(), c = l = u = void 0 }, b = () => { d && d(), f && f(), d = f = void 0 }, _ = () => { w(), b() }, E = (t = !0) => { t ? (o || (o = s(e, "touchstart", m, i)), h || (h = s(e, "mousedown", g, i))) : (o && o(), h && h(), o = h = void 0, _()) }; return { enable: E, stop: _, destroy: () => { E(!1), r = n = t = void 0 } } })(c.el, e => { const t = h(e); return !(n || !i) && (u(e, _), _.startX = _.currentX, _.startY = _.currentY, _.startTime = _.currentTime = t, _.velocityX = _.velocityY = _.deltaX = _.deltaY = 0, _.event = e, (!d || !1 !== d(_)) && (C.release(), !!C.start() && (n = !0, 0 === v ? T() : (E.start(_.startX, _.startY), !0)))) }, e => { t ? !o && i && (o = !0, l(_, e), requestAnimationFrame(S)) : (l(_, e), E.detect(_.currentX, _.currentY) && (E.isGesture() && T() || D())) }, A, { capture: !1, passive: w }), D = () => { k(), x.stop(), g && g(_) }; return { enable(e = !0) { e || (t && A(void 0), k()), x.enable(e) }, destroy() { C.destroy(), x.destroy() } } }, l = (e, t) => { if (!t) return; const n = e.currentX, r = e.currentY, s = e.currentTime; u(t, e); const i = e.currentX, o = e.currentY, a = (e.currentTime = h(t)) - s; if (a > 0 && a < 100) { const t = (o - r) / a; e.velocityX = (i - n) / a * .7 + .3 * e.velocityX, e.velocityY = .7 * t + .3 * e.velocityY } e.deltaX = i - e.startX, e.deltaY = o - e.startY, e.event = t }, u = (e, t) => { let n = 0, r = 0; if (e) { const t = e.changedTouches; if (t && t.length > 0) { const e = t[0]; n = e.clientX, r = e.clientY } else void 0 !== e.pageX && (n = e.pageX, r = e.pageY) } t.currentX = n, t.currentY = r }, h = e => e.timeStamp || Date.now() }, 3150: (e, t, n) => { "use strict"; n.d(t, { B: () => je, C: () => d, H: () => F, a: () => g, b: () => Ee, c: () => Ue, e: () => re, f: () => Ve, g: () => D, h: () => N, i: () => ne, j: () => he, k: () => Ce, p: () => p, r: () => Ie, s: () => x, w: () => h }); let r, s, i, o = !1, a = !1, c = !1, l = !1, u = !1; const h = "undefined" != typeof window ? window : {}, d = h.CSS, f = h.document || { head: {} }, p = { $flags$: 0, $resourcesUrl$: "", jmp: e => e(), raf: e => requestAnimationFrame(e), ael: (e, t, n, r) => e.addEventListener(t, n, r), rel: (e, t, n, r) => e.removeEventListener(t, n, r), ce: (e, t) => new CustomEvent(e, t) }, m = (() => (f.head.attachShadow + "").indexOf("[native") > -1)(), g = e => Promise.resolve(e), y = (() => { try { return new CSSStyleSheet, "function" == typeof (new CSSStyleSheet).replace } catch (e) { } return !1 })(), v = (e, t, n, r) => { n && n.map(([n, r, s]) => { const i = b(e, n), o = w(t, s), a = _(n); p.ael(i, r, o, a), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => p.rel(i, r, o, a)) }) }, w = (e, t) => n => { try { 256 & e.$flags$ ? e.$lazyInstance$[t](n) : (e.$queuedListeners$ = e.$queuedListeners$ || []).push([t, n]) } catch (r) { xe(r) } }, b = (e, t) => 4 & t ? f : 8 & t ? h : 16 & t ? f.body : e, _ = e => 0 != (2 & e), E = "s-id", C = "c-id", S = "http://www.w3.org/1999/xlink", T = new WeakMap, I = (e, t, n) => { let r = Re.get(e); y && n ? (r = r || new CSSStyleSheet, r.replace(t)) : r = t, Re.set(e, r) }, k = (e, t, n, r) => { let s = A(t, n), i = Re.get(s); if (e = 11 === e.nodeType ? e : f, i) if ("string" == typeof i) { let n, o = T.get(e = e.head || e); if (o || T.set(e, o = new Set), !o.has(s)) { if (e.host && (n = e.querySelector(`[sty-id="${s}"]`))) n.innerHTML = i; else { if (p.$cssShim$) { n = p.$cssShim$.createHostStyle(r, s, i, !!(10 & t.$flags$)); const e = n["s-sc"]; e && (s = e, o = null) } else n = f.createElement("style"), n.innerHTML = i; e.insertBefore(n, e.querySelector("link")) } o && o.add(s) } } else e.adoptedStyleSheets.includes(i) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, i]); return s }, A = (e, t) => "sc-" + (t && 32 & e.$flags$ ? e.$tagName$ + "-" + t : e.$tagName$), x = e => Ne.push(e), D = e => Te(e).$modeName$, O = {}, R = e => "object" == (e = typeof e) || "function" === e, N = (e, t, ...n) => { let r = null, s = null, i = null, o = !1, a = !1, c = []; const l = t => { for (let n = 0; n < t.length; n++)r = t[n], Array.isArray(r) ? l(r) : null != r && "boolean" != typeof r && ((o = "function" != typeof e && !R(r)) && (r = String(r)), o && a ? c[c.length - 1].$text$ += r : c.push(o ? P(null, r) : r), a = o) }; if (l(n), t) { t.key && (s = t.key), t.name && (i = t.name); { const e = t.className || t.class; e && (t.class = "object" != typeof e ? e : Object.keys(e).filter(t => e[t]).join(" ")) } } if ("function" == typeof e) return e(null === t ? {} : t, c, L); const u = P(e, null); return u.$attrs$ = t, c.length > 0 && (u.$children$ = c), u.$key$ = s, u.$name$ = i, u }, P = (e, t) => ({ $flags$: 0, $tag$: e, $text$: t, $elm$: null, $children$: null, $attrs$: null, $key$: null, $name$: null }), F = {}, L = { forEach: (e, t) => e.map(M).forEach(t), map: (e, t) => e.map(M).map(t).map($) }, M = e => ({ vattrs: e.$attrs$, vchildren: e.$children$, vkey: e.$key$, vname: e.$name$, vtag: e.$tag$, vtext: e.$text$ }), $ = e => { if ("function" == typeof e.vtag) { const t = Object.assign({}, e.vattrs); return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), N(e.vtag, t, ...e.vchildren || []) } const t = P(e.vtag, e.vtext); return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t }, B = (e, t, n, r, s, i) => { if (n !== r) { let a = Ae(e, t), c = t.toLowerCase(); if ("class" === t) { const t = e.classList, s = U(n), i = U(r); t.remove(...s.filter(e => e && !i.includes(e))), t.add(...i.filter(e => e && !s.includes(e))) } else if ("style" === t) { for (const t in n) r && null != r[t] || (t.includes("-") ? e.style.removeProperty(t) : e.style[t] = ""); for (const t in r) n && r[t] === n[t] || (t.includes("-") ? e.style.setProperty(t, r[t]) : e.style[t] = r[t]) } else if ("key" === t); else if ("ref" === t) r && r(e); else if (a || "o" !== t[0] || "n" !== t[1]) { const l = R(r); if ((a || l && null !== r) && !s) try { if (e.tagName.includes("-")) e[t] = r; else { let s = null == r ? "" : r; "list" === t ? a = !1 : null != n && e[t] == s || (e[t] = s) } } catch (o) { } let u = !1; c !== (c = c.replace(/^xlink\:?/, "")) && (t = c, u = !0), null == r || !1 === r ? !1 === r && "" !== e.getAttribute(t) || (u ? e.removeAttributeNS(S, t) : e.removeAttribute(t)) : (!a || 4 & i || s) && !l && (r = !0 === r ? "" : r, u ? e.setAttributeNS(S, t, r) : e.setAttribute(t, r)) } else t = "-" === t[2] ? t.slice(3) : Ae(h, c) ? c.slice(2) : c[2] + t.slice(3), n && p.rel(e, t, n, !1), r && p.ael(e, t, r, !1) } }, V = /\s/, U = e => e ? e.split(V) : [], j = (e, t, n, r) => { const s = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$, i = e && e.$attrs$ || O, o = t.$attrs$ || O; for (r in i) r in o || B(s, r, i[r], void 0, n, t.$flags$); for (r in o) B(s, r, i[r], o[r], n, t.$flags$) }, q = (e, t, n, a) => { let u, h, d, p = t.$children$[n], m = 0; if (o || (c = !0, "slot" === p.$tag$ && (r && a.classList.add(r + "-s"), p.$flags$ |= p.$children$ ? 2 : 1)), null !== p.$text$) u = p.$elm$ = f.createTextNode(p.$text$); else if (1 & p.$flags$) u = p.$elm$ = f.createTextNode(""); else { if (l || (l = "svg" === p.$tag$), u = p.$elm$ = f.createElementNS(l ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", 2 & p.$flags$ ? "slot-fb" : p.$tag$), l && "foreignObject" === p.$tag$ && (l = !1), j(null, p, l), null != r && u["s-si"] !== r && u.classList.add(u["s-si"] = r), p.$children$) for (m = 0; m < p.$children$.length; ++m)h = q(e, p, m, u), h && u.appendChild(h); "svg" === p.$tag$ ? l = !1 : "foreignObject" === u.tagName && (l = !0) } return u["s-hn"] = i, 3 & p.$flags$ && (u["s-sr"] = !0, u["s-cr"] = s, u["s-sn"] = p.$name$ || "", d = e && e.$children$ && e.$children$[n], d && d.$tag$ === p.$tag$ && e.$elm$ && z(e.$elm$, !1)), u }, z = (e, t) => { p.$flags$ |= 1; const n = e.childNodes; for (let r = n.length - 1; r >= 0; r--) { const e = n[r]; e["s-hn"] !== i && e["s-ol"] && (K(e).insertBefore(e, Y(e)), e["s-ol"].remove(), e["s-ol"] = void 0, c = !0), t && z(e, t) } p.$flags$ &= -2 }, H = (e, t, n, r, s, o) => { let a, c = e["s-cr"] && e["s-cr"].parentNode || e; for (c.shadowRoot && c.tagName === i && (c = c.shadowRoot); s <= o; ++s)r[s] && (a = q(null, n, s, e), a && (r[s].$elm$ = a, c.insertBefore(a, Y(t)))) }, G = (e, t, n, r, s) => { for (; t <= n; ++t)(r = e[t]) && (s = r.$elm$, te(r), a = !0, s["s-ol"] ? s["s-ol"].remove() : z(s, !0), s.remove()) }, W = (e, t) => e.$tag$ === t.$tag$ && ("slot" === e.$tag$ ? e.$name$ === t.$name$ : e.$key$ === t.$key$), Y = e => e && e["s-ol"] || e, K = e => (e["s-ol"] ? e["s-ol"] : e).parentNode, X = (e, t) => { const n = t.$elm$ = e.$elm$, r = e.$children$, s = t.$children$, i = t.$tag$, o = t.$text$; let a; null === o ? (l = "svg" === i || "foreignObject" !== i && l, "slot" === i || j(e, t, l), null !== r && null !== s ? ((e, t, n, r) => { let s, i, o = 0, a = 0, c = 0, l = 0, u = t.length - 1, h = t[0], d = t[u], f = r.length - 1, p = r[0], m = r[f]; for (; o <= u && a <= f;)if (null == h) h = t[++o]; else if (null == d) d = t[--u]; else if (null == p) p = r[++a]; else if (null == m) m = r[--f]; else if (W(h, p)) X(h, p), h = t[++o], p = r[++a]; else if (W(d, m)) X(d, m), d = t[--u], m = r[--f]; else if (W(h, m)) "slot" !== h.$tag$ && "slot" !== m.$tag$ || z(h.$elm$.parentNode, !1), X(h, m), e.insertBefore(h.$elm$, d.$elm$.nextSibling), h = t[++o], m = r[--f]; else if (W(d, p)) "slot" !== h.$tag$ && "slot" !== m.$tag$ || z(d.$elm$.parentNode, !1), X(d, p), e.insertBefore(d.$elm$, h.$elm$), d = t[--u], p = r[++a]; else { for (c = -1, l = o; l <= u; ++l)if (t[l] && null !== t[l].$key$ && t[l].$key$ === p.$key$) { c = l; break } c >= 0 ? (i = t[c], i.$tag$ !== p.$tag$ ? s = q(t && t[a], n, c, e) : (X(i, p), t[c] = void 0, s = i.$elm$), p = r[++a]) : (s = q(t && t[a], n, a, e), p = r[++a]), s && K(h.$elm$).insertBefore(s, Y(h.$elm$)) } o > u ? H(e, null == r[f + 1] ? null : r[f + 1].$elm$, n, r, a, f) : a > f && G(t, o, u) })(n, r, t, s) : null !== s ? (null !== e.$text$ && (n.textContent = ""), H(n, null, t, s, 0, s.length - 1)) : null !== r && G(r, 0, r.length - 1), l && "svg" === i && (l = !1)) : (a = n["s-cr"]) ? a.parentNode.textContent = o : e.$text$ !== o && (n.data = o) }, Z = e => { let t, n, r, s, i, o, a = e.childNodes; for (n = 0, r = a.length; n < r; n++)if (t = a[n], 1 === t.nodeType) { if (t["s-sr"]) for (i = t["s-sn"], t.hidden = !1, s = 0; s < r; s++)if (o = a[s].nodeType, a[s]["s-hn"] !== t["s-hn"] || "" !== i) { if (1 === o && i === a[s].getAttribute("slot")) { t.hidden = !0; break } } else if (1 === o || 3 === o && "" !== a[s].textContent.trim()) { t.hidden = !0; break } Z(t) } }, Q = [], J = e => { let t, n, r, s, i, o, c = 0, l = e.childNodes, u = l.length; for (; c < u; c++) { if (t = l[c], t["s-sr"] && (n = t["s-cr"]) && n.parentNode) for (r = n.parentNode.childNodes, s = t["s-sn"], o = r.length - 1; o >= 0; o--)n = r[o], n["s-cn"] || n["s-nr"] || n["s-hn"] === t["s-hn"] || (ee(n, s) ? (i = Q.find(e => e.$nodeToRelocate$ === n), a = !0, n["s-sn"] = n["s-sn"] || s, i ? i.$slotRefNode$ = t : Q.push({ $slotRefNode$: t, $nodeToRelocate$: n }), n["s-sr"] && Q.map(e => { ee(e.$nodeToRelocate$, n["s-sn"]) && (i = Q.find(e => e.$nodeToRelocate$ === n), i && !e.$slotRefNode$ && (e.$slotRefNode$ = i.$slotRefNode$)) })) : Q.some(e => e.$nodeToRelocate$ === n) || Q.push({ $nodeToRelocate$: n })); 1 === t.nodeType && J(t) } }, ee = (e, t) => 1 === e.nodeType ? null === e.getAttribute("slot") && "" === t || e.getAttribute("slot") === t : e["s-sn"] === t || "" === t, te = e => { e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(te) }, ne = e => Te(e).$hostElement$, re = (e, t, n) => { const r = ne(e); return { emit: e => se(r, t, { bubbles: !!(4 & n), composed: !!(2 & n), cancelable: !!(1 & n), detail: e }) } }, se = (e, t, n) => { const r = p.ce(t, n); return e.dispatchEvent(r), r }, ie = (e, t) => { t && !e.$onRenderResolve$ && t["s-p"] && t["s-p"].push(new Promise(t => e.$onRenderResolve$ = t)) }, oe = (e, t) => { if (e.$flags$ |= 16, !(4 & e.$flags$)) return ie(e, e.$ancestorComponent$), Ue(() => ae(e, t)); e.$flags$ |= 512 }, ae = (e, t) => { const n = e.$lazyInstance$; let r; return t && (e.$flags$ |= 256, e.$queuedListeners$ && (e.$queuedListeners$.map(([e, t]) => fe(n, e, t)), e.$queuedListeners$ = null), r = fe(n, "componentWillLoad")), r = pe(r, () => fe(n, "componentWillRender")), pe(r, () => ce(e, n, t)) }, ce = async (e, t, n) => { const r = e.$hostElement$, s = r["s-rc"]; n && (e => { const t = e.$cmpMeta$, n = e.$hostElement$, r = t.$flags$, s = k(m && n.shadowRoot ? n.shadowRoot : n.getRootNode(), t, e.$modeName$, n); 10 & r && (n["s-sc"] = s, n.classList.add(s + "-h"), 2 & r && n.classList.add(s + "-s")) })(e), le(e, t), p.$cssShim$ && p.$cssShim$.updateHost(r), s && (s.map(e => e()), r["s-rc"] = void 0); { const t = r["s-p"], n = () => ue(e); 0 === t.length ? n() : (Promise.all(t).then(n), e.$flags$ |= 4, t.length = 0) } }, le = (e, t, n) => { try { t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, ((e, t) => { const n = e.$hostElement$, l = e.$cmpMeta$, u = e.$vnode$ || P(null, null), h = (d = t) && d.$tag$ === F ? t : N(null, null, t); var d; if (i = n.tagName, l.$attrsToReflect$ && (h.$attrs$ = h.$attrs$ || {}, l.$attrsToReflect$.map(([e, t]) => h.$attrs$[t] = n[e])), h.$tag$ = null, h.$flags$ |= 4, e.$vnode$ = h, h.$elm$ = u.$elm$ = n.shadowRoot || n, r = n["s-sc"], s = n["s-cr"], o = m && 0 != (1 & l.$flags$), a = !1, X(u, h), p.$flags$ |= 1, c) { let e, t, n, r, s, i; J(h.$elm$); let o = 0; for (; o < Q.length; o++)e = Q[o], t = e.$nodeToRelocate$, t["s-ol"] || (n = f.createTextNode(""), n["s-nr"] = t, t.parentNode.insertBefore(t["s-ol"] = n, t)); for (o = 0; o < Q.length; o++)if (e = Q[o], t = e.$nodeToRelocate$, e.$slotRefNode$) { for (r = e.$slotRefNode$.parentNode, s = e.$slotRefNode$.nextSibling, n = t["s-ol"]; n = n.previousSibling;)if (i = n["s-nr"], i && i["s-sn"] === t["s-sn"] && r === i.parentNode && (i = i.nextSibling, !i || !i["s-nr"])) { s = i; break } (!s && r !== t.parentNode || t.nextSibling !== s) && t !== s && (!t["s-hn"] && t["s-ol"] && (t["s-hn"] = t["s-ol"].parentNode.nodeName), r.insertBefore(t, s)) } else 1 === t.nodeType && (t.hidden = !0) } a && Z(h.$elm$), p.$flags$ &= -2, Q.length = 0 })(e, t) } catch (l) { xe(l, e.$hostElement$) } return null }, ue = e => { const t = e.$hostElement$, n = e.$lazyInstance$, r = e.$ancestorComponent$; 64 & e.$flags$ ? fe(n, "componentDidUpdate") : (e.$flags$ |= 64, me(t), fe(n, "componentDidLoad"), e.$onReadyResolve$(t), r || de()), e.$onInstanceResolve$(t), e.$onRenderResolve$ && (e.$onRenderResolve$(), e.$onRenderResolve$ = void 0), 512 & e.$flags$ && Be(() => oe(e, !1)), e.$flags$ &= -517 }, he = e => { { const t = Te(e), n = t.$hostElement$.isConnected; return n && 2 == (18 & t.$flags$) && oe(t, !1), n } }, de = e => { me(f.documentElement), Be(() => se(h, "appload", { detail: { namespace: "ionic" } })) }, fe = (e, t, n) => { if (e && e[t]) try { return e[t](n) } catch (r) { xe(r) } }, pe = (e, t) => e && e.then ? e.then(t) : t(), me = e => e.classList.add("hydrated"), ge = (e, t, n, r, s, i, o) => { let a, c, l, u; if (1 === i.nodeType) { for (a = i.getAttribute(C), a && (c = a.split("."), c[0] !== o && "0" !== c[0] || (l = { $flags$: 0, $hostId$: c[0], $nodeId$: c[1], $depth$: c[2], $index$: c[3], $tag$: i.tagName.toLowerCase(), $elm$: i, $attrs$: null, $children$: null, $key$: null, $name$: null, $text$: null }, t.push(l), i.removeAttribute(C), e.$children$ || (e.$children$ = []), e.$children$[l.$index$] = l, e = l, r && "0" === l.$depth$ && (r[l.$index$] = l.$elm$))), u = i.childNodes.length - 1; u >= 0; u--)ge(e, t, n, r, s, i.childNodes[u], o); if (i.shadowRoot) for (u = i.shadowRoot.childNodes.length - 1; u >= 0; u--)ge(e, t, n, r, s, i.shadowRoot.childNodes[u], o) } else if (8 === i.nodeType) c = i.nodeValue.split("."), c[1] !== o && "0" !== c[1] || (a = c[0], l = { $flags$: 0, $hostId$: c[1], $nodeId$: c[2], $depth$: c[3], $index$: c[4], $elm$: i, $attrs$: null, $children$: null, $key$: null, $name$: null, $tag$: null, $text$: null }, "t" === a ? (l.$elm$ = i.nextSibling, l.$elm$ && 3 === l.$elm$.nodeType && (l.$text$ = l.$elm$.textContent, t.push(l), i.remove(), e.$children$ || (e.$children$ = []), e.$children$[l.$index$] = l, r && "0" === l.$depth$ && (r[l.$index$] = l.$elm$))) : l.$hostId$ === o && ("s" === a ? (l.$tag$ = "slot", i["s-sn"] = c[5] ? l.$name$ = c[5] : "", i["s-sr"] = !0, r && (l.$elm$ = f.createElement(l.$tag$), l.$name$ && l.$elm$.setAttribute("name", l.$name$), i.parentNode.insertBefore(l.$elm$, i), i.remove(), "0" === l.$depth$ && (r[l.$index$] = l.$elm$)), n.push(l), e.$children$ || (e.$children$ = []), e.$children$[l.$index$] = l) : "r" === a && (r ? i.remove() : (s["s-cr"] = i, i["s-cn"] = !0)))); else if (e && "style" === e.$tag$) { const t = P(null, i.textContent); t.$elm$ = i, t.$index$ = "0", e.$children$ = [t] } }, ye = (e, t) => { if (1 === e.nodeType) { let n = 0; for (; n < e.childNodes.length; n++)ye(e.childNodes[n], t); if (e.shadowRoot) for (n = 0; n < e.shadowRoot.childNodes.length; n++)ye(e.shadowRoot.childNodes[n], t) } else if (8 === e.nodeType) { const n = e.nodeValue.split("."); "o" === n[0] && (t.set(n[1] + "." + n[2], e), e.nodeValue = "", e["s-en"] = n[3]) } }, ve = (e, t, n) => { if (t.$members$) { e.watchers && (t.$watchers$ = e.watchers); const r = Object.entries(t.$members$), s = e.prototype; if (r.map(([e, [r]]) => { 31 & r || 2 & n && 32 & r ? Object.defineProperty(s, e, { get() { return t = e, Te(this).$instanceValues$.get(t); var t }, set(n) { ((e, t, n, r) => { const s = Te(this), i = s.$hostElement$, o = s.$instanceValues$.get(t), a = s.$flags$, c = s.$lazyInstance$; var l, u; if (u = r.$members$[t][0], n = null == (l = n) || R(l) ? l : 4 & u ? "false" !== l && ("" === l || !!l) : 2 & u ? parseFloat(l) : 1 & u ? String(l) : l, !(8 & a && void 0 !== o || n === o) && (s.$instanceValues$.set(t, n), c)) { if (r.$watchers$ && 128 & a) { const e = r.$watchers$[t]; e && e.map(e => { try { c[e](n, o, t) } catch (r) { xe(r, i) } }) } 2 == (18 & a) && oe(s, !1) } })(0, e, n, t) }, configurable: !0, enumerable: !0 }) : 1 & n && 64 & r && Object.defineProperty(s, e, { value(...t) { const n = Te(this); return n.$onInstancePromise$.then(() => n.$lazyInstance$[e](...t)) } }) }), 1 & n) { const n = new Map; s.attributeChangedCallback = function (e, t, r) { p.jmp(() => { const t = n.get(e); this[t] = (null !== r || "boolean" != typeof this[t]) && r }) }, e.observedAttributes = r.filter(([e, t]) => 15 & t[0]).map(([e, r]) => { const s = r[1] || e; return n.set(s, e), 512 & r[0] && t.$attrsToReflect$.push([e, s]), s }) } } return e }, we = e => { fe(e, "connectedCallback") }, be = e => { if (0 == (1 & p.$flags$)) { const t = Te(e), r = t.$cmpMeta$, s = () => { }; if (1 & t.$flags$) v(e, t, r.$listeners$), we(t.$lazyInstance$); else { let s; if (t.$flags$ |= 1, s = e.getAttribute(E), s) { if (m && 1 & r.$flags$) { const t = k(e.shadowRoot, r, e.getAttribute("s-mode")); e.classList.remove(t + "-h", t + "-s") } ((e, t, n, r) => { const s = e.shadowRoot, i = [], o = s ? [] : null, a = r.$vnode$ = P(t, null); p.$orgLocNodes$ || ye(f.body, p.$orgLocNodes$ = new Map), e["s-id"] = n, e.removeAttribute(E), ge(a, i, [], o, e, e, n), i.map(e => { const n = e.$hostId$ + "." + e.$nodeId$, r = p.$orgLocNodes$.get(n), i = e.$elm$; r && m && "" === r["s-en"] && r.parentNode.insertBefore(i, r.nextSibling), s || (i["s-hn"] = t, r && (i["s-ol"] = r, i["s-ol"]["s-nr"] = i)), p.$orgLocNodes$.delete(n) }), s && o.map(e => { e && s.appendChild(e) }) })(e, r.$tagName$, s, t) } s || 12 & r.$flags$ && _e(e); { let n = e; for (; n = n.parentNode || n.host;)if (1 === n.nodeType && n.hasAttribute("s-id") && n["s-p"] || n["s-p"]) { ie(t, t.$ancestorComponent$ = n); break } } r.$members$ && Object.entries(r.$members$).map(([t, [n]]) => { if (31 & n && e.hasOwnProperty(t)) { const n = e[t]; delete e[t], e[t] = n } }), Be(() => (async (e, t, r, s, i) => { if (0 == (32 & t.$flags$)) { { if (t.$flags$ |= 32, (i = Oe(r)).then) { const e = () => { }; i = await i, e() } i.isProxied || (r.$watchers$ = i.watchers, ve(i, r, 2), i.isProxied = !0); const e = () => { }; t.$flags$ |= 8; try { new i(t) } catch (c) { xe(c) } t.$flags$ &= -9, t.$flags$ |= 128, e(), we(t.$lazyInstance$) } if (i.style) { let s = i.style; "string" != typeof s && (s = s[t.$modeName$ = (e => Ne.map(t => t(e)).find(e => !!e))(e)]); const o = A(r, t.$modeName$); if (!Re.has(o)) { const e = () => { }; 8 & r.$flags$ && (s = await n.e(8810).then(n.bind(n, 8810)).then(e => e.scopeCss(s, o, !1))), I(o, s, !!(1 & r.$flags$)), e() } } } const o = t.$ancestorComponent$, a = () => oe(t, !0); o && o["s-rc"] ? o["s-rc"].push(a) : a() })(e, t, r)) } s() } }, _e = e => { const t = e["s-cr"] = f.createComment(""); t["s-cn"] = !0, e.insertBefore(t, e.firstChild) }, Ee = (e, t = {}) => { const n = [], r = t.exclude || [], s = h.customElements, i = f.head, o = i.querySelector("meta[charset]"), a = f.createElement("style"), c = [], l = f.querySelectorAll("[sty-id]"); let u, d = !0, g = 0; for (Object.assign(p, t), p.$resourcesUrl$ = new URL(t.resourcesUrl || "./", f.baseURI).href, p.$flags$ |= 2; g < l.length; g++)I(l[g].getAttribute("sty-id"), l[g].innerHTML.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, "$1{"), !0); e.map(e => e[1].map(t => { const i = { $flags$: t[0], $tagName$: t[1], $members$: t[2], $listeners$: t[3] }; i.$members$ = t[2], i.$listeners$ = t[3], i.$attrsToReflect$ = [], i.$watchers$ = {}, !m && 1 & i.$flags$ && (i.$flags$ |= 8); const o = i.$tagName$, a = class extends HTMLElement { constructor(e) { super(e), ke(e = this, i), 1 & i.$flags$ && (m ? e.attachShadow({ mode: "open", delegatesFocus: !!(16 & i.$flags$) }) : "shadowRoot" in e || (e.shadowRoot = e)) } connectedCallback() { u && (clearTimeout(u), u = null), d ? c.push(this) : p.jmp(() => be(this)) } disconnectedCallback() { p.jmp(() => (e => { if (0 == (1 & p.$flags$)) { const t = Te(e), n = t.$lazyInstance$; t.$rmListeners$ && (t.$rmListeners$.map(e => e()), t.$rmListeners$ = void 0), p.$cssShim$ && p.$cssShim$.removeHost(e), fe(n, "disconnectedCallback") } })(this)) } componentOnReady() { return Te(this).$onReadyPromise$ } }; i.$lazyBundleId$ = e[0], r.includes(o) || s.get(o) || (n.push(o), s.define(o, ve(a, i, 1))) })), a.innerHTML = n + "{visibility:hidden}.hydrated{visibility:inherit}", a.setAttribute("data-styles", ""), i.insertBefore(a, o ? o.nextSibling : i.firstChild), d = !1, c.length ? c.map(e => e.connectedCallback()) : p.jmp(() => u = setTimeout(de, 30)) }, Ce = e => { const t = new URL(e, p.$resourcesUrl$); return t.origin !== h.location.origin ? t.href : t.pathname }, Se = new WeakMap, Te = e => Se.get(e), Ie = (e, t) => Se.set(t.$lazyInstance$ = e, t), ke = (e, t) => { const n = { $flags$: 0, $hostElement$: e, $cmpMeta$: t, $instanceValues$: new Map }; return n.$onInstancePromise$ = new Promise(e => n.$onInstanceResolve$ = e), n.$onReadyPromise$ = new Promise(e => n.$onReadyResolve$ = e), e["s-p"] = [], e["s-rc"] = [], v(e, n, t.$listeners$), Se.set(e, n) }, Ae = (e, t) => t in e, xe = (e, t) => (0, console.error)(e, t), De = new Map, Oe = (e, t, r) => { const s = e.$tagName$.replace(/-/g, "_"), i = e.$lazyBundleId$, o = De.get(i); return o ? o[s] : n(863)(`./${i}.entry.js`).then(e => (De.set(i, e), e[s]), xe) }, Re = new Map, Ne = [], Pe = [], Fe = [], Le = (e, t) => n => { e.push(n), u || (u = !0, t && 4 & p.$flags$ ? Be($e) : p.raf($e)) }, Me = e => { for (let n = 0; n < e.length; n++)try { e[n](performance.now()) } catch (t) { xe(t) } e.length = 0 }, $e = () => { Me(Pe), Me(Fe), (u = Pe.length > 0) && p.raf($e) }, Be = e => g().then(e), Ve = Le(Pe, !1), Ue = Le(Fe, !0), je = { isDev: !1, isBrowser: !0, isServer: !1, isTesting: !1 } }, 4001: (e, t, n) => { "use strict"; n.d(t, { L: () => i, a: () => o, b: () => a, c: () => c, d: () => l, e: () => S, g: () => k, l: () => E, s: () => T, t: () => u }); var r = n(3150), s = n(2377); const i = "ionViewWillEnter", o = "ionViewDidEnter", a = "ionViewWillLeave", c = "ionViewDidLeave", l = "ionViewWillUnload", u = e => new Promise((t, n) => { (0, r.c)(() => { h(e), d(e).then(n => { n.animation && n.animation.destroy(), f(e), t(n) }, t => { f(e), n(t) }) }) }), h = e => { const t = e.enteringEl, n = e.leavingEl; I(t, n, e.direction), e.showGoBack ? t.classList.add("can-go-back") : t.classList.remove("can-go-back"), T(t, !1), t.style.setProperty("pointer-events", "none"), n && (T(n, !1), n.style.setProperty("pointer-events", "none")) }, d = async e => { const t = await p(e); return t && r.B.isBrowser ? m(t, e) : g(e) }, f = e => { const t = e.enteringEl, n = e.leavingEl; t.classList.remove("ion-page-invisible"), t.style.removeProperty("pointer-events"), void 0 !== n && (n.classList.remove("ion-page-invisible"), n.style.removeProperty("pointer-events")) }, p = async e => { if (e.leavingEl && e.animated && 0 !== e.duration) return e.animationBuilder ? e.animationBuilder : "ios" === e.mode ? (await Promise.resolve().then(n.bind(n, 9554))).iosTransitionAnimation : (await Promise.resolve().then(n.bind(n, 7405))).mdTransitionAnimation }, m = async (e, t) => { await y(t, !0); const n = e(t.baseEl, t); b(t.enteringEl, t.leavingEl); const r = await w(n, t); return t.progressCallback && t.progressCallback(void 0), r && _(t.enteringEl, t.leavingEl), { hasCompleted: r, animation: n } }, g = async e => { const t = e.enteringEl, n = e.leavingEl; return await y(e, !1), b(t, n), _(t, n), { hasCompleted: !0 } }, y = async (e, t) => { const n = (void 0 !== e.deepWait ? e.deepWait : t) ? [S(e.enteringEl), S(e.leavingEl)] : [C(e.enteringEl), C(e.leavingEl)]; await Promise.all(n), await v(e.viewIsReady, e.enteringEl) }, v = async (e, t) => { e && await e(t) }, w = (e, t) => { const n = t.progressCallback, r = new Promise(t => { e.onFinish(e => t(1 === e)) }); return n ? (e.progressStart(!0), n(e)) : e.play(), r }, b = (e, t) => { E(t, a), E(e, i) }, _ = (e, t) => { E(e, o), E(t, c) }, E = (e, t) => { if (e) { const n = new CustomEvent(t, { bubbles: !1, cancelable: !1 }); e.dispatchEvent(n) } }, C = e => e ? new Promise(t => (0, s.c)(e, t)) : Promise.resolve(), S = async e => { const t = e; if (t) { if (null != t.componentOnReady && null != await t.componentOnReady()) return; await Promise.all(Array.from(t.children).map(S)) } }, T = (e, t) => { t ? (e.setAttribute("aria-hidden", "true"), e.classList.add("ion-page-hidden")) : (e.hidden = !1, e.removeAttribute("aria-hidden"), e.classList.remove("ion-page-hidden")) }, I = (e, t, n) => { void 0 !== e && (e.style.zIndex = "back" === n ? "99" : "101"), void 0 !== t && (t.style.zIndex = "100") }, k = e => e.classList.contains("ion-page") ? e : e.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs") || e }, 7585: (e, t, n) => { "use strict"; n.d(t, { a: () => i, b: () => E, c: () => v, g: () => s, i: () => C }); var r = n(3150); const s = e => o(e), i = (e, t) => ("string" == typeof e && (t = e, e = void 0), s(e).includes(t)), o = (e = window) => { if (void 0 === e) return []; e.Ionic = e.Ionic || {}; let t = e.Ionic.platforms; return null == t && (t = e.Ionic.platforms = a(e), t.forEach(t => e.document.documentElement.classList.add(`plt-${t}`))), t }, a = e => Object.keys(g).filter(t => g[t](e)), c = e => !!p(e, /iPad/i) || !(!p(e, /Macintosh/i) || !u(e)), l = e => p(e, /android|sink/i), u = e => m(e, "(any-pointer:coarse)"), h = e => d(e) || f(e), d = e => !!(e.cordova || e.phonegap || e.PhoneGap), f = e => { const t = e.Capacitor; return !(!t || !t.isNative) }, p = (e, t) => t.test(e.navigator.userAgent), m = (e, t) => e.matchMedia(t).matches, g = { ipad: c, iphone: e => p(e, /iPhone/i), ios: e => p(e, /iPhone|iPod/i) || c(e), android: l, phablet: e => { const t = e.innerWidth, n = e.innerHeight, r = Math.min(t, n), s = Math.max(t, n); return r > 390 && r < 520 && s > 620 && s < 800 }, tablet: e => { const t = e.innerWidth, n = e.innerHeight, r = Math.min(t, n), s = Math.max(t, n); return c(e) || (e => l(e) && !p(e, /mobile/i))(e) || r > 460 && r < 820 && s > 780 && s < 1400 }, cordova: d, capacitor: f, electron: e => p(e, /electron/i), pwa: e => !(!e.matchMedia("(display-mode: standalone)").matches && !e.navigator.standalone), mobile: u, mobileweb: e => u(e) && !h(e), desktop: e => !u(e), hybrid: h }; class y { constructor() { this.m = new Map } reset(e) { this.m = new Map(Object.entries(e)) } get(e, t) { const n = this.m.get(e); return void 0 !== n ? n : t } getBoolean(e, t = !1) { const n = this.m.get(e); return void 0 === n ? t : "string" == typeof n ? "true" === n : !!n } getNumber(e, t) { const n = parseFloat(this.m.get(e)); return isNaN(n) ? void 0 !== t ? t : NaN : n } set(e, t) { this.m.set(e, t) } } const v = new y, w = "ionic:", b = "ionic-persist-config"; let _; const E = e => e && (0, r.g)(e) || _, C = (e = {}) => { if ("undefined" == typeof window) return; const t = window.document, n = window, s = n.Ionic = n.Ionic || {}; o(n); const a = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (e => { try { const t = e.sessionStorage.getItem(b); return null !== t ? JSON.parse(t) : {} } catch (t) { return {} } })(n)), { persistConfig: !1 }), s.config), (e => { const t = {}; return e.location.search.slice(1).split("&").map(e => e.split("=")).map(([e, t]) => [decodeURIComponent(e), decodeURIComponent(t)]).filter(([e]) => "ionic:" === e.substr(0, w.length)).map(([e, t]) => [e.slice(w.length), t]).forEach(([e, n]) => { t[e] = n }), t })(n)), e); v.reset(a), v.getBoolean("persistConfig") && ((e, t) => { try { e.sessionStorage.setItem(b, JSON.stringify(t)) } catch (n) { return } })(n, a), s.config = v, s.mode = _ = v.get("mode", t.documentElement.getAttribute("mode") || (i(n, "ios") ? "ios" : "md")), v.set("mode", _), t.documentElement.setAttribute("mode", _), t.documentElement.classList.add(_), v.getBoolean("_testing") && v.set("animated", !1); const c = e => e.tagName && e.tagName.startsWith("ION-"), l = e => ["ios", "md"].includes(e); (0, r.s)(e => { for (; e;) { const t = e.mode || e.getAttribute("mode"); if (t) { if (l(t)) return t; c(e) && console.warn('Invalid ionic mode: "' + t + '", expected: "ios" or "md"') } e = e.parentElement } return _ }) } }, 9554: (e, t, n) => { "use strict"; n.r(t), n.d(t, { iosTransitionAnimation: () => h, shadow: () => o }); var r = n(4086), s = n(4001); n(3150); const i = e => document.querySelector(`${e}.ion-cloned-element`), o = e => e.shadowRoot || e, a = e => { const t = "ION-TABS" === e.tagName ? e : e.querySelector("ion-tabs"), n = "ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large"; if (null != t) { const e = t.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)"); return null != e ? e.querySelector(n) : null } return e.querySelector(n) }, c = (e, t) => { const n = "ION-TABS" === e.tagName ? e : e.querySelector("ion-tabs"); let r = []; if (null != n) { const e = n.querySelector("ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)"); null != e && (r = e.querySelectorAll("ion-buttons")) } else r = e.querySelectorAll("ion-buttons"); for (const s of r) { const e = s.closest("ion-header"), n = e && !e.classList.contains("header-collapse-condense-inactive"), r = s.querySelector("ion-back-button"), i = s.classList.contains("buttons-collapse"), o = "start" === s.slot || "" === s.slot; if (null !== r && o && (i && n && t || !i)) return r } return null }, l = (e, t, n, s, a, c) => { const l = t ? `calc(100% - ${c.right + 4}px)` : c.left - 4 + "px", u = t ? "7px" : "-7px", h = t ? "-4px" : "4px", d = t ? "-4px" : "4px", f = t ? "right" : "left", p = t ? "left" : "right", m = n ? [{ offset: 0, opacity: 1, transform: `translate3d(${h}, ${c.top - 46}px, 0) scale(1)` }, { offset: .6, opacity: 0 }, { offset: 1, opacity: 0, transform: `translate3d(${u}, ${a.top - 40}px, 0) scale(2.1)` }] : [{ offset: 0, opacity: 0, transform: `translate3d(${u}, ${a.top - 40}px, 0) scale(2.1)` }, { offset: 1, opacity: 1, transform: `translate3d(${h}, ${c.top - 46}px, 0) scale(1)` }], g = n ? [{ offset: 0, opacity: 1, transform: `translate3d(${d}, ${c.top - 46}px, 0) scale(1)` }, { offset: .2, opacity: 0, transform: `translate3d(${d}, ${c.top - 41}px, 0) scale(0.6)` }, { offset: 1, opacity: 0, transform: `translate3d(${d}, ${c.top - 41}px, 0) scale(0.6)` }] : [{ offset: 0, opacity: 0, transform: `translate3d(${d}, ${c.top - 41}px, 0) scale(0.6)` }, { offset: 1, opacity: 1, transform: `translate3d(${d}, ${c.top - 46}px, 0) scale(1)` }], y = (0, r.c)(), v = (0, r.c)(), w = i("ion-back-button"), b = o(w).querySelector(".button-text"), _ = o(w).querySelector("ion-icon"); w.text = s.text, w.mode = s.mode, w.icon = s.icon, w.color = s.color, w.disabled = s.disabled, w.style.setProperty("display", "block"), w.style.setProperty("position", "fixed"), v.addElement(_), y.addElement(b), y.beforeStyles({ "transform-origin": `${f} center` }).beforeAddWrite(() => { s.style.setProperty("display", "none"), w.style.setProperty(f, l) }).afterAddWrite(() => { s.style.setProperty("display", ""), w.style.setProperty("display", "none"), w.style.removeProperty(f) }).keyframes(m), v.beforeStyles({ "transform-origin": `${p} center` }).keyframes(g), e.addAnimation([y, v]) }, u = (e, t, n, s, o, a) => { const c = t ? `calc(100% - ${o.right}px)` : `${o.left}px`, l = t ? "-18px" : "18px", u = t ? "right" : "left", h = n ? [{ offset: 0, opacity: 0, transform: `translate3d(${l}, ${a.top - 4}px, 0) scale(0.49)` }, { offset: .1, opacity: 0 }, { offset: 1, opacity: 1, transform: `translate3d(0, ${o.top - 2}px, 0) scale(1)` }] : [{ offset: 0, opacity: .99, transform: `translate3d(0, ${o.top - 2}px, 0) scale(1)` }, { offset: .6, opacity: 0 }, { offset: 1, opacity: 0, transform: `translate3d(${l}, ${a.top - 4}px, 0) scale(0.5)` }], d = i("ion-title"), f = (0, r.c)(); d.innerText = s.innerText, d.size = s.size, d.color = s.color, f.addElement(d), f.beforeStyles({ "transform-origin": `${u} center`, height: "46px", display: "", position: "relative", [u]: c }).beforeAddWrite(() => { s.style.setProperty("display", "none") }).afterAddWrite(() => { s.style.setProperty("display", ""), d.style.setProperty("display", "none") }).keyframes(h), e.addAnimation(f) }, h = (e, t) => { try { const n = "cubic-bezier(0.32,0.72,0,1)", i = "opacity", h = "transform", d = "0%", f = .8, p = "rtl" === e.ownerDocument.dir, m = p ? "-99.5%" : "99.5%", g = p ? "33%" : "-33%", y = t.enteringEl, v = t.leavingEl, w = "back" === t.direction, b = y.querySelector(":scope > ion-content"), _ = y.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *"), E = y.querySelectorAll(":scope > ion-header > ion-toolbar"), C = (0, r.c)(), S = (0, r.c)(); if (C.addElement(y).duration(t.duration || 540).easing(t.easing || n).fill("both").beforeRemoveClass("ion-page-invisible"), v && e) { const t = (0, r.c)(); t.addElement(e), C.addAnimation(t) } if (b || 0 !== E.length || 0 !== _.length ? (S.addElement(b), S.addElement(_)) : S.addElement(y.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs")), C.addAnimation(S), w ? S.beforeClearStyles([i]).fromTo("transform", `translateX(${g})`, `translateX(${d})`).fromTo(i, f, 1) : S.beforeClearStyles([i]).fromTo("transform", `translateX(${m})`, `translateX(${d})`), b) { const e = o(b).querySelector(".transition-effect"); if (e) { const t = e.querySelector(".transition-cover"), n = e.querySelector(".transition-shadow"), s = (0, r.c)(), o = (0, r.c)(), a = (0, r.c)(); s.addElement(e).beforeStyles({ opacity: "1", display: "block" }).afterStyles({ opacity: "", display: "" }), o.addElement(t).beforeClearStyles([i]).fromTo(i, 0, .1), a.addElement(n).beforeClearStyles([i]).fromTo(i, .03, .7), s.addAnimation([o, a]), S.addAnimation([s]) } } const T = y.querySelector("ion-header.header-collapse-condense"), { forward: I, backward: k } = ((e, t, n, r, s) => { const i = c(r, n), o = a(s), h = a(r), d = c(s, n), f = null !== i && null !== o && !n, p = null !== h && null !== d && n; if (f) { const r = o.getBoundingClientRect(), s = i.getBoundingClientRect(); u(e, t, n, o, r, s), l(e, t, n, i, r, s) } else if (p) { const r = h.getBoundingClientRect(), s = d.getBoundingClientRect(); u(e, t, n, h, r, s), l(e, t, n, d, r, s) } return { forward: f, backward: p } })(C, p, w, y, v); if (E.forEach(e => { const t = (0, r.c)(); t.addElement(e), C.addAnimation(t); const n = (0, r.c)(); n.addElement(e.querySelector("ion-title")); const s = (0, r.c)(), a = Array.from(e.querySelectorAll("ion-buttons,[menuToggle]")), c = e.closest("ion-header"), l = c && c.classList.contains("header-collapse-condense-inactive"); let u; u = a.filter(w ? e => { const t = e.classList.contains("buttons-collapse"); return t && !l || !t } : e => !e.classList.contains("buttons-collapse")), s.addElement(u); const h = (0, r.c)(); h.addElement(e.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])")); const f = (0, r.c)(); f.addElement(o(e).querySelector(".toolbar-background")); const y = (0, r.c)(), v = e.querySelector("ion-back-button"); if (v && y.addElement(v), t.addAnimation([n, s, h, f, y]), s.fromTo(i, .01, 1), h.fromTo(i, .01, 1), w) l || n.fromTo("transform", `translateX(${g})`, `translateX(${d})`).fromTo(i, .01, 1), h.fromTo("transform", `translateX(${g})`, `translateX(${d})`), y.fromTo(i, .01, 1); else if (T || n.fromTo("transform", `translateX(${m})`, `translateX(${d})`).fromTo(i, .01, 1), h.fromTo("transform", `translateX(${m})`, `translateX(${d})`), f.beforeClearStyles([i, "transform"]), (null == c ? void 0 : c.translucent) ? f.fromTo("transform", p ? "translateX(-100%)" : "translateX(100%)", "translateX(0px)") : f.fromTo(i, .01, "var(--opacity)"), I || y.fromTo(i, .01, 1), v && !I) { const e = (0, r.c)(); e.addElement(o(v).querySelector(".button-text")).fromTo("transform", p ? "translateX(-100px)" : "translateX(100px)", "translateX(0px)"), t.addAnimation(e) } }), v) { const e = (0, r.c)(), t = v.querySelector(":scope > ion-content"), n = v.querySelectorAll(":scope > ion-header > ion-toolbar"), a = v.querySelectorAll(":scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *"); if (t || 0 !== n.length || 0 !== a.length ? (e.addElement(t), e.addElement(a)) : e.addElement(v.querySelector(":scope > .ion-page, :scope > ion-nav, :scope > ion-tabs")), C.addAnimation(e), w) { e.beforeClearStyles([i]).fromTo("transform", `translateX(${d})`, p ? "translateX(-100%)" : "translateX(100%)"); const t = (0, s.g)(v); C.afterAddWrite(() => { "normal" === C.getDirection() && t.style.setProperty("display", "none") }) } else e.fromTo("transform", `translateX(${d})`, `translateX(${g})`).fromTo(i, 1, f); if (t) { const n = o(t).querySelector(".transition-effect"); if (n) { const t = n.querySelector(".transition-cover"), s = n.querySelector(".transition-shadow"), o = (0, r.c)(), a = (0, r.c)(), c = (0, r.c)(); o.addElement(n).beforeStyles({ opacity: "1", display: "block" }).afterStyles({ opacity: "", display: "" }), a.addElement(t).beforeClearStyles([i]).fromTo(i, .1, 0), c.addElement(s).beforeClearStyles([i]).fromTo(i, .7, .03), o.addAnimation([a, c]), e.addAnimation([o]) } } n.forEach(e => { const t = (0, r.c)(); t.addElement(e); const n = (0, r.c)(); n.addElement(e.querySelector("ion-title")); const s = (0, r.c)(), a = e.querySelectorAll("ion-buttons,[menuToggle]"), c = e.closest("ion-header"), l = c && c.classList.contains("header-collapse-condense-inactive"), u = Array.from(a).filter(e => { const t = e.classList.contains("buttons-collapse"); return t && !l || !t }); s.addElement(u); const f = (0, r.c)(), m = e.querySelectorAll(":scope > *:not(ion-title):not(ion-buttons):not([menuToggle])"); m.length > 0 && f.addElement(m); const y = (0, r.c)(); y.addElement(o(e).querySelector(".toolbar-background")); const v = (0, r.c)(), b = e.querySelector("ion-back-button"); if (b && v.addElement(b), t.addAnimation([n, s, f, v, y]), C.addAnimation(t), v.fromTo(i, .99, 0), s.fromTo(i, .99, 0), f.fromTo(i, .99, 0), w) { if (l || n.fromTo("transform", `translateX(${d})`, p ? "translateX(-100%)" : "translateX(100%)").fromTo(i, .99, 0), f.fromTo("transform", `translateX(${d})`, p ? "translateX(-100%)" : "translateX(100%)"), y.beforeClearStyles([i, "transform"]), (null == c ? void 0 : c.translucent) ? y.fromTo("transform", "translateX(0px)", p ? "translateX(-100%)" : "translateX(100%)") : y.fromTo(i, "var(--opacity)", 0), b && !k) { const e = (0, r.c)(); e.addElement(o(b).querySelector(".button-text")).fromTo("transform", `translateX(${d})`, `translateX(${(p ? -124 : 124) + "px"})`), t.addAnimation(e) } } else l || n.fromTo("transform", `translateX(${d})`, `translateX(${g})`).fromTo(i, .99, 0).afterClearStyles([h, i]), f.fromTo("transform", `translateX(${d})`, `translateX(${g})`).afterClearStyles([h, i]), v.afterClearStyles([i]), n.afterClearStyles([i]), s.afterClearStyles([i]) }) } return C } catch (n) { throw n } } }, 7405: (e, t, n) => { "use strict"; n.r(t), n.d(t, { mdTransitionAnimation: () => i }); var r = n(4086), s = n(4001); n(3150); const i = (e, t) => { const n = "back" === t.direction, i = t.leavingEl, o = (0, s.g)(t.enteringEl), a = o.querySelector("ion-toolbar"), c = (0, r.c)(); if (c.addElement(o).fill("both").beforeRemoveClass("ion-page-invisible"), n ? c.duration(t.duration || 200).easing("cubic-bezier(0.47,0,0.745,0.715)") : c.duration(t.duration || 280).easing("cubic-bezier(0.36,0.66,0.04,1)").fromTo("transform", "translateY(40px)", "translateY(0px)").fromTo("opacity", .01, 1), a) { const e = (0, r.c)(); e.addElement(a), c.addAnimation(e) } if (i && n) { c.duration(t.duration || 200).easing("cubic-bezier(0.47,0,0.745,0.715)"); const e = (0, r.c)(); e.addElement((0, s.g)(i)).onFinish(t => { 1 === t && e.elements.length > 0 && e.elements[0].style.setProperty("display", "none") }).fromTo("transform", "translateY(0px)", "translateY(40px)").fromTo("opacity", 1, 0), c.addAnimation(e) } return c } }, 7053: (e, t, n) => { "use strict"; n.d(t, { B: () => P, a: () => l, b: () => u, c: () => p, d: () => S, e: () => g, f: () => I, g: () => x, h: () => a, i: () => O, l: () => h, m: () => d, p: () => f, s: () => N, t: () => m }); var r = n(7585), s = n(3087), i = n(2377); let o = 0; const a = new WeakMap, c = e => ({ create: t => y(e, t), dismiss: (t, n, r) => _(document, t, n, e, r), getTop: async () => E(document, e) }), l = c("ion-alert"), u = c("ion-action-sheet"), h = c("ion-loading"), d = c("ion-modal"), f = c("ion-picker"), p = c("ion-popover"), m = c("ion-toast"), g = e => { "undefined" != typeof document && b(document); const t = o++; e.overlayIndex = t, e.hasAttribute("id") || (e.id = `ion-overlay-${t}`) }, y = (e, t) => "undefined" != typeof customElements ? customElements.whenDefined(e).then(() => { const n = document.createElement(e); return n.classList.add("overlay-hidden"), Object.assign(n, t), k(document).appendChild(n), new Promise(e => (0, i.c)(n, e)) }) : Promise.resolve(), v = '[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])', w = "input:not([type=hidden]), textarea, button, select", b = e => { 0 === o && (o = 1, e.addEventListener("focus", t => ((e, t) => { const n = E(t), r = e.target; if (n && r) if (n === r) n.lastFocus = void 0; else { const e = (0, i.g)(n); if (!e.contains(r)) return; const s = e.querySelector(".ion-overlay-wrapper"); if (!s) return; if (s.contains(r)) n.lastFocus = r; else { const e = n.lastFocus; ((e, t) => { let n = e.querySelector(v); const r = n && n.shadowRoot; r && (n = r.querySelector(w) || n), n ? n.focus() : t.focus() })(s, n), e === t.activeElement && ((e, t) => { const n = Array.from(e.querySelectorAll(v)); let r = n.length > 0 ? n[n.length - 1] : null; const s = r && r.shadowRoot; s && (r = s.querySelector(w) || r), r ? r.focus() : t.focus() })(s, n), n.lastFocus = t.activeElement } } })(t, e), !0), e.addEventListener("ionBackButton", t => { const n = E(e); n && n.backdropDismiss && t.detail.register(s.OVERLAY_BACK_BUTTON_PRIORITY, () => n.dismiss(void 0, P)) }), e.addEventListener("keyup", t => { if ("Escape" === t.key) { const t = E(e); t && t.backdropDismiss && t.dismiss(void 0, P) } })) }, _ = (e, t, n, r, s) => { const i = E(e, r, s); return i ? i.dismiss(t, n) : Promise.reject("overlay does not exist") }, E = (e, t, n) => { const r = ((e, t) => (void 0 === t && (t = "ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast"), Array.from(e.querySelectorAll(t)).filter(e => e.overlayIndex > 0)))(e, t); return void 0 === n ? r[r.length - 1] : r.find(e => e.id === n) }, C = (e = !1) => { const t = k(document).querySelector("ion-router-outlet, ion-nav, #ion-view-container-root"); t && (e ? t.setAttribute("aria-hidden", "true") : t.removeAttribute("aria-hidden")) }, S = async (e, t, n, s, i) => { if (e.presented) return; C(!0), e.presented = !0, e.willPresent.emit(); const o = (0, r.b)(e), a = e.enterAnimation ? e.enterAnimation : r.c.get(t, "ios" === o ? n : s); await A(e, a, e.el, i) && e.didPresent.emit(), "ION-TOAST" !== e.el.tagName && T(e.el), e.keyboardClose && e.el.focus() }, T = async e => { let t = document.activeElement; if (!t) return; const n = t && t.shadowRoot; n && (t = n.querySelector(w) || t), await e.onDidDismiss(), t.focus() }, I = async (e, t, n, s, i, o, c) => { if (!e.presented) return !1; C(!1), e.presented = !1; try { e.el.style.setProperty("pointer-events", "none"), e.willDismiss.emit({ data: t, role: n }); const l = (0, r.b)(e), u = e.leaveAnimation ? e.leaveAnimation : r.c.get(s, "ios" === l ? i : o); "gesture" !== n && await A(e, u, e.el, c), e.didDismiss.emit({ data: t, role: n }), a.delete(e) } catch (l) { console.error(l) } return e.el.remove(), !0 }, k = e => e.querySelector("ion-app") || e.body, A = async (e, t, n, s) => { n.classList.remove("overlay-hidden"); const i = t(n.shadowRoot || e.el, s); e.animated && r.c.getBoolean("animated", !0) || i.duration(0), e.keyboardClose && i.beforeAddWrite(() => { const e = n.ownerDocument.activeElement; e && e.matches("input, ion-input, ion-textarea") && e.blur() }); const o = a.get(e) || []; return a.set(e, [...o, i]), await i.play(), !0 }, x = (e, t) => { let n; const r = new Promise(e => n = e); return D(e, t, e => { n(e.detail) }), r }, D = (e, t, n) => { const r = s => { (0, i.b)(e, t, r), n(s) }; (0, i.a)(e, t, r) }, O = e => "cancel" === e || e === P, R = e => e(), N = (e, t) => { if ("function" == typeof e) return r.c.get("_zoneGate", R)(() => { try { return e(t) } catch (n) { console.error(n) } }) }, P = "backdrop" }, 1628: (e, t, n) => { "use strict"; n.d(t, { K: () => a }); var r = n(2430), s = n.n(r); const i = { SecureStorage: "ionicSecureStorage", IndexedDB: s().INDEXEDDB, LocalStorage: s().LOCALSTORAGE }, o = { name: "_ionicstorage", storeName: "_ionickv", dbKey: "_ionickey", driverOrder: [i.SecureStorage, i.IndexedDB, i.LocalStorage] }; class a { constructor(e = o) { this._db = null, this._secureStorageDriver = null; const t = Object.assign({}, o, e || {}); this._config = t } async create() { const e = s().createInstance(this._config); return this._db = e, await e.setDriver(this._config.driverOrder || []), this } async defineDriver(e) { return e._driver === i.SecureStorage && (this._secureStorageDriver = e), s().defineDriver(e) } get driver() { var e; return (null === (e = this._db) || void 0 === e ? void 0 : e.driver()) || null } assertDb() { if (!this._db) throw new Error("Database not created. Must call create() first"); return this._db } get(e) { return this.assertDb().getItem(e) } set(e, t) { return this.assertDb().setItem(e, t) } remove(e) { return this.assertDb().removeItem(e) } clear() { return this.assertDb().clear() } length() { return this.assertDb().length() } keys() { return this.assertDb().keys() } forEach(e) { return this.assertDb().iterate(e) } setEncryptionKey(e) { var t; if (!this._secureStorageDriver) throw new Error("@ionic-enterprise/secure-storage not installed. Encryption support not available"); null === (t = this._secureStorageDriver) || void 0 === t || t.setEncryptionKey(e) } } }, 2329: (e, t, n) => { "use strict"; n.d(t, { Mq: () => r.getApp, C6: () => r.getApps }); var r = n(279); (0, r.registerVersion)("firebase", "9.6.9", "app") }, 7841: (e, t, n) => { "use strict"; n.d(t, { Z: () => r.Z }); var r = n(156); r.Z.registerVersion("firebase", "9.6.9", "app-compat") }, 9743: (e, t, n) => { "use strict"; n.r(t); var r = n(156), s = n(3854), i = n(279), o = n(4762), a = n(9306), c = n(8604); const l = function () { return { "admin-restricted-operation": "This operation is restricted to administrators only.", "argument-error": "", "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.", "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.", "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.", "code-expired": "The SMS code has expired. Please re-send the verification code to try again.", "cordova-not-ready": "Cordova framework is not ready.", "cors-unsupported": "This browser is not supported.", "credential-already-in-use": "This credential is already associated with a different user account.", "custom-token-mismatch": "The custom token corresponds to a different audience.", "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.", "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.", "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.", "email-change-needs-verification": "Multi-factor users must always have a verified email.", "email-already-in-use": "The email address is already in use by another account.", "emulator-config-failed": 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.', "expired-action-code": "The action code has expired.", "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.", "internal-error": "An internal AuthError has occurred.", "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.", "invalid-app-id": "The mobile app identifier is not registed for the current project.", "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.", "invalid-auth-event": "An internal AuthError has occurred.", "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.", "invalid-continue-uri": "The continue URL provided in the request is invalid.", "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.", "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.", "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.", "invalid-email": "The email address is badly formatted.", "invalid-emulator-scheme": "Emulator URL must start with a valid scheme (http:// or https://).", "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.", "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.", "invalid-credential": "The supplied auth credential is malformed or has expired.", "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.", "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.", "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.", "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.", "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.", "wrong-password": "The password is invalid or the user does not have a password.", "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.", "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].", "invalid-provider-id": "The specified provider ID is invalid.", "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.", "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.", "invalid-tenant-id": "The Auth instance's tenant ID is invalid.", "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.", "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.", "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.", "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.", "missing-continue-uri": "A continue URL must be provided in the request.", "missing-iframe-start": "An internal AuthError has occurred.", "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.", "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.", "missing-multi-factor-info": "No second factor identifier is provided.", "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.", "missing-phone-number": "To send verification codes, provide a phone number for the recipient.", "missing-verification-id": "The phone auth credential was created with an empty verification ID.", "app-deleted": "This instance of FirebaseApp has been deleted.", "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.", "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.", "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.", "network-request-failed": "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.", "no-auth-event": "An internal AuthError has occurred.", "no-such-provider": "User was not linked to an account with the given provider.", "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.", "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.", "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.', "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.", "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.", "provider-already-linked": "User can only be linked to one identity for the given provider.", "quota-exceeded": "The project's quota for this operation has been exceeded.", "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.", "redirect-operation-pending": "A redirect sign-in operation is already pending.", "rejected-credential": "The request contains malformed or mismatching credentials.", "second-factor-already-in-use": "The second factor is already enrolled on this account.", "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.", "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID", timeout: "The operation has timed out.", "user-token-expired": "The user's credential is no longer valid. The user must sign in again.", "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.", "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.", "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.", "unsupported-persistence-type": "The current environment does not support the specified persistence type.", "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.", "unverified-email": "The operation requires a verified email.", "user-cancelled": "The user did not grant your application the permissions it requested.", "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.", "user-disabled": "The user account has been disabled by an administrator.", "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.", "user-signed-out": "", "weak-password": "The password must be 6 characters long or more.", "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled.", "already-initialized": "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance." } }, u = new s.LL("auth", "Firebase", { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." }), h = new a.Yd("@firebase/auth"); function d(e, ...t) { h.logLevel <= a.in.ERROR && h.error(`Auth (${i.SDK_VERSION}): ${e}`, ...t) } function f(e, ...t) { throw y(e, ...t) } function p(e, ...t) { return y(e, ...t) } function m(e, t, n) { const r = Object.assign(Object.assign({}, { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." }), { [t]: n }); return new s.LL("auth", "Firebase", r).create(t, { appName: e.name }) } function g(e, t, n) { if (!(t instanceof n)) throw n.name !== t.constructor.name && f(e, "argument-error"), m(e, "argument-error", `Type of ${t.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`) } function y(e, ...t) { if ("string" != typeof e) { const n = t[0], r = [...t.slice(1)]; return r[0] && (r[0].appName = e.name), e._errorFactory.create(n, ...r) } return u.create(e, ...t) } function v(e, t, ...n) { if (!e) throw y(t, ...n) } function w(e) { const t = "INTERNAL ASSERTION FAILED: " + e; throw d(t), new Error(t) } function b(e, t) { e || w(t) } const _ = new Map; function E(e) { b(e instanceof Function, "Expected a class definition"); let t = _.get(e); return t ? (b(t instanceof e, "Instance stored in cache mismatched with class"), t) : (t = new e, _.set(e, t), t) } function C() { var e; return "undefined" != typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.href) || "" } function S() { return "http:" === T() || "https:" === T() } function T() { var e; return "undefined" != typeof self && (null === (e = self.location) || void 0 === e ? void 0 : e.protocol) || null } class I { constructor(e, t) { this.shortDelay = e, this.longDelay = t, b(t > e, "Short delay should be less than long delay!"), this.isMobile = (0, s.uI)() || (0, s.b$)() } get() { return "undefined" != typeof navigator && navigator && "onLine" in navigator && "boolean" == typeof navigator.onLine && (S() || (0, s.ru)() || "connection" in navigator) && !navigator.onLine ? Math.min(5e3, this.shortDelay) : this.isMobile ? this.longDelay : this.shortDelay } } function k(e, t) { b(e.emulator, "Emulator should always be set here"); const { url: n } = e.emulator; return t ? `${n}${t.startsWith("/") ? t.slice(1) : t}` : n } class A { static initialize(e, t, n) { this.fetchImpl = e, t && (this.headersImpl = t), n && (this.responseImpl = n) } static fetch() { return this.fetchImpl ? this.fetchImpl : "undefined" != typeof self && "fetch" in self ? self.fetch : void w("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static headers() { return this.headersImpl ? this.headersImpl : "undefined" != typeof self && "Headers" in self ? self.Headers : void w("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static response() { return this.responseImpl ? this.responseImpl : "undefined" != typeof self && "Response" in self ? self.Response : void w("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } } const x = { CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_PASSWORD: "wrong-password", MISSING_PASSWORD: "internal-error", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_REQ_TYPE: "internal-error", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests", EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", INVALID_CODE: "invalid-verification-code", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_SESSION_INFO: "missing-verification-id", SESSION_EXPIRED: "code-expired", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", ADMIN_ONLY_OPERATION: "admin-restricted-operation", INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session", MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found", MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info", MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session", SECOND_FACTOR_EXISTS: "second-factor-already-in-use", SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded", BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error" }, D = new I(3e4, 6e4); function O(e, t) { return e.tenantId && !t.tenantId ? Object.assign(Object.assign({}, t), { tenantId: e.tenantId }) : t } async function R(e, t, n, r, i = {}) { return N(e, i, async () => { let i = {}, o = {}; r && ("GET" === t ? o = r : i = { body: JSON.stringify(r) }); const a = (0, s.xO)(Object.assign({ key: e.config.apiKey }, o)).slice(1), c = await e._getAdditionalHeaders(); return c["Content-Type"] = "application/json", e.languageCode && (c["X-Firebase-Locale"] = e.languageCode), A.fetch()(F(e, e.config.apiHost, n, a), Object.assign({ method: t, headers: c, referrerPolicy: "no-referrer" }, i)) }) } async function N(e, t, n) { e._canInitEmulator = !1; const r = Object.assign(Object.assign({}, x), t); try { const t = new L(e), s = await Promise.race([n(), t.promise]); t.clearNetworkTimeout(); const i = await s.json(); if ("needConfirmation" in i) throw M(e, "account-exists-with-different-credential", i); if (s.ok && !("errorMessage" in i)) return i; { const t = s.ok ? i.errorMessage : i.error.message, [n, o] = t.split(" : "); if ("FEDERATED_USER_ID_ALREADY_LINKED" === n) throw M(e, "credential-already-in-use", i); if ("EMAIL_EXISTS" === n) throw M(e, "email-already-in-use", i); const a = r[n] || n.toLowerCase().replace(/[_\s]+/g, "-"); if (o) throw m(e, a, o); f(e, a) } } catch (i) { if (i instanceof s.ZR) throw i; f(e, "network-request-failed") } } async function P(e, t, n, r, s = {}) { const i = await R(e, t, n, r, s); return "mfaPendingCredential" in i && f(e, "multi-factor-auth-required", { _serverResponse: i }), i } function F(e, t, n, r) { const s = `${t}${n}?${r}`; return e.config.emulator ? k(e.config, s) : `${e.config.apiScheme}://${s}` } class L { constructor(e) { this.auth = e, this.timer = null, this.promise = new Promise((e, t) => { this.timer = setTimeout(() => t(p(this.auth, "network-request-failed")), D.get()) }) } clearNetworkTimeout() { clearTimeout(this.timer) } } function M(e, t, n) { const r = { appName: e.name }; n.email && (r.email = n.email), n.phoneNumber && (r.phoneNumber = n.phoneNumber); const s = p(e, t, r); return s.customData._tokenResponse = n, s } function $(e) { if (e) try { const t = new Date(Number(e)); if (!isNaN(t.getTime())) return t.toUTCString() } catch (t) { } } function B(e) { return 1e3 * Number(e) } function V(e) { const [t, n, r] = e.split("."); if (void 0 === t || void 0 === n || void 0 === r) return d("JWT malformed, contained fewer than 3 sections"), null; try { const e = (0, s.tV)(n); return e ? JSON.parse(e) : (d("Failed to decode base64 JWT payload"), null) } catch (i) { return d("Caught error parsing JWT payload as JSON", i), null } } async function U(e, t, n = !1) { if (n) return t; try { return await t } catch (r) { throw r instanceof s.ZR && function ({ code: e }) { return "auth/user-disabled" === e || "auth/user-token-expired" === e }(r) && e.auth.currentUser === e && await e.auth.signOut(), r } } class j { constructor(e) { this.user = e, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4 } _start() { this.isRunning || (this.isRunning = !0, this.schedule()) } _stop() { this.isRunning && (this.isRunning = !1, null !== this.timerId && clearTimeout(this.timerId)) } getInterval(e) { var t; if (e) { const e = this.errorBackoff; return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), e } { this.errorBackoff = 3e4; const e = (null !== (t = this.user.stsTokenManager.expirationTime) && void 0 !== t ? t : 0) - Date.now() - 3e5; return Math.max(0, e) } } schedule(e = !1) { if (!this.isRunning) return; const t = this.getInterval(e); this.timerId = setTimeout(async () => { await this.iteration() }, t) } async iteration() { try { await this.user.getIdToken(!0) } catch (e) { return void ("auth/network-request-failed" === e.code && this.schedule(!0)) } this.schedule() } } class q { constructor(e, t) { this.createdAt = e, this.lastLoginAt = t, this._initializeTime() } _initializeTime() { this.lastSignInTime = $(this.lastLoginAt), this.creationTime = $(this.createdAt) } _copy(e) { this.createdAt = e.createdAt, this.lastLoginAt = e.lastLoginAt, this._initializeTime() } toJSON() { return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt } } } async function z(e) { var t; const n = e.auth, r = await e.getIdToken(), s = await U(e, async function (e, t) { return R(e, "POST", "/v1/accounts:lookup", t) }(n, { idToken: r })); v(null == s ? void 0 : s.users.length, n, "internal-error"); const i = s.users[0]; e._notifyReloadListener(i); const a = (null === (t = i.providerUserInfo) || void 0 === t ? void 0 : t.length) ? i.providerUserInfo.map(e => { var { providerId: t } = e, n = (0, o._T)(e, ["providerId"]); return { providerId: t, uid: n.rawId || "", displayName: n.displayName || null, email: n.email || null, phoneNumber: n.phoneNumber || null, photoURL: n.photoUrl || null } }) : [], c = (l = a, [...e.providerData.filter(e => !l.some(t => t.providerId === e.providerId)), ...l]); var l; const u = !!e.isAnonymous && !(e.email && i.passwordHash || (null == c ? void 0 : c.length)), h = { uid: i.localId, displayName: i.displayName || null, photoURL: i.photoUrl || null, email: i.email || null, emailVerified: i.emailVerified || !1, phoneNumber: i.phoneNumber || null, tenantId: i.tenantId || null, providerData: c, metadata: new q(i.createdAt, i.lastLoginAt), isAnonymous: u }; Object.assign(e, h) } class H { constructor() { this.refreshToken = null, this.accessToken = null, this.expirationTime = null } get isExpired() { return !this.expirationTime || Date.now() > this.expirationTime - 3e4 } updateFromServerResponse(e) { v(e.idToken, "internal-error"), v(void 0 !== e.idToken, "internal-error"), v(void 0 !== e.refreshToken, "internal-error"); const t = "expiresIn" in e && void 0 !== e.expiresIn ? Number(e.expiresIn) : function (e) { const t = V(e); return v(t, "internal-error"), v(void 0 !== t.exp, "internal-error"), v(void 0 !== t.iat, "internal-error"), Number(t.exp) - Number(t.iat) }(e.idToken); this.updateTokensAndExpiration(e.idToken, e.refreshToken, t) } async getToken(e, t = !1) { return v(!this.accessToken || this.refreshToken, e, "user-token-expired"), t || !this.accessToken || this.isExpired ? this.refreshToken ? (await this.refresh(e, this.refreshToken), this.accessToken) : null : this.accessToken } clearRefreshToken() { this.refreshToken = null } async refresh(e, t) { const { accessToken: n, refreshToken: r, expiresIn: i } = await async function (e, t) { const n = await N(e, {}, async () => { const n = (0, s.xO)({ grant_type: "refresh_token", refresh_token: t }).slice(1), { tokenApiHost: r, apiKey: i } = e.config, o = F(e, r, "/v1/token", `key=${i}`), a = await e._getAdditionalHeaders(); return a["Content-Type"] = "application/x-www-form-urlencoded", A.fetch()(o, { method: "POST", headers: a, body: n }) }); return { accessToken: n.access_token, expiresIn: n.expires_in, refreshToken: n.refresh_token } }(e, t); this.updateTokensAndExpiration(n, r, Number(i)) } updateTokensAndExpiration(e, t, n) { this.refreshToken = t || null, this.accessToken = e || null, this.expirationTime = Date.now() + 1e3 * n } static fromJSON(e, t) { const { refreshToken: n, accessToken: r, expirationTime: s } = t, i = new H; return n && (v("string" == typeof n, "internal-error", { appName: e }), i.refreshToken = n), r && (v("string" == typeof r, "internal-error", { appName: e }), i.accessToken = r), s && (v("number" == typeof s, "internal-error", { appName: e }), i.expirationTime = s), i } toJSON() { return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime } } _assign(e) { this.accessToken = e.accessToken, this.refreshToken = e.refreshToken, this.expirationTime = e.expirationTime } _clone() { return Object.assign(new H, this.toJSON()) } _performRefresh() { return w("not implemented") } } function G(e, t) { v("string" == typeof e || void 0 === e, "internal-error", { appName: t }) } class W { constructor(e) { var { uid: t, auth: n, stsTokenManager: r } = e, s = (0, o._T)(e, ["uid", "auth", "stsTokenManager"]); this.providerId = "firebase", this.proactiveRefresh = new j(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = t, this.auth = n, this.stsTokenManager = r, this.accessToken = r.accessToken, this.displayName = s.displayName || null, this.email = s.email || null, this.emailVerified = s.emailVerified || !1, this.phoneNumber = s.phoneNumber || null, this.photoURL = s.photoURL || null, this.isAnonymous = s.isAnonymous || !1, this.tenantId = s.tenantId || null, this.providerData = s.providerData ? [...s.providerData] : [], this.metadata = new q(s.createdAt || void 0, s.lastLoginAt || void 0) } async getIdToken(e) { const t = await U(this, this.stsTokenManager.getToken(this.auth, e)); return v(t, this.auth, "internal-error"), this.accessToken !== t && (this.accessToken = t, await this.auth._persistUserIfCurrent(this), this.auth._notifyListenersIfCurrent(this)), t } getIdTokenResult(e) { return async function (e, t = !1) { const n = (0, s.m9)(e), r = await n.getIdToken(t), i = V(r); v(i && i.exp && i.auth_time && i.iat, n.auth, "internal-error"); const o = "object" == typeof i.firebase ? i.firebase : void 0, a = null == o ? void 0 : o.sign_in_provider; return { claims: i, token: r, authTime: $(B(i.auth_time)), issuedAtTime: $(B(i.iat)), expirationTime: $(B(i.exp)), signInProvider: a || null, signInSecondFactor: (null == o ? void 0 : o.sign_in_second_factor) || null } }(this, e) } reload() { return async function (e) { const t = (0, s.m9)(e); await z(t), await t.auth._persistUserIfCurrent(t), t.auth._notifyListenersIfCurrent(t) }(this) } _assign(e) { this !== e && (v(this.uid === e.uid, this.auth, "internal-error"), this.displayName = e.displayName, this.photoURL = e.photoURL, this.email = e.email, this.emailVerified = e.emailVerified, this.phoneNumber = e.phoneNumber, this.isAnonymous = e.isAnonymous, this.tenantId = e.tenantId, this.providerData = e.providerData.map(e => Object.assign({}, e)), this.metadata._copy(e.metadata), this.stsTokenManager._assign(e.stsTokenManager)) } _clone(e) { return new W(Object.assign(Object.assign({}, this), { auth: e, stsTokenManager: this.stsTokenManager._clone() })) } _onReload(e) { v(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = e, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null) } _notifyReloadListener(e) { this.reloadListener ? this.reloadListener(e) : this.reloadUserInfo = e } _startProactiveRefresh() { this.proactiveRefresh._start() } _stopProactiveRefresh() { this.proactiveRefresh._stop() } async _updateTokensIfNecessary(e, t = !1) { let n = !1; e.idToken && e.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(e), n = !0), t && await z(this), await this.auth._persistUserIfCurrent(this), n && this.auth._notifyListenersIfCurrent(this) } async delete() { const e = await this.getIdToken(); return await U(this, async function (e, t) { return R(e, "POST", "/v1/accounts:delete", t) }(this.auth, { idToken: e })), this.stsTokenManager.clearRefreshToken(), this.auth.signOut() } toJSON() { return Object.assign(Object.assign({ uid: this.uid, email: this.email || void 0, emailVerified: this.emailVerified, displayName: this.displayName || void 0, isAnonymous: this.isAnonymous, photoURL: this.photoURL || void 0, phoneNumber: this.phoneNumber || void 0, tenantId: this.tenantId || void 0, providerData: this.providerData.map(e => Object.assign({}, e)), stsTokenManager: this.stsTokenManager.toJSON(), _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { apiKey: this.auth.config.apiKey, appName: this.auth.name }) } get refreshToken() { return this.stsTokenManager.refreshToken || "" } static _fromJSON(e, t) { var n, r, s, i, o, a, c, l; const u = null !== (n = t.displayName) && void 0 !== n ? n : void 0, h = null !== (r = t.email) && void 0 !== r ? r : void 0, d = null !== (s = t.phoneNumber) && void 0 !== s ? s : void 0, f = null !== (i = t.photoURL) && void 0 !== i ? i : void 0, p = null !== (o = t.tenantId) && void 0 !== o ? o : void 0, m = null !== (a = t._redirectEventId) && void 0 !== a ? a : void 0, g = null !== (c = t.createdAt) && void 0 !== c ? c : void 0, y = null !== (l = t.lastLoginAt) && void 0 !== l ? l : void 0, { uid: w, emailVerified: b, isAnonymous: _, providerData: E, stsTokenManager: C } = t; v(w && C, e, "internal-error"); const S = H.fromJSON(this.name, C); v("string" == typeof w, e, "internal-error"), G(u, e.name), G(h, e.name), v("boolean" == typeof b, e, "internal-error"), v("boolean" == typeof _, e, "internal-error"), G(d, e.name), G(f, e.name), G(p, e.name), G(m, e.name), G(g, e.name), G(y, e.name); const T = new W({ uid: w, auth: e, email: h, emailVerified: b, displayName: u, isAnonymous: _, photoURL: f, phoneNumber: d, tenantId: p, stsTokenManager: S, createdAt: g, lastLoginAt: y }); return E && Array.isArray(E) && (T.providerData = E.map(e => Object.assign({}, e))), m && (T._redirectEventId = m), T } static async _fromIdTokenResponse(e, t, n = !1) { const r = new H; r.updateFromServerResponse(t); const s = new W({ uid: t.localId, auth: e, stsTokenManager: r, isAnonymous: n }); return await z(s), s } } const Y = (() => { class e { constructor() { this.type = "NONE", this.storage = {} } async _isAvailable() { return !0 } async _set(e, t) { this.storage[e] = t } async _get(e) { const t = this.storage[e]; return void 0 === t ? null : t } async _remove(e) { delete this.storage[e] } _addListener(e, t) { } _removeListener(e, t) { } } return e.type = "NONE", e })(); function K(e, t, n) { return `firebase:${e}:${t}:${n}` } class X { constructor(e, t, n) { this.persistence = e, this.auth = t, this.userKey = n; const { config: r, name: s } = this.auth; this.fullUserKey = K(this.userKey, r.apiKey, s), this.fullPersistenceKey = K("persistence", r.apiKey, s), this.boundEventHandler = t._onStorageEvent.bind(t), this.persistence._addListener(this.fullUserKey, this.boundEventHandler) } setCurrentUser(e) { return this.persistence._set(this.fullUserKey, e.toJSON()) } async getCurrentUser() { const e = await this.persistence._get(this.fullUserKey); return e ? W._fromJSON(this.auth, e) : null } removeCurrentUser() { return this.persistence._remove(this.fullUserKey) } savePersistenceForRedirect() { return this.persistence._set(this.fullPersistenceKey, this.persistence.type) } async setPersistence(e) { if (this.persistence === e) return; const t = await this.getCurrentUser(); return await this.removeCurrentUser(), this.persistence = e, t ? this.setCurrentUser(t) : void 0 } delete() { this.persistence._removeListener(this.fullUserKey, this.boundEventHandler) } static async create(e, t, n = "authUser") { if (!t.length) return new X(E(Y), e, n); const r = (await Promise.all(t.map(async e => { if (await e._isAvailable()) return e }))).filter(e => e); let s = r[0] || E(Y); const i = K(n, e.config.apiKey, e.name); let o = null; for (const l of t) try { const t = await l._get(i); if (t) { const n = W._fromJSON(e, t); l !== s && (o = n), s = l; break } } catch (c) { } const a = r.filter(e => e._shouldAllowMigration); return s._shouldAllowMigration && a.length ? (s = a[0], o && await s._set(i, o.toJSON()), await Promise.all(t.map(async e => { if (e !== s) try { await e._remove(i) } catch (c) { } })), new X(s, e, n)) : new X(s, e, n) } } function Z(e) { const t = e.toLowerCase(); if (t.includes("opera/") || t.includes("opr/") || t.includes("opios/")) return "Opera"; if (te(t)) return "IEMobile"; if (t.includes("msie") || t.includes("trident/")) return "IE"; if (t.includes("edge/")) return "Edge"; if (Q(t)) return "Firefox"; if (t.includes("silk/")) return "Silk"; if (re(t)) return "Blackberry"; if (se(t)) return "Webos"; if (J(t)) return "Safari"; if ((t.includes("chrome/") || ee(t)) && !t.includes("edge/")) return "Chrome"; if (ne(t)) return "Android"; { const t = e.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/); if (2 === (null == t ? void 0 : t.length)) return t[1] } return "Other" } function Q(e = (0, s.z$)()) { return /firefox\//i.test(e) } function J(e = (0, s.z$)()) { const t = e.toLowerCase(); return t.includes("safari/") && !t.includes("chrome/") && !t.includes("crios/") && !t.includes("android") } function ee(e = (0, s.z$)()) { return /crios\//i.test(e) } function te(e = (0, s.z$)()) { return /iemobile/i.test(e) } function ne(e = (0, s.z$)()) { return /android/i.test(e) } function re(e = (0, s.z$)()) { return /blackberry/i.test(e) } function se(e = (0, s.z$)()) { return /webos/i.test(e) } function ie(e = (0, s.z$)()) { return /iphone|ipad|ipod/i.test(e) } function oe(e = (0, s.z$)()) { return ie(e) || ne(e) || se(e) || re(e) || /windows phone/i.test(e) || te(e) } function ae(e, t = []) { let n; switch (e) { case "Browser": n = Z((0, s.z$)()); break; case "Worker": n = `${Z((0, s.z$)())}-${e}`; break; default: n = e }const r = t.length ? t.join(",") : "FirebaseCore-web"; return `${n}/JsCore/${i.SDK_VERSION}/${r}` } class ce { constructor(e, t, n) { this.app = e, this.heartbeatServiceProvider = t, this.config = n, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new ue(this), this.idTokenSubscription = new ue(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = u, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = e.name, this.clientVersion = n.sdkClientVersion } _initializeWithPersistence(e, t) { return t && (this._popupRedirectResolver = E(t)), this._initializationPromise = this.queue(async () => { var n, r; if (!this._deleted && (this.persistenceManager = await X.create(this, e), !this._deleted)) { if (null === (n = this._popupRedirectResolver) || void 0 === n ? void 0 : n._shouldInitProactively) try { await this._popupRedirectResolver._initialize(this) } catch (s) { } await this.initializeCurrentUser(t), this.lastNotifiedUid = (null === (r = this.currentUser) || void 0 === r ? void 0 : r.uid) || null, this._deleted || (this._isInitialized = !0) } }), this._initializationPromise } async _onStorageEvent() { if (this._deleted) return; const e = await this.assertedPersistence.getCurrentUser(); return this.currentUser || e ? this.currentUser && e && this.currentUser.uid === e.uid ? (this._currentUser._assign(e), void (await this.currentUser.getIdToken())) : void (await this._updateCurrentUser(e)) : void 0 } async initializeCurrentUser(e) { var t; let n = await this.assertedPersistence.getCurrentUser(); if (e && this.config.authDomain) { await this.getOrInitRedirectPersistenceManager(); const r = null === (t = this.redirectUser) || void 0 === t ? void 0 : t._redirectEventId, s = null == n ? void 0 : n._redirectEventId, i = await this.tryRedirectSignIn(e); r && r !== s || !(null == i ? void 0 : i.user) || (n = i.user) } return n ? n._redirectEventId ? (v(this._popupRedirectResolver, this, "argument-error"), await this.getOrInitRedirectPersistenceManager(), this.redirectUser && this.redirectUser._redirectEventId === n._redirectEventId ? this.directlySetCurrentUser(n) : this.reloadAndSetCurrentUserOrClear(n)) : this.reloadAndSetCurrentUserOrClear(n) : this.directlySetCurrentUser(null) } async tryRedirectSignIn(e) { let t = null; try { t = await this._popupRedirectResolver._completeRedirectFn(this, e, !0) } catch (n) { await this._setRedirectUser(null) } return t } async reloadAndSetCurrentUserOrClear(e) { try { await z(e) } catch (t) { if ("auth/network-request-failed" !== t.code) return this.directlySetCurrentUser(null) } return this.directlySetCurrentUser(e) } useDeviceLanguage() { this.languageCode = function () { if ("undefined" == typeof navigator) return null; const e = navigator; return e.languages && e.languages[0] || e.language || null }() } async _delete() { this._deleted = !0 } async updateCurrentUser(e) { const t = e ? (0, s.m9)(e) : null; return t && v(t.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"), this._updateCurrentUser(t && t._clone(this)) } async _updateCurrentUser(e) { if (!this._deleted) return e && v(this.tenantId === e.tenantId, this, "tenant-id-mismatch"), this.queue(async () => { await this.directlySetCurrentUser(e), this.notifyAuthListeners() }) } async signOut() { return (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null), this._updateCurrentUser(null) } setPersistence(e) { return this.queue(async () => { await this.assertedPersistence.setPersistence(E(e)) }) } _getPersistence() { return this.assertedPersistence.persistence.type } _updateErrorMap(e) { this._errorFactory = new s.LL("auth", "Firebase", e()) } onAuthStateChanged(e, t, n) { return this.registerStateListener(this.authStateSubscription, e, t, n) } onIdTokenChanged(e, t, n) { return this.registerStateListener(this.idTokenSubscription, e, t, n) } toJSON() { var e; return { apiKey: this.config.apiKey, authDomain: this.config.authDomain, appName: this.name, currentUser: null === (e = this._currentUser) || void 0 === e ? void 0 : e.toJSON() } } async _setRedirectUser(e, t) { const n = await this.getOrInitRedirectPersistenceManager(t); return null === e ? n.removeCurrentUser() : n.setCurrentUser(e) } async getOrInitRedirectPersistenceManager(e) { if (!this.redirectPersistenceManager) { const t = e && E(e) || this._popupRedirectResolver; v(t, this, "argument-error"), this.redirectPersistenceManager = await X.create(this, [E(t._redirectPersistence)], "redirectUser"), this.redirectUser = await this.redirectPersistenceManager.getCurrentUser() } return this.redirectPersistenceManager } async _redirectUserForId(e) { var t, n; return this._isInitialized && await this.queue(async () => { }), (null === (t = this._currentUser) || void 0 === t ? void 0 : t._redirectEventId) === e ? this._currentUser : (null === (n = this.redirectUser) || void 0 === n ? void 0 : n._redirectEventId) === e ? this.redirectUser : null } async _persistUserIfCurrent(e) { if (e === this.currentUser) return this.queue(async () => this.directlySetCurrentUser(e)) } _notifyListenersIfCurrent(e) { e === this.currentUser && this.notifyAuthListeners() } _key() { return `${this.config.authDomain}:${this.config.apiKey}:${this.name}` } _startProactiveRefresh() { this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh() } _stopProactiveRefresh() { this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh() } get _currentUser() { return this.currentUser } notifyAuthListeners() { var e, t; if (!this._isInitialized) return; this.idTokenSubscription.next(this.currentUser); const n = null !== (t = null === (e = this.currentUser) || void 0 === e ? void 0 : e.uid) && void 0 !== t ? t : null; this.lastNotifiedUid !== n && (this.lastNotifiedUid = n, this.authStateSubscription.next(this.currentUser)) } registerStateListener(e, t, n, r) { if (this._deleted) return () => { }; const s = "function" == typeof t ? t : t.next.bind(t), i = this._isInitialized ? Promise.resolve() : this._initializationPromise; return v(i, this, "internal-error"), i.then(() => s(this.currentUser)), "function" == typeof t ? e.addObserver(t, n, r) : e.addObserver(t) } async directlySetCurrentUser(e) { this.currentUser && this.currentUser !== e && (this._currentUser._stopProactiveRefresh(), e && this.isProactiveRefreshEnabled && e._startProactiveRefresh()), this.currentUser = e, e ? await this.assertedPersistence.setCurrentUser(e) : await this.assertedPersistence.removeCurrentUser() } queue(e) { return this.operations = this.operations.then(e, e), this.operations } get assertedPersistence() { return v(this.persistenceManager, this, "internal-error"), this.persistenceManager } _logFramework(e) { e && !this.frameworks.includes(e) && (this.frameworks.push(e), this.frameworks.sort(), this.clientVersion = ae(this.config.clientPlatform, this._getFrameworks())) } _getFrameworks() { return this.frameworks } async _getAdditionalHeaders() { var e; const t = { "X-Client-Version": this.clientVersion }; this.app.options.appId && (t["X-Firebase-gmpid"] = this.app.options.appId); const n = await (null === (e = this.heartbeatServiceProvider.getImmediate({ optional: !0 })) || void 0 === e ? void 0 : e.getHeartbeatsHeader()); return n && (t["X-Firebase-Client"] = n), t } } function le(e) { return (0, s.m9)(e) } class ue { constructor(e) { this.auth = e, this.observer = null, this.addObserver = (0, s.ne)(e => this.observer = e) } get next() { return v(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer) } } function he(e) { const t = e.indexOf(":"); return t < 0 ? "" : e.substr(0, t + 1) } function de(e) { if (!e) return null; const t = Number(e); return isNaN(t) ? null : t } class fe { constructor(e, t) { this.providerId = e, this.signInMethod = t } toJSON() { return w("not implemented") } _getIdTokenResponse(e) { return w("not implemented") } _linkToIdToken(e, t) { return w("not implemented") } _getReauthenticationResolver(e) { return w("not implemented") } } async function pe(e, t) { return R(e, "POST", "/v1/accounts:resetPassword", O(e, t)) } async function me(e, t) { return R(e, "POST", "/v1/accounts:update", t) } async function ge(e, t) { return R(e, "POST", "/v1/accounts:sendOobCode", O(e, t)) } class ye extends fe { constructor(e, t, n, r = null) { super("password", n), this._email = e, this._password = t, this._tenantId = r } static _fromEmailAndPassword(e, t) { return new ye(e, t, "password") } static _fromEmailAndCode(e, t, n = null) { return new ye(e, t, "emailLink", n) } toJSON() { return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId } } static fromJSON(e) { const t = "string" == typeof e ? JSON.parse(e) : e; if ((null == t ? void 0 : t.email) && (null == t ? void 0 : t.password)) { if ("password" === t.signInMethod) return this._fromEmailAndPassword(t.email, t.password); if ("emailLink" === t.signInMethod) return this._fromEmailAndCode(t.email, t.password, t.tenantId) } return null } async _getIdTokenResponse(e) { switch (this.signInMethod) { case "password": return async function (e, t) { return P(e, "POST", "/v1/accounts:signInWithPassword", O(e, t)) }(e, { returnSecureToken: !0, email: this._email, password: this._password }); case "emailLink": return async function (e, t) { return P(e, "POST", "/v1/accounts:signInWithEmailLink", O(e, t)) }(e, { email: this._email, oobCode: this._password }); default: f(e, "internal-error") } } async _linkToIdToken(e, t) { switch (this.signInMethod) { case "password": return me(e, { idToken: t, returnSecureToken: !0, email: this._email, password: this._password }); case "emailLink": return async function (e, t) { return P(e, "POST", "/v1/accounts:signInWithEmailLink", O(e, t)) }(e, { idToken: t, email: this._email, oobCode: this._password }); default: f(e, "internal-error") } } _getReauthenticationResolver(e) { return this._getIdTokenResponse(e) } } async function ve(e, t) { return P(e, "POST", "/v1/accounts:signInWithIdp", O(e, t)) } class we extends fe { constructor() { super(...arguments), this.pendingToken = null } static _fromParams(e) { const t = new we(e.providerId, e.signInMethod); return e.idToken || e.accessToken ? (e.idToken && (t.idToken = e.idToken), e.accessToken && (t.accessToken = e.accessToken), e.nonce && !e.pendingToken && (t.nonce = e.nonce), e.pendingToken && (t.pendingToken = e.pendingToken)) : e.oauthToken && e.oauthTokenSecret ? (t.accessToken = e.oauthToken, t.secret = e.oauthTokenSecret) : f("argument-error"), t } toJSON() { return { idToken: this.idToken, accessToken: this.accessToken, secret: this.secret, nonce: this.nonce, pendingToken: this.pendingToken, providerId: this.providerId, signInMethod: this.signInMethod } } static fromJSON(e) { const t = "string" == typeof e ? JSON.parse(e) : e, { providerId: n, signInMethod: r } = t, s = (0, o._T)(t, ["providerId", "signInMethod"]); if (!n || !r) return null; const i = new we(n, r); return i.idToken = s.idToken || void 0, i.accessToken = s.accessToken || void 0, i.secret = s.secret, i.nonce = s.nonce, i.pendingToken = s.pendingToken || null, i } _getIdTokenResponse(e) { return ve(e, this.buildRequest()) } _linkToIdToken(e, t) { const n = this.buildRequest(); return n.idToken = t, ve(e, n) } _getReauthenticationResolver(e) { const t = this.buildRequest(); return t.autoCreate = !1, ve(e, t) } buildRequest() { const e = { requestUri: "http://localhost", returnSecureToken: !0 }; if (this.pendingToken) e.pendingToken = this.pendingToken; else { const t = {}; this.idToken && (t.id_token = this.idToken), this.accessToken && (t.access_token = this.accessToken), this.secret && (t.oauth_token_secret = this.secret), t.providerId = this.providerId, this.nonce && !this.pendingToken && (t.nonce = this.nonce), e.postBody = (0, s.xO)(t) } return e } } const be = { USER_NOT_FOUND: "user-not-found" }; class _e extends fe { constructor(e) { super("phone", "phone"), this.params = e } static _fromVerification(e, t) { return new _e({ verificationId: e, verificationCode: t }) } static _fromTokenResponse(e, t) { return new _e({ phoneNumber: e, temporaryProof: t }) } _getIdTokenResponse(e) { return async function (e, t) { return P(e, "POST", "/v1/accounts:signInWithPhoneNumber", O(e, t)) }(e, this._makeVerificationRequest()) } _linkToIdToken(e, t) { return async function (e, t) { const n = await P(e, "POST", "/v1/accounts:signInWithPhoneNumber", O(e, t)); if (n.temporaryProof) throw M(e, "account-exists-with-different-credential", n); return n }(e, Object.assign({ idToken: t }, this._makeVerificationRequest())) } _getReauthenticationResolver(e) { return async function (e, t) { return P(e, "POST", "/v1/accounts:signInWithPhoneNumber", O(e, Object.assign(Object.assign({}, t), { operation: "REAUTH" })), be) }(e, this._makeVerificationRequest()) } _makeVerificationRequest() { const { temporaryProof: e, phoneNumber: t, verificationId: n, verificationCode: r } = this.params; return e && t ? { temporaryProof: e, phoneNumber: t } : { sessionInfo: n, code: r } } toJSON() { const e = { providerId: this.providerId }; return this.params.phoneNumber && (e.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (e.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (e.verificationCode = this.params.verificationCode), this.params.verificationId && (e.verificationId = this.params.verificationId), e } static fromJSON(e) { "string" == typeof e && (e = JSON.parse(e)); const { verificationId: t, verificationCode: n, phoneNumber: r, temporaryProof: s } = e; return n || t || r || s ? new _e({ verificationId: t, verificationCode: n, phoneNumber: r, temporaryProof: s }) : null } } class Ee { constructor(e) { var t, n, r, i, o, a; const c = (0, s.zd)((0, s.pd)(e)), l = null !== (t = c.apiKey) && void 0 !== t ? t : null, u = null !== (n = c.oobCode) && void 0 !== n ? n : null, h = function (e) { switch (e) { case "recoverEmail": return "RECOVER_EMAIL"; case "resetPassword": return "PASSWORD_RESET"; case "signIn": return "EMAIL_SIGNIN"; case "verifyEmail": return "VERIFY_EMAIL"; case "verifyAndChangeEmail": return "VERIFY_AND_CHANGE_EMAIL"; case "revertSecondFactorAddition": return "REVERT_SECOND_FACTOR_ADDITION"; default: return null } }(null !== (r = c.mode) && void 0 !== r ? r : null); v(l && u && h, "argument-error"), this.apiKey = l, this.operation = h, this.code = u, this.continueUrl = null !== (i = c.continueUrl) && void 0 !== i ? i : null, this.languageCode = null !== (o = c.languageCode) && void 0 !== o ? o : null, this.tenantId = null !== (a = c.tenantId) && void 0 !== a ? a : null } static parseLink(e) { const t = function (e) { const t = (0, s.zd)((0, s.pd)(e)).link, n = t ? (0, s.zd)((0, s.pd)(t)).deep_link_id : null, r = (0, s.zd)((0, s.pd)(e)).deep_link_id; return (r ? (0, s.zd)((0, s.pd)(r)).link : null) || r || n || t || e }(e); try { return new Ee(t) } catch (n) { return null } } } let Ce = (() => { class e { constructor() { this.providerId = e.PROVIDER_ID } static credential(e, t) { return ye._fromEmailAndPassword(e, t) } static credentialWithLink(e, t) { const n = Ee.parseLink(t); return v(n, "argument-error"), ye._fromEmailAndCode(e, n.code, n.tenantId) } } return e.PROVIDER_ID = "password", e.EMAIL_PASSWORD_SIGN_IN_METHOD = "password", e.EMAIL_LINK_SIGN_IN_METHOD = "emailLink", e })(); class Se { constructor(e) { this.providerId = e, this.defaultLanguageCode = null, this.customParameters = {} } setDefaultLanguage(e) { this.defaultLanguageCode = e } setCustomParameters(e) { return this.customParameters = e, this } getCustomParameters() { return this.customParameters } } class Te extends Se { constructor() { super(...arguments), this.scopes = [] } addScope(e) { return this.scopes.includes(e) || this.scopes.push(e), this } getScopes() { return [...this.scopes] } } class Ie extends Te { static credentialFromJSON(e) { const t = "string" == typeof e ? JSON.parse(e) : e; return v("providerId" in t && "signInMethod" in t, "argument-error"), we._fromParams(t) } credential(e) { return this._credential(Object.assign(Object.assign({}, e), { nonce: e.rawNonce })) } _credential(e) { return v(e.idToken || e.accessToken, "argument-error"), we._fromParams(Object.assign(Object.assign({}, e), { providerId: this.providerId, signInMethod: this.providerId })) } static credentialFromResult(e) { return Ie.oauthCredentialFromTaggedObject(e) } static credentialFromError(e) { return Ie.oauthCredentialFromTaggedObject(e.customData || {}) } static oauthCredentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; const { oauthIdToken: t, oauthAccessToken: n, oauthTokenSecret: r, pendingToken: s, nonce: i, providerId: o } = e; if (!(n || r || t || s)) return null; if (!o) return null; try { return new Ie(o)._credential({ idToken: t, accessToken: n, nonce: i, pendingToken: s }) } catch (a) { return null } } } let ke = (() => { class e extends Te { constructor() { super("facebook.com") } static credential(t) { return we._fromParams({ providerId: e.PROVIDER_ID, signInMethod: e.FACEBOOK_SIGN_IN_METHOD, accessToken: t }) } static credentialFromResult(t) { return e.credentialFromTaggedObject(t) } static credentialFromError(t) { return e.credentialFromTaggedObject(t.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: t }) { if (!t || !("oauthAccessToken" in t)) return null; if (!t.oauthAccessToken) return null; try { return e.credential(t.oauthAccessToken) } catch (n) { return null } } } return e.FACEBOOK_SIGN_IN_METHOD = "facebook.com", e.PROVIDER_ID = "facebook.com", e })(), Ae = (() => { class e extends Te { constructor() { super("google.com"), this.addScope("profile") } static credential(t, n) { return we._fromParams({ providerId: e.PROVIDER_ID, signInMethod: e.GOOGLE_SIGN_IN_METHOD, idToken: t, accessToken: n }) } static credentialFromResult(t) { return e.credentialFromTaggedObject(t) } static credentialFromError(t) { return e.credentialFromTaggedObject(t.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: t }) { if (!t) return null; const { oauthIdToken: n, oauthAccessToken: r } = t; if (!n && !r) return null; try { return e.credential(n, r) } catch (s) { return null } } } return e.GOOGLE_SIGN_IN_METHOD = "google.com", e.PROVIDER_ID = "google.com", e })(), xe = (() => { class e extends Te { constructor() { super("github.com") } static credential(t) { return we._fromParams({ providerId: e.PROVIDER_ID, signInMethod: e.GITHUB_SIGN_IN_METHOD, accessToken: t }) } static credentialFromResult(t) { return e.credentialFromTaggedObject(t) } static credentialFromError(t) { return e.credentialFromTaggedObject(t.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: t }) { if (!t || !("oauthAccessToken" in t)) return null; if (!t.oauthAccessToken) return null; try { return e.credential(t.oauthAccessToken) } catch (n) { return null } } } return e.GITHUB_SIGN_IN_METHOD = "github.com", e.PROVIDER_ID = "github.com", e })(); class De extends fe { constructor(e, t) { super(e, e), this.pendingToken = t } _getIdTokenResponse(e) { return ve(e, this.buildRequest()) } _linkToIdToken(e, t) { const n = this.buildRequest(); return n.idToken = t, ve(e, n) } _getReauthenticationResolver(e) { const t = this.buildRequest(); return t.autoCreate = !1, ve(e, t) } toJSON() { return { signInMethod: this.signInMethod, providerId: this.providerId, pendingToken: this.pendingToken } } static fromJSON(e) { const t = "string" == typeof e ? JSON.parse(e) : e, { providerId: n, signInMethod: r, pendingToken: s } = t; return n && r && s && n === r ? new De(n, s) : null } static _create(e, t) { return new De(e, t) } buildRequest() { return { requestUri: "http://localhost", returnSecureToken: !0, pendingToken: this.pendingToken } } } class Oe extends Se { constructor(e) { v(e.startsWith("saml."), "argument-error"), super(e) } static credentialFromResult(e) { return Oe.samlCredentialFromTaggedObject(e) } static credentialFromError(e) { return Oe.samlCredentialFromTaggedObject(e.customData || {}) } static credentialFromJSON(e) { const t = De.fromJSON(e); return v(t, "argument-error"), t } static samlCredentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; const { pendingToken: t, providerId: n } = e; if (!t || !n) return null; try { return De._create(n, t) } catch (r) { return null } } } let Re = (() => { class e extends Te { constructor() { super("twitter.com") } static credential(t, n) { return we._fromParams({ providerId: e.PROVIDER_ID, signInMethod: e.TWITTER_SIGN_IN_METHOD, oauthToken: t, oauthTokenSecret: n }) } static credentialFromResult(t) { return e.credentialFromTaggedObject(t) } static credentialFromError(t) { return e.credentialFromTaggedObject(t.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: t }) { if (!t) return null; const { oauthAccessToken: n, oauthTokenSecret: r } = t; if (!n || !r) return null; try { return e.credential(n, r) } catch (s) { return null } } } return e.TWITTER_SIGN_IN_METHOD = "twitter.com", e.PROVIDER_ID = "twitter.com", e })(); async function Ne(e, t) { return P(e, "POST", "/v1/accounts:signUp", O(e, t)) } class Pe { constructor(e) { this.user = e.user, this.providerId = e.providerId, this._tokenResponse = e._tokenResponse, this.operationType = e.operationType } static async _fromIdTokenResponse(e, t, n, r = !1) { const s = await W._fromIdTokenResponse(e, n, r), i = Fe(n); return new Pe({ user: s, providerId: i, _tokenResponse: n, operationType: t }) } static async _forOperation(e, t, n) { await e._updateTokensIfNecessary(n, !0); const r = Fe(n); return new Pe({ user: e, providerId: r, _tokenResponse: n, operationType: t }) } } function Fe(e) { return e.providerId ? e.providerId : "phoneNumber" in e ? "phone" : null } class Le extends s.ZR { constructor(e, t, n, r) { var s; super(t.code, t.message), this.operationType = n, this.user = r, Object.setPrototypeOf(this, Le.prototype), this.customData = { appName: e.name, tenantId: null !== (s = e.tenantId) && void 0 !== s ? s : void 0, _serverResponse: t.customData._serverResponse, operationType: n } } static _fromErrorAndOperation(e, t, n, r) { return new Le(e, t, n, r) } } function Me(e, t, n, r) { return ("reauthenticate" === t ? n._getReauthenticationResolver(e) : n._getIdTokenResponse(e)).catch(n => { if ("auth/multi-factor-auth-required" === n.code) throw Le._fromErrorAndOperation(e, n, t, r); throw n }) } function $e(e) { return new Set(e.map(({ providerId: e }) => e).filter(e => !!e)) } async function Be(e, t, n = !1) { const r = await U(e, t._linkToIdToken(e.auth, await e.getIdToken()), n); return Pe._forOperation(e, "link", r) } async function Ve(e, t, n) { await z(t); const r = !1 === e ? "provider-already-linked" : "no-such-provider"; v($e(t.providerData).has(n) === e, t.auth, r) } async function Ue(e, t, n = !1) { const { auth: r } = e, s = "reauthenticate"; try { const i = await U(e, Me(r, s, t, e), n); v(i.idToken, r, "internal-error"); const o = V(i.idToken); v(o, r, "internal-error"); const { sub: a } = o; return v(e.uid === a, r, "user-mismatch"), Pe._forOperation(e, s, i) } catch (i) { throw "auth/user-not-found" === (null == i ? void 0 : i.code) && f(r, "user-mismatch"), i } } async function je(e, t, n = !1) { const r = "signIn", s = await Me(e, r, t), i = await Pe._fromIdTokenResponse(e, r, s); return n || await e._updateCurrentUser(i.user), i } async function qe(e, t) { return je(le(e), t) } async function ze(e, t) { const n = (0, s.m9)(e); return await Ve(!1, n, t.providerId), Be(n, t) } async function He(e, t) { return Ue((0, s.m9)(e), t) } class Ge { constructor(e, t) { this.factorId = e, this.uid = t.mfaEnrollmentId, this.enrollmentTime = new Date(t.enrolledAt).toUTCString(), this.displayName = t.displayName } static _fromServerResponse(e, t) { return "phoneInfo" in t ? We._fromServerResponse(e, t) : f(e, "internal-error") } } class We extends Ge { constructor(e) { super("phone", e), this.phoneNumber = e.phoneInfo } static _fromServerResponse(e, t) { return new We(t) } } function Ye(e, t, n) { var r; v((null === (r = n.url) || void 0 === r ? void 0 : r.length) > 0, e, "invalid-continue-uri"), v(void 0 === n.dynamicLinkDomain || n.dynamicLinkDomain.length > 0, e, "invalid-dynamic-link-domain"), t.continueUrl = n.url, t.dynamicLinkDomain = n.dynamicLinkDomain, t.canHandleCodeInApp = n.handleCodeInApp, n.iOS && (v(n.iOS.bundleId.length > 0, e, "missing-ios-bundle-id"), t.iOSBundleId = n.iOS.bundleId), n.android && (v(n.android.packageName.length > 0, e, "missing-android-pkg-name"), t.androidInstallApp = n.android.installApp, t.androidMinimumVersionCode = n.android.minimumVersion, t.androidPackageName = n.android.packageName) } async function Ke(e, t) { const n = (0, s.m9)(e), r = await pe(n, { oobCode: t }), i = r.requestType; switch (v(i, n, "internal-error"), i) { case "EMAIL_SIGNIN": break; case "VERIFY_AND_CHANGE_EMAIL": v(r.newEmail, n, "internal-error"); break; case "REVERT_SECOND_FACTOR_ADDITION": v(r.mfaInfo, n, "internal-error"); default: v(r.email, n, "internal-error") }let o = null; return r.mfaInfo && (o = Ge._fromServerResponse(le(n), r.mfaInfo)), { data: { email: ("VERIFY_AND_CHANGE_EMAIL" === r.requestType ? r.newEmail : r.email) || null, previousEmail: ("VERIFY_AND_CHANGE_EMAIL" === r.requestType ? r.email : r.newEmail) || null, multiFactorInfo: o }, operation: i } } async function Xe(e, t, n) { const { auth: r } = e, s = { idToken: await e.getIdToken(), returnSecureToken: !0 }; t && (s.email = t), n && (s.password = n); const i = await U(e, me(r, s)); await e._updateTokensIfNecessary(i, !0) } class Ze { constructor(e, t, n = {}) { this.isNewUser = e, this.providerId = t, this.profile = n } } class Qe extends Ze { constructor(e, t, n, r) { super(e, t, n), this.username = r } } class Je extends Ze { constructor(e, t) { super(e, "facebook.com", t) } } class et extends Qe { constructor(e, t) { super(e, "github.com", t, "string" == typeof (null == t ? void 0 : t.login) ? null == t ? void 0 : t.login : null) } } class tt extends Ze { constructor(e, t) { super(e, "google.com", t) } } class nt extends Qe { constructor(e, t, n) { super(e, "twitter.com", t, n) } } function rt(e) { const { user: t, _tokenResponse: n } = e; return t.isAnonymous && !n ? { providerId: null, isNewUser: !1, profile: null } : function (e) { var t, n; if (!e) return null; const { providerId: r } = e, s = e.rawUserInfo ? JSON.parse(e.rawUserInfo) : {}, i = e.isNewUser || "identitytoolkit#SignupNewUserResponse" === e.kind; if (!r && (null == e ? void 0 : e.idToken)) { const r = null === (n = null === (t = V(e.idToken)) || void 0 === t ? void 0 : t.firebase) || void 0 === n ? void 0 : n.sign_in_provider; if (r) return new Ze(i, "anonymous" !== r && "custom" !== r ? r : null) } if (!r) return null; switch (r) { case "facebook.com": return new Je(i, s); case "github.com": return new et(i, s); case "google.com": return new tt(i, s); case "twitter.com": return new nt(i, s, e.screenName || null); case "custom": case "anonymous": return new Ze(i, null); default: return new Ze(i, r, s) } }(n) } class st { constructor(e, t) { this.type = e, this.credential = t } static _fromIdtoken(e) { return new st("enroll", e) } static _fromMfaPendingCredential(e) { return new st("signin", e) } toJSON() { return { multiFactorSession: { ["enroll" === this.type ? "idToken" : "pendingCredential"]: this.credential } } } static fromJSON(e) { var t, n; if (null == e ? void 0 : e.multiFactorSession) { if (null === (t = e.multiFactorSession) || void 0 === t ? void 0 : t.pendingCredential) return st._fromMfaPendingCredential(e.multiFactorSession.pendingCredential); if (null === (n = e.multiFactorSession) || void 0 === n ? void 0 : n.idToken) return st._fromIdtoken(e.multiFactorSession.idToken) } return null } } class it { constructor(e, t, n) { this.session = e, this.hints = t, this.signInResolver = n } static _fromError(e, t) { const n = le(e), r = t.customData._serverResponse, s = (r.mfaInfo || []).map(e => Ge._fromServerResponse(n, e)); v(r.mfaPendingCredential, n, "internal-error"); const i = st._fromMfaPendingCredential(r.mfaPendingCredential); return new it(i, s, async e => { const s = await e._process(n, i); delete r.mfaInfo, delete r.mfaPendingCredential; const o = Object.assign(Object.assign({}, r), { idToken: s.idToken, refreshToken: s.refreshToken }); switch (t.operationType) { case "signIn": const e = await Pe._fromIdTokenResponse(n, t.operationType, o); return await n._updateCurrentUser(e.user), e; case "reauthenticate": return v(t.user, n, "internal-error"), Pe._forOperation(t.user, t.operationType, o); default: f(n, "internal-error") } }) } async resolveSignIn(e) { return this.signInResolver(e) } } class ot { constructor(e) { this.user = e, this.enrolledFactors = [], e._onReload(t => { t.mfaInfo && (this.enrolledFactors = t.mfaInfo.map(t => Ge._fromServerResponse(e.auth, t))) }) } static _fromUser(e) { return new ot(e) } async getSession() { return st._fromIdtoken(await this.user.getIdToken()) } async enroll(e, t) { const n = e, r = await this.getSession(), s = await U(this.user, n._process(this.user.auth, r, t)); return await this.user._updateTokensIfNecessary(s), this.user.reload() } async unenroll(e) { const t = "string" == typeof e ? e : e.uid, n = await this.user.getIdToken(), r = await U(this.user, (s = this.user.auth, i = { idToken: n, mfaEnrollmentId: t }, R(s, "POST", "/v2/accounts/mfaEnrollment:withdraw", O(s, i)))); var s, i; this.enrolledFactors = this.enrolledFactors.filter(({ uid: e }) => e !== t), await this.user._updateTokensIfNecessary(r); try { await this.user.reload() } catch (o) { if ("auth/user-token-expired" !== o.code) throw o } } } const at = new WeakMap, ct = "__sak"; class lt { constructor(e, t) { this.storageRetriever = e, this.type = t } _isAvailable() { try { return this.storage ? (this.storage.setItem(ct, "1"), this.storage.removeItem(ct), Promise.resolve(!0)) : Promise.resolve(!1) } catch (e) { return Promise.resolve(!1) } } _set(e, t) { return this.storage.setItem(e, JSON.stringify(t)), Promise.resolve() } _get(e) { const t = this.storage.getItem(e); return Promise.resolve(t ? JSON.parse(t) : null) } _remove(e) { return this.storage.removeItem(e), Promise.resolve() } get storage() { return this.storageRetriever() } } const ut = (() => { class e extends lt { constructor() { super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (e, t) => this.onStorageEvent(e, t), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function () { const e = (0, s.z$)(); return J(e) || ie(e) }() && function () { try { return !(!window || window === window.top) } catch (e) { return !1 } }(), this.fallbackToPolling = oe(), this._shouldAllowMigration = !0 } forAllChangedKeys(e) { for (const t of Object.keys(this.listeners)) { const n = this.storage.getItem(t), r = this.localCache[t]; n !== r && e(t, r, n) } } onStorageEvent(e, t = !1) { if (!e.key) return void this.forAllChangedKeys((e, t, n) => { this.notifyListeners(e, n) }); const n = e.key; if (t ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) { const r = this.storage.getItem(n); if (e.newValue !== r) null !== e.newValue ? this.storage.setItem(n, e.newValue) : this.storage.removeItem(n); else if (this.localCache[n] === e.newValue && !t) return } const r = () => { const e = this.storage.getItem(n); (t || this.localCache[n] !== e) && this.notifyListeners(n, e) }, i = this.storage.getItem(n); (0, s.w1)() && 10 === document.documentMode && i !== e.newValue && e.newValue !== e.oldValue ? setTimeout(r, 10) : r() } notifyListeners(e, t) { this.localCache[e] = t; const n = this.listeners[e]; if (n) for (const r of Array.from(n)) r(t ? JSON.parse(t) : t) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(() => { this.forAllChangedKeys((e, t, n) => { this.onStorageEvent(new StorageEvent("storage", { key: e, oldValue: t, newValue: n }), !0) }) }, 1e3) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } attachListener() { window.addEventListener("storage", this.boundEventHandler) } detachListener() { window.removeEventListener("storage", this.boundEventHandler) } _addListener(e, t) { 0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[e] || (this.listeners[e] = new Set, this.localCache[e] = this.storage.getItem(e)), this.listeners[e].add(t) } _removeListener(e, t) { this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling()) } async _set(e, t) { await super._set(e, t), this.localCache[e] = JSON.stringify(t) } async _get(e) { const t = await super._get(e); return this.localCache[e] = JSON.stringify(t), t } async _remove(e) { await super._remove(e), delete this.localCache[e] } } return e.type = "LOCAL", e })(), ht = (() => { class e extends lt { constructor() { super(() => window.sessionStorage, "SESSION") } _addListener(e, t) { } _removeListener(e, t) { } } return e.type = "SESSION", e })(); let dt = (() => { class e { constructor(e) { this.eventTarget = e, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this) } static _getInstance(t) { const n = this.receivers.find(e => e.isListeningto(t)); if (n) return n; const r = new e(t); return this.receivers.push(r), r } isListeningto(e) { return this.eventTarget === e } async handleEvent(e) { const t = e, { eventId: n, eventType: r, data: s } = t.data, i = this.handlersMap[r]; if (!(null == i ? void 0 : i.size)) return; t.ports[0].postMessage({ status: "ack", eventId: n, eventType: r }); const o = Array.from(i).map(async e => e(t.origin, s)), a = await function (e) { return Promise.all(e.map(async e => { try { return { fulfilled: !0, value: await e } } catch (t) { return { fulfilled: !1, reason: t } } })) }(o); t.ports[0].postMessage({ status: "done", eventId: n, eventType: r, response: a }) } _subscribe(e, t) { 0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[e] || (this.handlersMap[e] = new Set), this.handlersMap[e].add(t) } _unsubscribe(e, t) { this.handlersMap[e] && t && this.handlersMap[e].delete(t), t && 0 !== this.handlersMap[e].size || delete this.handlersMap[e], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler) } } return e.receivers = [], e })(); function ft(e = "", t = 10) { let n = ""; for (let r = 0; r < t; r++)n += Math.floor(10 * Math.random()); return e + n } class pt { constructor(e) { this.target = e, this.handlers = new Set } removeMessageHandler(e) { e.messageChannel && (e.messageChannel.port1.removeEventListener("message", e.onMessage), e.messageChannel.port1.close()), this.handlers.delete(e) } async _send(e, t, n = 50) { const r = "undefined" != typeof MessageChannel ? new MessageChannel : null; if (!r) throw new Error("connection_unavailable"); let s, i; return new Promise((o, a) => { const c = ft("", 20); r.port1.start(); const l = setTimeout(() => { a(new Error("unsupported_event")) }, n); i = { messageChannel: r, onMessage(e) { const t = e; if (t.data.eventId === c) switch (t.data.status) { case "ack": clearTimeout(l), s = setTimeout(() => { a(new Error("timeout")) }, 3e3); break; case "done": clearTimeout(s), o(t.data.response); break; default: clearTimeout(l), clearTimeout(s), a(new Error("invalid_response")) } } }, this.handlers.add(i), r.port1.addEventListener("message", i.onMessage), this.target.postMessage({ eventType: e, eventId: c, data: t }, [r.port2]) }).finally(() => { i && this.removeMessageHandler(i) }) } } function mt() { return window } function gt() { return void 0 !== mt().WorkerGlobalScope && "function" == typeof mt().importScripts } const yt = "firebaseLocalStorageDb", vt = "firebaseLocalStorage", wt = "fbase_key"; class bt { constructor(e) { this.request = e } toPromise() { return new Promise((e, t) => { this.request.addEventListener("success", () => { e(this.request.result) }), this.request.addEventListener("error", () => { t(this.request.error) }) }) } } function _t(e, t) { return e.transaction([vt], t ? "readwrite" : "readonly").objectStore(vt) } function Et() { const e = indexedDB.open(yt, 1); return new Promise((t, n) => { e.addEventListener("error", () => { n(e.error) }), e.addEventListener("upgradeneeded", () => { const t = e.result; try { t.createObjectStore(vt, { keyPath: wt }) } catch (r) { n(r) } }), e.addEventListener("success", async () => { const n = e.result; n.objectStoreNames.contains(vt) ? t(n) : (n.close(), await function () { const e = indexedDB.deleteDatabase(yt); return new bt(e).toPromise() }(), t(await Et())) }) }) } async function Ct(e, t, n) { const r = _t(e, !0).put({ [wt]: t, value: n }); return new bt(r).toPromise() } function St(e, t) { const n = _t(e, !0).delete(t); return new bt(n).toPromise() } const Tt = (() => { class e { constructor() { this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => { }, () => { }) } async _openDb() { return this.db || (this.db = await Et()), this.db } async _withRetries(e) { let t = 0; for (; ;)try { const t = await this._openDb(); return await e(t) } catch (n) { if (t++ > 3) throw n; this.db && (this.db.close(), this.db = void 0) } } async initializeServiceWorkerMessaging() { return gt() ? this.initializeReceiver() : this.initializeSender() } async initializeReceiver() { this.receiver = dt._getInstance(gt() ? self : null), this.receiver._subscribe("keyChanged", async (e, t) => ({ keyProcessed: (await this._poll()).includes(t.key) })), this.receiver._subscribe("ping", async (e, t) => ["keyChanged"]) } async initializeSender() { var e, t; if (this.activeServiceWorker = await async function () { if (!(null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker)) return null; try { return (await navigator.serviceWorker.ready).active } catch (e) { return null } }(), !this.activeServiceWorker) return; this.sender = new pt(this.activeServiceWorker); const n = await this.sender._send("ping", {}, 800); n && (null === (e = n[0]) || void 0 === e ? void 0 : e.fulfilled) && (null === (t = n[0]) || void 0 === t ? void 0 : t.value.includes("keyChanged")) && (this.serviceWorkerReceiverAvailable = !0) } async notifyServiceWorker(e) { var t; if (this.sender && this.activeServiceWorker && ((null === (t = null === navigator || void 0 === navigator ? void 0 : navigator.serviceWorker) || void 0 === t ? void 0 : t.controller) || null) === this.activeServiceWorker) try { await this.sender._send("keyChanged", { key: e }, this.serviceWorkerReceiverAvailable ? 800 : 50) } catch (t) { } } async _isAvailable() { try { if (!indexedDB) return !1; const e = await Et(); return await Ct(e, ct, "1"), await St(e, ct), !0 } catch (e) { } return !1 } async _withPendingWrite(e) { this.pendingWrites++; try { await e() } finally { this.pendingWrites-- } } async _set(e, t) { return this._withPendingWrite(async () => (await this._withRetries(n => Ct(n, e, t)), this.localCache[e] = t, this.notifyServiceWorker(e))) } async _get(e) { const t = await this._withRetries(t => async function (e, t) { const n = _t(e, !1).get(t), r = await new bt(n).toPromise(); return void 0 === r ? null : r.value }(t, e)); return this.localCache[e] = t, t } async _remove(e) { return this._withPendingWrite(async () => (await this._withRetries(t => St(t, e)), delete this.localCache[e], this.notifyServiceWorker(e))) } async _poll() { const e = await this._withRetries(e => { const t = _t(e, !1).getAll(); return new bt(t).toPromise() }); if (!e) return []; if (0 !== this.pendingWrites) return []; const t = [], n = new Set; for (const { fbase_key: r, value: s } of e) n.add(r), JSON.stringify(this.localCache[r]) !== JSON.stringify(s) && (this.notifyListeners(r, s), t.push(r)); for (const r of Object.keys(this.localCache)) this.localCache[r] && !n.has(r) && (this.notifyListeners(r, null), t.push(r)); return t } notifyListeners(e, t) { this.localCache[e] = t; const n = this.listeners[e]; if (n) for (const r of Array.from(n)) r(t) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(async () => this._poll(), 800) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } _addListener(e, t) { 0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[e] || (this.listeners[e] = new Set, this._get(e)), this.listeners[e].add(t) } _removeListener(e, t) { this.listeners[e] && (this.listeners[e].delete(t), 0 === this.listeners[e].size && delete this.listeners[e]), 0 === Object.keys(this.listeners).length && this.stopPolling() } } return e.type = "LOCAL", e })(); function It(e) { return new Promise((t, n) => { const r = document.createElement("script"); var s, i; r.setAttribute("src", e), r.onload = t, r.onerror = e => { const t = p("internal-error"); t.customData = e, n(t) }, r.type = "text/javascript", r.charset = "UTF-8", (null !== (i = null === (s = document.getElementsByTagName("head")) || void 0 === s ? void 0 : s[0]) && void 0 !== i ? i : document).appendChild(r) }) } function kt(e) { return `__${e}${Math.floor(1e6 * Math.random())}` } const At = 1e12; class xt { constructor(e) { this.auth = e, this.counter = At, this._widgets = new Map } render(e, t) { const n = this.counter; return this._widgets.set(n, new Dt(e, this.auth.name, t || {})), this.counter++, n } reset(e) { var t; const n = e || At; null === (t = this._widgets.get(n)) || void 0 === t || t.delete(), this._widgets.delete(n) } getResponse(e) { var t; return (null === (t = this._widgets.get(e || At)) || void 0 === t ? void 0 : t.getResponse()) || "" } async execute(e) { var t; return null === (t = this._widgets.get(e || At)) || void 0 === t || t.execute(), "" } } class Dt { constructor(e, t, n) { this.params = n, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => { this.execute() }; const r = "string" == typeof e ? document.getElementById(e) : e; v(r, "argument-error", { appName: t }), this.container = r, this.isVisible = "invisible" !== this.params.size, this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler) } getResponse() { return this.checkIfDeleted(), this.responseToken } delete() { this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler) } execute() { this.checkIfDeleted(), this.timerId || (this.timerId = window.setTimeout(() => { this.responseToken = function (e) { const t = [], n = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let r = 0; r < 50; r++)t.push(n.charAt(Math.floor(Math.random() * n.length))); return t.join("") }(); const { callback: e, "expired-callback": t } = this.params; if (e) try { e(this.responseToken) } catch (n) { } this.timerId = window.setTimeout(() => { if (this.timerId = null, this.responseToken = null, t) try { t() } catch (n) { } this.isVisible && this.execute() }, 6e4) }, 500)) } checkIfDeleted() { if (this.deleted) throw new Error("reCAPTCHA mock was already deleted!") } } const Ot = kt("rcb"), Rt = new I(3e4, 6e4); class Nt { constructor() { this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !!mt().grecaptcha } load(e, t = "") { return v(function (e) { return e.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(e) }(t), e, "argument-error"), this.shouldResolveImmediately(t) ? Promise.resolve(mt().grecaptcha) : new Promise((n, r) => { const i = mt().setTimeout(() => { r(p(e, "network-request-failed")) }, Rt.get()); mt()[Ot] = () => { mt().clearTimeout(i), delete mt()[Ot]; const s = mt().grecaptcha; if (!s) return void r(p(e, "internal-error")); const o = s.render; s.render = (e, t) => { const n = o(e, t); return this.counter++, n }, this.hostLanguage = t, n(s) }, It(`https://www.google.com/recaptcha/api.js??${(0, s.xO)({ onload: Ot, render: "explicit", hl: t })}`).catch(() => { clearTimeout(i), r(p(e, "internal-error")) }) }) } clearedOneInstance() { this.counter-- } shouldResolveImmediately(e) { return !!mt().grecaptcha && (e === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded) } } class Pt { async load(e) { return new xt(e) } clearedOneInstance() { } } const Ft = "recaptcha", Lt = { theme: "light", type: "image" }; class Mt { constructor(e, t = Object.assign({}, Lt), n) { this.parameters = t, this.type = Ft, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = new Set, this.renderPromise = null, this.recaptcha = null, this.auth = le(n), this.isInvisible = "invisible" === this.parameters.size, v("undefined" != typeof document, this.auth, "operation-not-supported-in-this-environment"); const r = "string" == typeof e ? document.getElementById(e) : e; v(r, this.auth, "argument-error"), this.container = r, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new Pt : new Nt, this.validateStartingState() } async verify() { this.assertNotDestroyed(); const e = await this.render(), t = this.getAssertedRecaptcha(); return t.getResponse(e) || new Promise(n => { const r = e => { e && (this.tokenChangeListeners.delete(r), n(e)) }; this.tokenChangeListeners.add(r), this.isInvisible && t.execute(e) }) } render() { try { this.assertNotDestroyed() } catch (e) { return Promise.reject(e) } return this.renderPromise || (this.renderPromise = this.makeRenderPromise().catch(e => { throw this.renderPromise = null, e })), this.renderPromise } _reset() { this.assertNotDestroyed(), null !== this.widgetId && this.getAssertedRecaptcha().reset(this.widgetId) } clear() { this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach(e => { this.container.removeChild(e) }) } validateStartingState() { v(!this.parameters.sitekey, this.auth, "argument-error"), v(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"), v("undefined" != typeof document, this.auth, "operation-not-supported-in-this-environment") } makeTokenCallback(e) { return t => { if (this.tokenChangeListeners.forEach(e => e(t)), "function" == typeof e) e(t); else if ("string" == typeof e) { const n = mt()[e]; "function" == typeof n && n(t) } } } assertNotDestroyed() { v(!this.destroyed, this.auth, "internal-error") } async makeRenderPromise() { if (await this.init(), !this.widgetId) { let e = this.container; if (!this.isInvisible) { const t = document.createElement("div"); e.appendChild(t), e = t } this.widgetId = this.getAssertedRecaptcha().render(e, this.parameters) } return this.widgetId } async init() { v(S() && !gt(), this.auth, "internal-error"), await function () { let e = null; return new Promise(t => { "complete" !== document.readyState ? (e = () => t(), window.addEventListener("load", e)) : t() }).catch(t => { throw e && window.removeEventListener("load", e), t }) }(), this.recaptcha = await this._recaptchaLoader.load(this.auth, this.auth.languageCode || void 0); const e = await async function (e) { return (await R(e, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || "" }(this.auth); v(e, this.auth, "internal-error"), this.parameters.sitekey = e } getAssertedRecaptcha() { return v(this.recaptcha, this.auth, "internal-error"), this.recaptcha } } class $t { constructor(e, t) { this.verificationId = e, this.onConfirmation = t } confirm(e) { const t = _e._fromVerification(this.verificationId, e); return this.onConfirmation(t) } } async function Bt(e, t, n) { var r; const s = await n.verify(); try { let i; if (v("string" == typeof s, e, "argument-error"), v(n.type === Ft, e, "argument-error"), i = "string" == typeof t ? { phoneNumber: t } : t, "session" in i) { const t = i.session; if ("phoneNumber" in i) return v("enroll" === t.type, e, "internal-error"), (await function (e, t) { return R(e, "POST", "/v2/accounts/mfaEnrollment:start", O(e, t)) }(e, { idToken: t.credential, phoneEnrollmentInfo: { phoneNumber: i.phoneNumber, recaptchaToken: s } })).phoneSessionInfo.sessionInfo; { v("signin" === t.type, e, "internal-error"); const n = (null === (r = i.multiFactorHint) || void 0 === r ? void 0 : r.uid) || i.multiFactorUid; return v(n, e, "missing-multi-factor-info"), (await function (e, t) { return R(e, "POST", "/v2/accounts/mfaSignIn:start", O(e, t)) }(e, { mfaPendingCredential: t.credential, mfaEnrollmentId: n, phoneSignInInfo: { recaptchaToken: s } })).phoneResponseInfo.sessionInfo } } { const { sessionInfo: t } = await async function (e, t) { return R(e, "POST", "/v1/accounts:sendVerificationCode", O(e, t)) }(e, { phoneNumber: i.phoneNumber, recaptchaToken: s }); return t } } finally { n._reset() } } let Vt = (() => { class e { constructor(t) { this.providerId = e.PROVIDER_ID, this.auth = le(t) } verifyPhoneNumber(e, t) { return Bt(this.auth, e, (0, s.m9)(t)) } static credential(e, t) { return _e._fromVerification(e, t) } static credentialFromResult(t) { return e.credentialFromTaggedObject(t) } static credentialFromError(t) { return e.credentialFromTaggedObject(t.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: e }) { if (!e) return null; const { phoneNumber: t, temporaryProof: n } = e; return t && n ? _e._fromTokenResponse(t, n) : null } } return e.PROVIDER_ID = "phone", e.PHONE_SIGN_IN_METHOD = "phone", e })(); function Ut(e, t) { return t ? E(t) : (v(e._popupRedirectResolver, e, "argument-error"), e._popupRedirectResolver) } class jt extends fe { constructor(e) { super("custom", "custom"), this.params = e } _getIdTokenResponse(e) { return ve(e, this._buildIdpRequest()) } _linkToIdToken(e, t) { return ve(e, this._buildIdpRequest(t)) } _getReauthenticationResolver(e) { return ve(e, this._buildIdpRequest()) } _buildIdpRequest(e) { const t = { requestUri: this.params.requestUri, sessionId: this.params.sessionId, postBody: this.params.postBody, tenantId: this.params.tenantId, pendingToken: this.params.pendingToken, returnSecureToken: !0, returnIdpCredential: !0 }; return e && (t.idToken = e), t } } function qt(e) { return je(e.auth, new jt(e), e.bypassAuthState) } function zt(e) { const { auth: t, user: n } = e; return v(n, t, "internal-error"), Ue(n, new jt(e), e.bypassAuthState) } async function Ht(e) { const { auth: t, user: n } = e; return v(n, t, "internal-error"), Be(n, new jt(e), e.bypassAuthState) } class Gt { constructor(e, t, n, r, s = !1) { this.auth = e, this.resolver = n, this.user = r, this.bypassAuthState = s, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(t) ? t : [t] } execute() { return new Promise(async (e, t) => { this.pendingPromise = { resolve: e, reject: t }; try { this.eventManager = await this.resolver._initialize(this.auth), await this.onExecution(), this.eventManager.registerConsumer(this) } catch (n) { this.reject(n) } }) } async onAuthEvent(e) { const { urlResponse: t, sessionId: n, postBody: r, tenantId: s, error: i, type: o } = e; if (i) return void this.reject(i); const a = { auth: this.auth, requestUri: t, sessionId: n, tenantId: s || void 0, postBody: r || void 0, user: this.user, bypassAuthState: this.bypassAuthState }; try { this.resolve(await this.getIdpTask(o)(a)) } catch (c) { this.reject(c) } } onError(e) { this.reject(e) } getIdpTask(e) { switch (e) { case "signInViaPopup": case "signInViaRedirect": return qt; case "linkViaPopup": case "linkViaRedirect": return Ht; case "reauthViaPopup": case "reauthViaRedirect": return zt; default: f(this.auth, "internal-error") } } resolve(e) { b(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(e), this.unregisterAndCleanUp() } reject(e) { b(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(e), this.unregisterAndCleanUp() } unregisterAndCleanUp() { this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp() } } const Wt = new I(2e3, 1e4); let Yt = (() => { class e extends Gt { constructor(t, n, r, s, i) { super(t, n, s, i), this.provider = r, this.authWindow = null, this.pollId = null, e.currentPopupAction && e.currentPopupAction.cancel(), e.currentPopupAction = this } async executeNotNull() { const e = await this.execute(); return v(e, this.auth, "internal-error"), e } async onExecution() { b(1 === this.filter.length, "Popup operations only handle one event"); const e = ft(); this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], e), this.authWindow.associatedEvent = e, this.resolver._originValidation(this.auth).catch(e => { this.reject(e) }), this.resolver._isIframeWebStorageSupported(this.auth, e => { e || this.reject(p(this.auth, "web-storage-unsupported")) }), this.pollUserCancellation() } get eventId() { var e; return (null === (e = this.authWindow) || void 0 === e ? void 0 : e.associatedEvent) || null } cancel() { this.reject(p(this.auth, "cancelled-popup-request")) } cleanUp() { this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, e.currentPopupAction = null } pollUserCancellation() { const e = () => { var t, n; this.pollId = (null === (n = null === (t = this.authWindow) || void 0 === t ? void 0 : t.window) || void 0 === n ? void 0 : n.closed) ? window.setTimeout(() => { this.pollId = null, this.reject(p(this.auth, "popup-closed-by-user")) }, 2e3) : window.setTimeout(e, Wt.get()) }; e() } } return e.currentPopupAction = null, e })(); const Kt = new Map; class Xt extends Gt { constructor(e, t, n = !1) { super(e, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], t, void 0, n), this.eventId = null } async execute() { let e = Kt.get(this.auth._key()); if (!e) { try { const t = await async function (e, t) { const n = Jt(t), r = Qt(e); if (!(await r._isAvailable())) return !1; const s = "true" === await r._get(n); return await r._remove(n), s }(this.resolver, this.auth) ? await super.execute() : null; e = () => Promise.resolve(t) } catch (t) { e = () => Promise.reject(t) } Kt.set(this.auth._key(), e) } return this.bypassAuthState || Kt.set(this.auth._key(), () => Promise.resolve(null)), e() } async onAuthEvent(e) { if ("signInViaRedirect" === e.type) return super.onAuthEvent(e); if ("unknown" !== e.type) { if (e.eventId) { const t = await this.auth._redirectUserForId(e.eventId); if (t) return this.user = t, super.onAuthEvent(e); this.resolve(null) } } else this.resolve(null) } async onExecution() { } cleanUp() { } } async function Zt(e, t) { return Qt(e)._set(Jt(t), "true") } function Qt(e) { return E(e._redirectPersistence) } function Jt(e) { return K("pendingRedirect", e.config.apiKey, e.name) } async function en(e, t, n = !1) { const r = le(e), s = Ut(r, t), i = new Xt(r, s, n), o = await i.execute(); return o && !n && (delete o.user._redirectEventId, await r._persistUserIfCurrent(o.user), await r._setRedirectUser(null, t)), o } async function tn(e) { const t = ft(`${e.uid}:::`); return e._redirectEventId = t, await e.auth._setRedirectUser(e), await e.auth._persistUserIfCurrent(e), t } class nn { constructor(e) { this.auth = e, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now() } registerConsumer(e) { this.consumers.add(e), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, e) && (this.sendToConsumer(this.queuedRedirectEvent, e), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null) } unregisterConsumer(e) { this.consumers.delete(e) } onEvent(e) { if (this.hasEventBeenHandled(e)) return !1; let t = !1; return this.consumers.forEach(n => { this.isEventForConsumer(e, n) && (t = !0, this.sendToConsumer(e, n), this.saveEventToCache(e)) }), this.hasHandledPotentialRedirect || !function (e) { switch (e.type) { case "signInViaRedirect": case "linkViaRedirect": case "reauthViaRedirect": return !0; case "unknown": return sn(e); default: return !1 } }(e) || (this.hasHandledPotentialRedirect = !0, t || (this.queuedRedirectEvent = e, t = !0)), t } sendToConsumer(e, t) { var n; if (e.error && !sn(e)) { const r = (null === (n = e.error.code) || void 0 === n ? void 0 : n.split("auth/")[1]) || "internal-error"; t.onError(p(this.auth, r)) } else t.onAuthEvent(e) } isEventForConsumer(e, t) { const n = null === t.eventId || !!e.eventId && e.eventId === t.eventId; return t.filter.includes(e.type) && n } hasEventBeenHandled(e) { return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(rn(e)) } saveEventToCache(e) { this.cachedEventUids.add(rn(e)), this.lastProcessedEventTime = Date.now() } } function rn(e) { return [e.type, e.eventId, e.sessionId, e.tenantId].filter(e => e).join("-") } function sn({ type: e, error: t }) { return "unknown" === e && "auth/no-auth-event" === (null == t ? void 0 : t.code) } async function on(e, t = {}) { return R(e, "GET", "/v1/projects", t) } const an = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, cn = /^https?/; function ln(e) { const t = C(), { protocol: n, hostname: r } = new URL(t); if (e.startsWith("chrome-extension://")) { const s = new URL(e); return "" === s.hostname && "" === r ? "chrome-extension:" === n && e.replace("chrome-extension://", "") === t.replace("chrome-extension://", "") : "chrome-extension:" === n && s.hostname === r } if (!cn.test(n)) return !1; if (an.test(e)) return r === e; const s = e.replace(/\./g, "\\."); return new RegExp("^(.+\\." + s + "|" + s + ")$", "i").test(r) } const un = new I(3e4, 6e4); function hn() { const e = mt().___jsl; if (null == e ? void 0 : e.H) for (const t of Object.keys(e.H)) if (e.H[t].r = e.H[t].r || [], e.H[t].L = e.H[t].L || [], e.H[t].r = [...e.H[t].L], e.CP) for (let n = 0; n < e.CP.length; n++)e.CP[n] = null } let dn = null; function fn(e) { return dn = dn || function (e) { return new Promise((t, n) => { var r, s, i; function o() { hn(), gapi.load("gapi.iframes", { callback: () => { t(gapi.iframes.getContext()) }, ontimeout: () => { hn(), n(p(e, "network-request-failed")) }, timeout: un.get() }) } if (null === (s = null === (r = mt().gapi) || void 0 === r ? void 0 : r.iframes) || void 0 === s ? void 0 : s.Iframe) t(gapi.iframes.getContext()); else { if (!(null === (i = mt().gapi) || void 0 === i ? void 0 : i.load)) { const t = kt("iframefcb"); return mt()[t] = () => { gapi.load ? o() : n(p(e, "network-request-failed")) }, It(`https://apis.google.com/js/api.js?onload=${t}`).catch(e => n(e)) } o() } }).catch(e => { throw dn = null, e }) }(e), dn } const pn = new I(5e3, 15e3), mn = { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" }, "aria-hidden": "true", tabindex: "-1" }, gn = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]); function yn(e) { const t = e.config; v(t.authDomain, e, "auth-domain-config-required"); const n = t.emulator ? k(t, "emulator/auth/iframe") : `https://${e.config.authDomain}/__/auth/iframe`, r = { apiKey: t.apiKey, appName: e.name, v: i.SDK_VERSION }, o = gn.get(e.config.apiHost); o && (r.eid = o); const a = e._getFrameworks(); return a.length && (r.fw = a.join(",")), `${n}?${(0, s.xO)(r).slice(1)}` } const vn = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" }; class wn { constructor(e) { this.window = e, this.associatedEvent = null } close() { if (this.window) try { this.window.close() } catch (e) { } } } function bn(e, t, n, r, o, a) { v(e.config.authDomain, e, "auth-domain-config-required"), v(e.config.apiKey, e, "invalid-api-key"); const c = { apiKey: e.config.apiKey, appName: e.name, authType: n, redirectUrl: r, v: i.SDK_VERSION, eventId: o }; if (t instanceof Se) { t.setDefaultLanguage(e.languageCode), c.providerId = t.providerId || "", (0, s.xb)(t.getCustomParameters()) || (c.customParameters = JSON.stringify(t.getCustomParameters())); for (const [e, t] of Object.entries(a || {})) c[e] = t } if (t instanceof Te) { const e = t.getScopes().filter(e => "" !== e); e.length > 0 && (c.scopes = e.join(",")) } e.tenantId && (c.tid = e.tenantId); const l = c; for (const s of Object.keys(l)) void 0 === l[s] && delete l[s]; return `${function ({ config: e }) { return e.emulator ? k(e, "emulator/auth/handler") : `https://${e.authDomain}/__/auth/handler` }(e)}?${(0, s.xO)(l).slice(1)}` } const _n = "webStorageSupport"; class En extends class { constructor(e) { this.factorId = e } _process(e, t, n) { switch (t.type) { case "enroll": return this._finalizeEnroll(e, t.credential, n); case "signin": return this._finalizeSignIn(e, t.credential); default: return w("unexpected MultiFactorSessionType") } } }{ constructor(e) { super("phone"), this.credential = e } static _fromCredential(e) { return new En(e) } _finalizeEnroll(e, t, n) { return function (e, t) { return R(e, "POST", "/v2/accounts/mfaEnrollment:finalize", O(e, t)) }(e, { idToken: t, displayName: n, phoneVerificationInfo: this.credential._makeVerificationRequest() }) } _finalizeSignIn(e, t) { return function (e, t) { return R(e, "POST", "/v2/accounts/mfaSignIn:finalize", O(e, t)) }(e, { mfaPendingCredential: t, phoneVerificationInfo: this.credential._makeVerificationRequest() }) } } let Cn = (() => { class e { constructor() { } static assertion(e) { return En._fromCredential(e) } } return e.FACTOR_ID = "phone", e })(); var Sn, Tn = "@firebase/auth", In = "0.19.10"; class kn { constructor(e) { this.auth = e, this.internalListeners = new Map } getUid() { var e; return this.assertAuthConfigured(), (null === (e = this.auth.currentUser) || void 0 === e ? void 0 : e.uid) || null } async getToken(e) { return this.assertAuthConfigured(), await this.auth._initializationPromise, this.auth.currentUser ? { accessToken: await this.auth.currentUser.getIdToken(e) } : null } addAuthTokenListener(e) { if (this.assertAuthConfigured(), this.internalListeners.has(e)) return; const t = this.auth.onIdTokenChanged(t => { var n; e((null === (n = t) || void 0 === n ? void 0 : n.stsTokenManager.accessToken) || null) }); this.internalListeners.set(e, t), this.updateProactiveRefresh() } removeAuthTokenListener(e) { this.assertAuthConfigured(); const t = this.internalListeners.get(e); t && (this.internalListeners.delete(e), t(), this.updateProactiveRefresh()) } assertAuthConfigured() { v(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth") } updateProactiveRefresh() { this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh() } } function An() { return window } Sn = "Browser", (0, i._registerComponent)(new c.wA("auth", (e, { options: t }) => { const n = e.getProvider("app").getImmediate(), r = e.getProvider("heartbeat"), { apiKey: s, authDomain: i } = n.options; return ((e, n) => { v(s && !s.includes(":"), "invalid-api-key", { appName: e.name }), v(!(null == i ? void 0 : i.includes(":")), "argument-error", { appName: e.name }); const r = { apiKey: s, authDomain: i, clientPlatform: Sn, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: ae(Sn) }, o = new ce(e, n, r); return function (e, t) { const n = (null == t ? void 0 : t.persistence) || [], r = (Array.isArray(n) ? n : [n]).map(E); (null == t ? void 0 : t.errorMap) && e._updateErrorMap(t.errorMap), e._initializeWithPersistence(r, null == t ? void 0 : t.popupRedirectResolver) }(o, t), o })(n, r) }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((e, t, n) => { e.getProvider("auth-internal").initialize() })), (0, i._registerComponent)(new c.wA("auth-internal", e => { return t = le(e.getProvider("auth").getImmediate()), new kn(t); var t }, "PRIVATE").setInstantiationMode("EXPLICIT")), (0, i.registerVersion)(Tn, In, void 0), (0, i.registerVersion)(Tn, In, "esm2017"); class xn extends nn { constructor() { super(...arguments), this.passiveListeners = new Set, this.initPromise = new Promise(e => { this.resolveInialized = e }) } addPassiveListener(e) { this.passiveListeners.add(e) } removePassiveListener(e) { this.passiveListeners.delete(e) } resetRedirect() { this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1 } onEvent(e) { return this.resolveInialized(), this.passiveListeners.forEach(t => t(e)), super.onEvent(e) } async initialized() { await this.initPromise } } async function Dn(e) { const t = await Rn()._get(Nn(e)); return t && await Rn()._remove(Nn(e)), t } function On() { const e = [], t = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let n = 0; n < 20; n++) { const n = Math.floor(Math.random() * t.length); e.push(t.charAt(n)) } return e.join("") } function Rn() { return E(ut) } function Nn(e) { return K("authEvent", e.config.apiKey, e.name) } function Pn(e) { if (!(null == e ? void 0 : e.includes("?"))) return {}; const [t, ...n] = e.split("?"); return (0, s.zd)(n.join("?")) } function Fn() { return { type: "unknown", eventId: null, sessionId: null, urlResponse: null, postBody: null, tenantId: null, error: p("no-auth-event") } } function Ln() { var e; return (null === (e = null === self || void 0 === self ? void 0 : self.location) || void 0 === e ? void 0 : e.protocol) || null } function Mn(e = (0, s.z$)()) { return !("file:" !== Ln() && "ionic:" !== Ln() || !e.toLowerCase().match(/iphone|ipad|ipod|android/)) } function $n() { try { const e = self.localStorage, t = ft(); if (e) return e.setItem(t, "1"), e.removeItem(t), !function (e = (0, s.z$)()) { return (0, s.w1)() && 11 === (null === document || void 0 === document ? void 0 : document.documentMode) || function (e = (0, s.z$)()) { return /Edge\/\d+/.test(e) }(e) }() || (0, s.hl)() } catch (e) { return Bn() && (0, s.hl)() } return !1 } function Bn() { return "undefined" != typeof global && "WorkerGlobalScope" in global && "importScripts" in global } function Vn() { return ("http:" === Ln() || "https:" === Ln() || (0, s.ru)() || Mn()) && !((0, s.b$)() || (0, s.UG)()) && $n() && !Bn() } function Un() { return Mn() && "undefined" != typeof document } const jn = { LOCAL: "local", NONE: "none", SESSION: "session" }, qn = v, zn = "persistence"; async function Hn(e) { await e._initializationPromise; const t = Gn(), n = K(zn, e.config.apiKey, e.name); t && t.setItem(n, e._getPersistence()) } function Gn() { var e; try { return (null === (e = "undefined" != typeof window ? window : null) || void 0 === e ? void 0 : e.sessionStorage) || null } catch (t) { return null } } const Wn = v; class Yn { constructor() { this.browserResolver = E(class { constructor() { this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = ht, this._completeRedirectFn = en } async _openPopup(e, t, n, r) { var i; return b(null === (i = this.eventManagers[e._key()]) || void 0 === i ? void 0 : i.manager, "_initialize() not called before _openPopup()"), function (e, t, n, r = 500, i = 600) { const o = Math.max((window.screen.availHeight - i) / 2, 0).toString(), a = Math.max((window.screen.availWidth - r) / 2, 0).toString(); let c = ""; const l = Object.assign(Object.assign({}, vn), { width: r.toString(), height: i.toString(), top: o, left: a }), u = (0, s.z$)().toLowerCase(); n && (c = ee(u) ? "_blank" : n), Q(u) && (t = t || "http://localhost", l.scrollbars = "yes"); const h = Object.entries(l).reduce((e, [t, n]) => `${e}${t}=${n},`, ""); if (function (e = (0, s.z$)()) { var t; return ie(e) && !!(null === (t = window.navigator) || void 0 === t ? void 0 : t.standalone) }(u) && "_self" !== c) return function (e, t) { const n = document.createElement("a"); n.href = e, n.target = t; const r = document.createEvent("MouseEvent"); r.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), n.dispatchEvent(r) }(t || "", c), new wn(null); const d = window.open(t || "", c, h); v(d, e, "popup-blocked"); try { d.focus() } catch (f) { } return new wn(d) }(e, bn(e, t, n, C(), r), ft()) } async _openRedirect(e, t, n, r) { var s; return await this._originValidation(e), s = bn(e, t, n, C(), r), mt().location.href = s, new Promise(() => { }) } _initialize(e) { const t = e._key(); if (this.eventManagers[t]) { const { manager: e, promise: n } = this.eventManagers[t]; return e ? Promise.resolve(e) : (b(n, "If manager is not set, promise should be"), n) } const n = this.initAndGetManager(e); return this.eventManagers[t] = { promise: n }, n.catch(() => { delete this.eventManagers[t] }), n } async initAndGetManager(e) { const t = await async function (e) { const t = await fn(e), n = mt().gapi; return v(n, e, "internal-error"), t.open({ where: document.body, url: yn(e), messageHandlersFilter: n.iframes.CROSS_ORIGIN_IFRAMES_FILTER, attributes: mn, dontclear: !0 }, t => new Promise(async (n, r) => { await t.restyle({ setHideOnLeave: !1 }); const s = p(e, "network-request-failed"), i = mt().setTimeout(() => { r(s) }, pn.get()); function o() { mt().clearTimeout(i), n(t) } t.ping(o).then(o, () => { r(s) }) })) }(e), n = new nn(e); return t.register("authEvent", t => (v(null == t ? void 0 : t.authEvent, e, "invalid-auth-event"), { status: n.onEvent(t.authEvent) ? "ACK" : "ERROR" }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), this.eventManagers[e._key()] = { manager: n }, this.iframes[e._key()] = t, n } _isIframeWebStorageSupported(e, t) { this.iframes[e._key()].send(_n, { type: _n }, n => { var r; const s = null === (r = null == n ? void 0 : n[0]) || void 0 === r ? void 0 : r.webStorageSupport; void 0 !== s && t(!!s), f(e, "internal-error") }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER) } _originValidation(e) { const t = e._key(); return this.originValidationPromises[t] || (this.originValidationPromises[t] = async function (e) { if (e.config.emulator) return; const { authorizedDomains: t } = await on(e); for (const r of t) try { if (ln(r)) return } catch (n) { } f(e, "unauthorized-domain") }(e)), this.originValidationPromises[t] } get _shouldInitProactively() { return oe() || J() || ie() } }), this.cordovaResolver = E(class { constructor() { this._redirectPersistence = ht, this._shouldInitProactively = !0, this.eventManagers = new Map, this.originValidationPromises = {}, this._completeRedirectFn = en } async _initialize(e) { const t = e._key(); let n = this.eventManagers.get(t); return n || (n = new xn(e), this.eventManagers.set(t, n), this.attachCallbackListeners(e, n)), n } _openPopup(e) { f(e, "operation-not-supported-in-this-environment") } async _openRedirect(e, t, n, r) { !function (e) { var t, n, r, s, i, o, a, c, l, u; const h = An(); v("function" == typeof (null === (t = null == h ? void 0 : h.universalLinks) || void 0 === t ? void 0 : t.subscribe), e, "invalid-cordova-configuration", { missingPlugin: "cordova-universal-links-plugin-fix" }), v(void 0 !== (null === (n = null == h ? void 0 : h.BuildInfo) || void 0 === n ? void 0 : n.packageName), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-buildInfo" }), v("function" == typeof (null === (i = null === (s = null === (r = null == h ? void 0 : h.cordova) || void 0 === r ? void 0 : r.plugins) || void 0 === s ? void 0 : s.browsertab) || void 0 === i ? void 0 : i.openUrl), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), v("function" == typeof (null === (c = null === (a = null === (o = null == h ? void 0 : h.cordova) || void 0 === o ? void 0 : o.plugins) || void 0 === a ? void 0 : a.browsertab) || void 0 === c ? void 0 : c.isAvailable), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), v("function" == typeof (null === (u = null === (l = null == h ? void 0 : h.cordova) || void 0 === l ? void 0 : l.InAppBrowser) || void 0 === u ? void 0 : u.open), e, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-inappbrowser" }) }(e); const i = await this._initialize(e); await i.initialized(), i.resetRedirect(), Kt.clear(), await this._originValidation(e); const o = function (e, t, n = null) { return { type: t, eventId: n, urlResponse: null, sessionId: On(), postBody: null, tenantId: e.tenantId, error: p(e, "no-auth-event") } }(e, n, r); await function (e, t) { return Rn()._set(Nn(e), t) }(e, o); const a = await async function (e, t, n) { var r; const { BuildInfo: s } = An(); b(t.sessionId, "AuthEvent did not contain a session ID"); const i = await async function (e) { const t = function (e) { if (b(/[0-9a-zA-Z]+/.test(e), "Can only convert alpha-numeric strings"), "undefined" != typeof TextEncoder) return (new TextEncoder).encode(e); const t = new ArrayBuffer(e.length), n = new Uint8Array(t); for (let r = 0; r < e.length; r++)n[r] = e.charCodeAt(r); return n }(e), n = await crypto.subtle.digest("SHA-256", t); return Array.from(new Uint8Array(n)).map(e => e.toString(16).padStart(2, "0")).join("") }(t.sessionId), o = {}; return ie() ? o.ibi = s.packageName : ne() ? o.apn = s.packageName : f(e, "operation-not-supported-in-this-environment"), s.displayName && (o.appDisplayName = s.displayName), o.sessionId = i, bn(e, n, t.type, void 0, null !== (r = t.eventId) && void 0 !== r ? r : void 0, o) }(e, o, t); return async function (e, t, n) { const { cordova: r } = An(); let s = () => { }; try { await new Promise((i, o) => { let a = null; function c() { var e; i(); const t = null === (e = r.plugins.browsertab) || void 0 === e ? void 0 : e.close; "function" == typeof t && t(), "function" == typeof (null == n ? void 0 : n.close) && n.close() } function l() { a || (a = window.setTimeout(() => { o(p(e, "redirect-cancelled-by-user")) }, 2e3)) } function u() { "visible" === (null === document || void 0 === document ? void 0 : document.visibilityState) && l() } t.addPassiveListener(c), document.addEventListener("resume", l, !1), ne() && document.addEventListener("visibilitychange", u, !1), s = () => { t.removePassiveListener(c), document.removeEventListener("resume", l, !1), document.removeEventListener("visibilitychange", u, !1), a && window.clearTimeout(a) } }) } finally { s() } }(e, i, await function (e) { const { cordova: t } = An(); return new Promise(n => { t.plugins.browsertab.isAvailable(r => { let i = null; r ? t.plugins.browsertab.openUrl(e) : i = t.InAppBrowser.open(e, function (e = (0, s.z$)()) { return /(iPad|iPhone|iPod).*OS 7_\d/i.test(e) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(e) }() ? "_blank" : "_system", "location=yes"), n(i) }) }) }(a)) } _isIframeWebStorageSupported(e, t) { throw new Error("Method not implemented.") } _originValidation(e) { const t = e._key(); return this.originValidationPromises[t] || (this.originValidationPromises[t] = async function (e) { const { BuildInfo: t } = An(), n = {}; ie() ? n.iosBundleId = t.packageName : ne() ? n.androidPackageName = t.packageName : f(e, "operation-not-supported-in-this-environment"), await on(e, n) }(e)), this.originValidationPromises[t] } attachCallbackListeners(e, t) { const { universalLinks: n, handleOpenURL: r, BuildInfo: s } = An(), i = setTimeout(async () => { await Dn(e), t.onEvent(Fn()) }, 500), o = async n => { clearTimeout(i); const r = await Dn(e); let s = null; r && (null == n ? void 0 : n.url) && (s = function (e, t) { var n, r; const s = function (e) { const t = Pn(e), n = t.link ? decodeURIComponent(t.link) : void 0, r = Pn(n).link, s = t.deep_link_id ? decodeURIComponent(t.deep_link_id) : void 0; return Pn(s).link || s || r || n || e }(t); if (s.includes("/__/auth/callback")) { const t = Pn(s), i = t.firebaseError ? function (e) { try { return JSON.parse(e) } catch (t) { return null } }(decodeURIComponent(t.firebaseError)) : null, o = null === (r = null === (n = null == i ? void 0 : i.code) || void 0 === n ? void 0 : n.split("auth/")) || void 0 === r ? void 0 : r[1], a = o ? p(o) : null; return a ? { type: e.type, eventId: e.eventId, tenantId: e.tenantId, error: a, urlResponse: null, sessionId: null, postBody: null } : { type: e.type, eventId: e.eventId, tenantId: e.tenantId, sessionId: e.sessionId, urlResponse: s, postBody: null } } return null }(r, n.url)), t.onEvent(s || Fn()) }; void 0 !== n && "function" == typeof n.subscribe && n.subscribe(null, o); const a = r, c = `${s.packageName.toLowerCase()}://`; An().handleOpenURL = async e => { if (e.toLowerCase().startsWith(c) && o({ url: e }), "function" == typeof a) try { a(e) } catch (t) { console.error(t) } } } }), this.underlyingResolver = null, this._redirectPersistence = ht, this._completeRedirectFn = en } async _initialize(e) { return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._initialize(e) } async _openPopup(e, t, n, r) { return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._openPopup(e, t, n, r) } async _openRedirect(e, t, n, r) { return await this.selectUnderlyingResolver(), this.assertedUnderlyingResolver._openRedirect(e, t, n, r) } _isIframeWebStorageSupported(e, t) { this.assertedUnderlyingResolver._isIframeWebStorageSupported(e, t) } _originValidation(e) { return this.assertedUnderlyingResolver._originValidation(e) } get _shouldInitProactively() { return Un() || this.browserResolver._shouldInitProactively } get assertedUnderlyingResolver() { return Wn(this.underlyingResolver, "internal-error"), this.underlyingResolver } async selectUnderlyingResolver() { if (this.underlyingResolver) return; const e = await async function () { return !!Un() && new Promise(e => { const t = setTimeout(() => { e(!1) }, 1e3); document.addEventListener("deviceready", () => { clearTimeout(t), e(!0) }) }) }(); this.underlyingResolver = e ? this.cordovaResolver : this.browserResolver } } function Kn(e) { return e.unwrap() } function Xn(e) { const { _tokenResponse: t } = e instanceof s.ZR ? e.customData : e; if (!t) return null; if (!(e instanceof s.ZR) && "temporaryProof" in t && "phoneNumber" in t) return Vt.credentialFromResult(e); const n = t.providerId; if (!n || "password" === n) return null; let r; switch (n) { case "google.com": r = Ae; break; case "facebook.com": r = ke; break; case "github.com": r = xe; break; case "twitter.com": r = Re; break; default: const { oauthIdToken: e, oauthAccessToken: s, oauthTokenSecret: i, pendingToken: o, nonce: a } = t; return s || i || e || o ? o ? n.startsWith("saml.") ? De._create(n, o) : we._fromParams({ providerId: n, signInMethod: n, pendingToken: o, idToken: e, accessToken: s }) : new Ie(n).credential({ idToken: e, accessToken: s, rawNonce: a }) : null }return e instanceof s.ZR ? r.credentialFromError(e) : r.credentialFromResult(e) } function Zn(e, t) { return t.catch(t => { throw t instanceof s.ZR && function (e, t) { var n; const r = null === (n = t.customData) || void 0 === n ? void 0 : n._tokenResponse; if ("auth/multi-factor-auth-required" === t.code) t.resolver = new Jn(e, function (e, t) { var n; const r = (0, s.m9)(e), i = t; return v(t.customData.operationType, r, "argument-error"), v(null === (n = i.customData._serverResponse) || void 0 === n ? void 0 : n.mfaPendingCredential, r, "argument-error"), it._fromError(r, i) }(e, t)); else if (r) { const e = Xn(t), n = t; e && (n.credential = e, n.tenantId = r.tenantId || void 0, n.email = r.email || void 0, n.phoneNumber = r.phoneNumber || void 0) } }(e, t), t }).then(e => { const t = e.user; return { operationType: e.operationType, credential: (n = e, Xn(n)), additionalUserInfo: rt(e), user: er.getOrCreate(t) }; var n }) } async function Qn(e, t) { const n = await t; return { verificationId: n.verificationId, confirm: t => Zn(e, n.confirm(t)) } } class Jn { constructor(e, t) { this.resolver = t, this.auth = e.wrapped() } get session() { return this.resolver.session } get hints() { return this.resolver.hints } resolveSignIn(e) { return Zn(Kn(this.auth), this.resolver.resolveSignIn(e)) } } class er { constructor(e) { this._delegate = e, this.multiFactor = function (e) { const t = (0, s.m9)(e); return at.has(t) || at.set(t, ot._fromUser(t)), at.get(t) }(e) } static getOrCreate(e) { return er.USER_MAP.has(e) || er.USER_MAP.set(e, new er(e)), er.USER_MAP.get(e) } delete() { return this._delegate.delete() } reload() { return this._delegate.reload() } toJSON() { return this._delegate.toJSON() } getIdTokenResult(e) { return this._delegate.getIdTokenResult(e) } getIdToken(e) { return this._delegate.getIdToken(e) } linkAndRetrieveDataWithCredential(e) { return this.linkWithCredential(e) } async linkWithCredential(e) { return Zn(this.auth, ze(this._delegate, e)) } async linkWithPhoneNumber(e, t) { return Qn(this.auth, async function (e, t, n) { const r = (0, s.m9)(e); await Ve(!1, r, "phone"); const i = await Bt(r.auth, t, (0, s.m9)(n)); return new $t(i, e => ze(r, e)) }(this._delegate, e, t)) } async linkWithPopup(e) { return Zn(this.auth, async function (e, t, n) { const r = (0, s.m9)(e); g(r.auth, t, Se); const i = Ut(r.auth, n); return new Yt(r.auth, "linkViaPopup", t, i, r).executeNotNull() }(this._delegate, e, Yn)) } async linkWithRedirect(e) { return await Hn(le(this.auth)), function (e, t, n) { return async function (e, t, n) { const r = (0, s.m9)(e); g(r.auth, t, Se); const i = Ut(r.auth, n); await Ve(!1, r, t.providerId), await Zt(i, r.auth); const o = await tn(r); return i._openRedirect(r.auth, t, "linkViaRedirect", o) }(e, t, n) }(this._delegate, e, Yn) } reauthenticateAndRetrieveDataWithCredential(e) { return this.reauthenticateWithCredential(e) } async reauthenticateWithCredential(e) { return Zn(this.auth, He(this._delegate, e)) } reauthenticateWithPhoneNumber(e, t) { return Qn(this.auth, async function (e, t, n) { const r = (0, s.m9)(e), i = await Bt(r.auth, t, (0, s.m9)(n)); return new $t(i, e => He(r, e)) }(this._delegate, e, t)) } reauthenticateWithPopup(e) { return Zn(this.auth, async function (e, t, n) { const r = (0, s.m9)(e); g(r.auth, t, Se); const i = Ut(r.auth, n); return new Yt(r.auth, "reauthViaPopup", t, i, r).executeNotNull() }(this._delegate, e, Yn)) } async reauthenticateWithRedirect(e) { return await Hn(le(this.auth)), function (e, t, n) { return async function (e, t, n) { const r = (0, s.m9)(e); g(r.auth, t, Se); const i = Ut(r.auth, n); await Zt(i, r.auth); const o = await tn(r); return i._openRedirect(r.auth, t, "reauthViaRedirect", o) }(e, t, n) }(this._delegate, e, Yn) } sendEmailVerification(e) { return async function (e, t) { const n = (0, s.m9)(e), r = { requestType: "VERIFY_EMAIL", idToken: await e.getIdToken() }; t && Ye(n.auth, r, t); const { email: i } = await async function (e, t) { return ge(e, t) }(n.auth, r); i !== e.email && await e.reload() }(this._delegate, e) } async unlink(e) { return await async function (e, t) { const n = (0, s.m9)(e); await Ve(!0, n, t); const { providerUserInfo: r } = await async function (e, t) { return R(e, "POST", "/v1/accounts:update", t) }(n.auth, { idToken: await n.getIdToken(), deleteProvider: [t] }), i = $e(r || []); return n.providerData = n.providerData.filter(e => i.has(e.providerId)), i.has("phone") || (n.phoneNumber = null), await n.auth._persistUserIfCurrent(n), n }(this._delegate, e), this } updateEmail(e) { return function (e, t) { return Xe((0, s.m9)(e), t, null) }(this._delegate, e) } updatePassword(e) { return function (e, t) { return Xe((0, s.m9)(e), null, t) }(this._delegate, e) } updatePhoneNumber(e) { return async function (e, t) { await Be((0, s.m9)(e), t) }(this._delegate, e) } updateProfile(e) { return async function (e, { displayName: t, photoURL: n }) { if (void 0 === t && void 0 === n) return; const r = (0, s.m9)(e), i = { idToken: await r.getIdToken(), displayName: t, photoUrl: n, returnSecureToken: !0 }, o = await U(r, async function (e, t) { return R(e, "POST", "/v1/accounts:update", t) }(r.auth, i)); r.displayName = o.displayName || null, r.photoURL = o.photoUrl || null; const a = r.providerData.find(({ providerId: e }) => "password" === e); a && (a.displayName = r.displayName, a.photoURL = r.photoURL), await r._updateTokensIfNecessary(o) }(this._delegate, e) } verifyBeforeUpdateEmail(e, t) { return async function (e, t, n) { const r = (0, s.m9)(e), i = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: await e.getIdToken(), newEmail: t }; n && Ye(r.auth, i, n); const { email: o } = await async function (e, t) { return ge(e, t) }(r.auth, i); o !== e.email && await e.reload() }(this._delegate, e, t) } get emailVerified() { return this._delegate.emailVerified } get isAnonymous() { return this._delegate.isAnonymous } get metadata() { return this._delegate.metadata } get phoneNumber() { return this._delegate.phoneNumber } get providerData() { return this._delegate.providerData } get refreshToken() { return this._delegate.refreshToken } get tenantId() { return this._delegate.tenantId } get displayName() { return this._delegate.displayName } get email() { return this._delegate.email } get photoURL() { return this._delegate.photoURL } get providerId() { return this._delegate.providerId } get uid() { return this._delegate.uid } get auth() { return this._delegate.auth } } er.USER_MAP = new WeakMap; const tr = v; let nr = (() => { class e { constructor(e, t) { if (this.app = e, t.isInitialized()) return this._delegate = t.getImmediate(), void this.linkUnderlyingAuth(); const { apiKey: n } = e.options; tr(n, "invalid-api-key", { appName: e.name }), tr(n, "invalid-api-key", { appName: e.name }); const r = "undefined" != typeof window ? Yn : void 0; this._delegate = t.initialize({ options: { persistence: sr(n, e.name), popupRedirectResolver: r } }), this._delegate._updateErrorMap(l), this.linkUnderlyingAuth() } get emulatorConfig() { return this._delegate.emulatorConfig } get currentUser() { return this._delegate.currentUser ? er.getOrCreate(this._delegate.currentUser) : null } get languageCode() { return this._delegate.languageCode } set languageCode(e) { this._delegate.languageCode = e } get settings() { return this._delegate.settings } get tenantId() { return this._delegate.tenantId } set tenantId(e) { this._delegate.tenantId = e } useDeviceLanguage() { this._delegate.useDeviceLanguage() } signOut() { return this._delegate.signOut() } useEmulator(e, t) { !function (e, t, n) { const r = le(e); v(r._canInitEmulator, r, "emulator-config-failed"), v(/^https?:\/\//.test(t), r, "invalid-emulator-scheme"); const s = !!(null == n ? void 0 : n.disableWarnings), i = he(t), { host: o, port: a } = function (e) { const t = he(e), n = /(\/\/)?([^?#/]+)/.exec(e.substr(t.length)); if (!n) return { host: "", port: null }; const r = n[2].split("@").pop() || "", s = /^(\[[^\]]+\])(:|$)/.exec(r); if (s) { const e = s[1]; return { host: e, port: de(r.substr(e.length + 1)) } } { const [e, t] = r.split(":"); return { host: e, port: de(t) } } }(t); r.config.emulator = { url: `${i}//${o}${null === a ? "" : `:${a}`}/` }, r.settings.appVerificationDisabledForTesting = !0, r.emulatorConfig = Object.freeze({ host: o, port: a, protocol: i.replace(":", ""), options: Object.freeze({ disableWarnings: s }) }), s || function () { function e() { const e = document.createElement("p"), t = e.style; e.innerText = "Running in emulator mode. Do not use with production credentials.", t.position = "fixed", t.width = "100%", t.backgroundColor = "#ffffff", t.border = ".1em solid #000000", t.color = "#b50000", t.bottom = "0px", t.left = "0px", t.margin = "0px", t.zIndex = "10000", t.textAlign = "center", e.classList.add("firebase-emulator-warning"), document.body.appendChild(e) } "undefined" != typeof console && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), "undefined" != typeof window && "undefined" != typeof document && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", e) : e()) }() }(this._delegate, e, t) } applyActionCode(e) { return async function (e, t) { await async function (e, t) { return R(e, "POST", "/v1/accounts:update", O(e, t)) }((0, s.m9)(e), { oobCode: t }) }(this._delegate, e) } checkActionCode(e) { return Ke(this._delegate, e) } confirmPasswordReset(e, t) { return async function (e, t, n) { await pe((0, s.m9)(e), { oobCode: t, newPassword: n }) }(this._delegate, e, t) } async createUserWithEmailAndPassword(e, t) { return Zn(this._delegate, async function (e, t, n) { const r = le(e), s = await Ne(r, { returnSecureToken: !0, email: t, password: n }), i = await Pe._fromIdTokenResponse(r, "signIn", s); return await r._updateCurrentUser(i.user), i }(this._delegate, e, t)) } fetchProvidersForEmail(e) { return this.fetchSignInMethodsForEmail(e) } fetchSignInMethodsForEmail(e) { return async function (e, t) { const n = { identifier: t, continueUri: S() ? C() : "http://localhost" }, { signinMethods: r } = await async function (e, t) { return R(e, "POST", "/v1/accounts:createAuthUri", O(e, t)) }((0, s.m9)(e), n); return r || [] }(this._delegate, e) } isSignInWithEmailLink(e) { return function (e, t) { const n = Ee.parseLink(t); return "EMAIL_SIGNIN" === (null == n ? void 0 : n.operation) }(0, e) } async getRedirectResult() { tr(Vn(), this._delegate, "operation-not-supported-in-this-environment"); const e = await async function (e, t) { return await le(e)._initializationPromise, en(e, t, !1) }(this._delegate, Yn); return e ? Zn(this._delegate, Promise.resolve(e)) : { credential: null, user: null } } addFrameworkForLogging(e) { !function (e, t) { le(e)._logFramework(t) }(this._delegate, e) } onAuthStateChanged(e, t, n) { const { next: r, error: s, complete: i } = rr(e, t, n); return this._delegate.onAuthStateChanged(r, s, i) } onIdTokenChanged(e, t, n) { const { next: r, error: s, complete: i } = rr(e, t, n); return this._delegate.onIdTokenChanged(r, s, i) } sendSignInLinkToEmail(e, t) { return async function (e, t, n) { const r = (0, s.m9)(e), i = { requestType: "EMAIL_SIGNIN", email: t }; v(n.handleCodeInApp, r, "argument-error"), n && Ye(r, i, n), await async function (e, t) { return ge(e, t) }(r, i) }(this._delegate, e, t) } sendPasswordResetEmail(e, t) { return async function (e, t, n) { const r = (0, s.m9)(e), i = { requestType: "PASSWORD_RESET", email: t }; n && Ye(r, i, n), await async function (e, t) { return ge(e, t) }(r, i) }(this._delegate, e, t || void 0) } async setPersistence(e) { let t; switch (function (e, t) { qn(Object.values(jn).includes(t), e, "invalid-persistence-type"), (0, s.b$)() ? qn(t !== jn.SESSION, e, "unsupported-persistence-type") : (0, s.UG)() ? qn(t === jn.NONE, e, "unsupported-persistence-type") : Bn() ? qn(t === jn.NONE || t === jn.LOCAL && (0, s.hl)(), e, "unsupported-persistence-type") : qn(t === jn.NONE || $n(), e, "unsupported-persistence-type") }(this._delegate, e), e) { case jn.SESSION: t = ht; break; case jn.LOCAL: t = await E(Tt)._isAvailable() ? Tt : ut; break; case jn.NONE: t = Y; break; default: return f("argument-error", { appName: this._delegate.name }) }return this._delegate.setPersistence(t) } signInAndRetrieveDataWithCredential(e) { return this.signInWithCredential(e) } signInAnonymously() { return Zn(this._delegate, async function (e) { var t; const n = le(e); if (await n._initializationPromise, null === (t = n.currentUser) || void 0 === t ? void 0 : t.isAnonymous) return new Pe({ user: n.currentUser, providerId: null, operationType: "signIn" }); const r = await Ne(n, { returnSecureToken: !0 }), s = await Pe._fromIdTokenResponse(n, "signIn", r, !0); return await n._updateCurrentUser(s.user), s }(this._delegate)) } signInWithCredential(e) { return Zn(this._delegate, qe(this._delegate, e)) } signInWithCustomToken(e) { return Zn(this._delegate, async function (e, t) { const n = le(e), r = await async function (e, t) { return P(e, "POST", "/v1/accounts:signInWithCustomToken", O(e, t)) }(n, { token: t, returnSecureToken: !0 }), s = await Pe._fromIdTokenResponse(n, "signIn", r); return await n._updateCurrentUser(s.user), s }(this._delegate, e)) } signInWithEmailAndPassword(e, t) { return Zn(this._delegate, function (e, t, n) { return qe((0, s.m9)(e), Ce.credential(t, n)) }(this._delegate, e, t)) } signInWithEmailLink(e, t) { return Zn(this._delegate, async function (e, t, n) { const r = (0, s.m9)(e), i = Ce.credentialWithLink(t, n || C()); return v(i._tenantId === (r.tenantId || null), r, "tenant-id-mismatch"), qe(r, i) }(this._delegate, e, t)) } signInWithPhoneNumber(e, t) { return Qn(this._delegate, async function (e, t, n) { const r = le(e), i = await Bt(r, t, (0, s.m9)(n)); return new $t(i, e => qe(r, e)) }(this._delegate, e, t)) } async signInWithPopup(e) { return tr(Vn(), this._delegate, "operation-not-supported-in-this-environment"), Zn(this._delegate, async function (e, t, n) { const r = le(e); g(e, t, Se); const s = Ut(r, n); return new Yt(r, "signInViaPopup", t, s).executeNotNull() }(this._delegate, e, Yn)) } async signInWithRedirect(e) { return tr(Vn(), this._delegate, "operation-not-supported-in-this-environment"), await Hn(this._delegate), function (e, t, n) { return async function (e, t, n) { const r = le(e); g(e, t, Se); const s = Ut(r, n); return await Zt(s, r), s._openRedirect(r, t, "signInViaRedirect") }(e, t, n) }(this._delegate, e, Yn) } updateCurrentUser(e) { return this._delegate.updateCurrentUser(e) } verifyPasswordResetCode(e) { return async function (e, t) { const { data: n } = await Ke((0, s.m9)(e), t); return n.email }(this._delegate, e) } unwrap() { return this._delegate } _delete() { return this._delegate._delete() } linkUnderlyingAuth() { this._delegate.wrapped = () => this } } return e.Persistence = jn, e })(); function rr(e, t, n) { let r = e; "function" != typeof e && ({ next: r, error: t, complete: n } = e); const s = r; return { next: e => s(e && er.getOrCreate(e)), error: t, complete: n } } function sr(e, t) { const n = function (e, t) { const n = Gn(); if (!n) return []; const r = K(zn, e, t); switch (n.getItem(r)) { case jn.NONE: return [Y]; case jn.LOCAL: return [Tt, ht]; case jn.SESSION: return [ht]; default: return [] } }(e, t); if ("undefined" == typeof self || n.includes(Tt) || n.push(Tt), "undefined" != typeof window) for (const r of [ut, ht]) n.includes(r) || n.push(r); return n.includes(Y) || n.push(Y), n } class ir { constructor() { this.providerId = "phone", this._delegate = new Vt(Kn(r.Z.auth())) } static credential(e, t) { return Vt.credential(e, t) } verifyPhoneNumber(e, t) { return this._delegate.verifyPhoneNumber(e, t) } unwrap() { return this._delegate } } ir.PHONE_SIGN_IN_METHOD = Vt.PHONE_SIGN_IN_METHOD, ir.PROVIDER_ID = Vt.PROVIDER_ID; const or = v; var ar; (ar = r.Z).INTERNAL.registerComponent(new c.wA("auth-compat", e => { const t = e.getProvider("app-compat").getImmediate(), n = e.getProvider("auth"); return new nr(t, n) }, "PUBLIC").setServiceProps({ ActionCodeInfo: { Operation: { EMAIL_SIGNIN: "EMAIL_SIGNIN", PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION", VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL", VERIFY_EMAIL: "VERIFY_EMAIL" } }, EmailAuthProvider: Ce, FacebookAuthProvider: ke, GithubAuthProvider: xe, GoogleAuthProvider: Ae, OAuthProvider: Ie, SAMLAuthProvider: Oe, PhoneAuthProvider: ir, PhoneMultiFactorGenerator: Cn, RecaptchaVerifier: class { constructor(e, t, n = r.Z.app()) { var s; or(null === (s = n.options) || void 0 === s ? void 0 : s.apiKey, "invalid-api-key", { appName: n.name }), this._delegate = new Mt(e, t, n.auth()), this.type = this._delegate.type } clear() { this._delegate.clear() } render() { return this._delegate.render() } verify() { return this._delegate.verify() } }, TwitterAuthProvider: Re, Auth: nr, AuthCredential: fe, Error: s.ZR }).setInstantiationMode("LAZY").setMultipleInstances(!1)), ar.registerVersion("@firebase/auth-compat", "0.2.10") }, 2430: e => { e.exports = function e(t, n, r) { function s(o, a) { if (!n[o]) { if (!t[o]) { if (i) return i(o, !0); var c = new Error("Cannot find module '" + o + "'"); throw c.code = "MODULE_NOT_FOUND", c } var l = n[o] = { exports: {} }; t[o][0].call(l.exports, function (e) { return s(t[o][1][e] || e) }, l, l.exports, e, t, n, r) } return n[o].exports } for (var i = void 0, o = 0; o < r.length; o++)s(r[o]); return s }({ 1: [function (e, t, n) { (function (e) { "use strict"; var n, r, s = e.MutationObserver || e.WebKitMutationObserver; if (s) { var i = 0, o = new s(u), a = e.document.createTextNode(""); o.observe(a, { characterData: !0 }), n = function () { a.data = i = ++i % 2 } } else if (e.setImmediate || void 0 === e.MessageChannel) n = "document" in e && "onreadystatechange" in e.document.createElement("script") ? function () { var t = e.document.createElement("script"); t.onreadystatechange = function () { u(), t.onreadystatechange = null, t.parentNode.removeChild(t), t = null }, e.document.documentElement.appendChild(t) } : function () { setTimeout(u, 0) }; else { var c = new e.MessageChannel; c.port1.onmessage = u, n = function () { c.port2.postMessage(0) } } var l = []; function u() { var e, t; r = !0; for (var n = l.length; n;) { for (t = l, l = [], e = -1; ++e < n;)t[e](); n = l.length } r = !1 } t.exports = function (e) { 1 !== l.push(e) || r || n() } }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, {}], 2: [function (e, t, n) { "use strict"; var r = e(1); function s() { } var i = {}, o = ["REJECTED"], a = ["FULFILLED"], c = ["PENDING"]; function l(e) { if ("function" != typeof e) throw new TypeError("resolver must be a function"); this.state = c, this.queue = [], this.outcome = void 0, e !== s && f(this, e) } function u(e, t, n) { this.promise = e, "function" == typeof t && (this.onFulfilled = t, this.callFulfilled = this.otherCallFulfilled), "function" == typeof n && (this.onRejected = n, this.callRejected = this.otherCallRejected) } function h(e, t, n) { r(function () { var r; try { r = t(n) } catch (s) { return i.reject(e, s) } r === e ? i.reject(e, new TypeError("Cannot resolve promise with itself")) : i.resolve(e, r) }) } function d(e) { var t = e && e.then; if (e && ("object" == typeof e || "function" == typeof e) && "function" == typeof t) return function () { t.apply(e, arguments) } } function f(e, t) { var n = !1; function r(t) { n || (n = !0, i.reject(e, t)) } function s(t) { n || (n = !0, i.resolve(e, t)) } var o = p(function () { t(s, r) }); "error" === o.status && r(o.value) } function p(e, t) { var n = {}; try { n.value = e(t), n.status = "success" } catch (r) { n.status = "error", n.value = r } return n } t.exports = l, l.prototype.catch = function (e) { return this.then(null, e) }, l.prototype.then = function (e, t) { if ("function" != typeof e && this.state === a || "function" != typeof t && this.state === o) return this; var n = new this.constructor(s); return this.state !== c ? h(n, this.state === a ? e : t, this.outcome) : this.queue.push(new u(n, e, t)), n }, u.prototype.callFulfilled = function (e) { i.resolve(this.promise, e) }, u.prototype.otherCallFulfilled = function (e) { h(this.promise, this.onFulfilled, e) }, u.prototype.callRejected = function (e) { i.reject(this.promise, e) }, u.prototype.otherCallRejected = function (e) { h(this.promise, this.onRejected, e) }, i.resolve = function (e, t) { var n = p(d, t); if ("error" === n.status) return i.reject(e, n.value); var r = n.value; if (r) f(e, r); else { e.state = a, e.outcome = t; for (var s = -1, o = e.queue.length; ++s < o;)e.queue[s].callFulfilled(t) } return e }, i.reject = function (e, t) { e.state = o, e.outcome = t; for (var n = -1, r = e.queue.length; ++n < r;)e.queue[n].callRejected(t); return e }, l.resolve = function (e) { return e instanceof this ? e : i.resolve(new this(s), e) }, l.reject = function (e) { var t = new this(s); return i.reject(t, e) }, l.all = function (e) { var t = this; if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array")); var n = e.length, r = !1; if (!n) return this.resolve([]); for (var o = new Array(n), a = 0, c = -1, l = new this(s); ++c < n;)u(e[c], c); return l; function u(e, s) { t.resolve(e).then(function (e) { o[s] = e, ++a !== n || r || (r = !0, i.resolve(l, o)) }, function (e) { r || (r = !0, i.reject(l, e)) }) } }, l.race = function (e) { if ("[object Array]" !== Object.prototype.toString.call(e)) return this.reject(new TypeError("must be an array")); var t = e.length, n = !1; if (!t) return this.resolve([]); for (var r = -1, o = new this(s); ++r < t;)this.resolve(e[r]).then(function (e) { n || (n = !0, i.resolve(o, e)) }, function (e) { n || (n = !0, i.reject(o, e)) }); return o } }, { 1: 1 }], 3: [function (e, t, n) { (function (t) { "use strict"; "function" != typeof t.Promise && (t.Promise = e(2)) }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) }, { 2: 2 }], 4: [function (e, t, n) { "use strict"; var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, s = function () { try { if ("undefined" != typeof indexedDB) return indexedDB; if ("undefined" != typeof webkitIndexedDB) return webkitIndexedDB; if ("undefined" != typeof mozIndexedDB) return mozIndexedDB; if ("undefined" != typeof OIndexedDB) return OIndexedDB; if ("undefined" != typeof msIndexedDB) return msIndexedDB } catch (e) { return } }(); function i(e, t) { e = e || [], t = t || {}; try { return new Blob(e, t) } catch (s) { if ("TypeError" !== s.name) throw s; for (var n = new ("undefined" != typeof BlobBuilder ? BlobBuilder : "undefined" != typeof MSBlobBuilder ? MSBlobBuilder : "undefined" != typeof MozBlobBuilder ? MozBlobBuilder : WebKitBlobBuilder), r = 0; r < e.length; r += 1)n.append(e[r]); return n.getBlob(t.type) } } "undefined" == typeof Promise && e(3); var o = Promise; function a(e, t) { t && e.then(function (e) { t(null, e) }, function (e) { t(e) }) } function c(e, t, n) { "function" == typeof t && e.then(t), "function" == typeof n && e.catch(n) } function l(e) { return "string" != typeof e && (console.warn(e + " used as a key, but it is not a string."), e = String(e)), e } function u() { if (arguments.length && "function" == typeof arguments[arguments.length - 1]) return arguments[arguments.length - 1] } var h = "local-forage-detect-blob-support", d = void 0, f = {}, p = Object.prototype.toString, m = "readonly", g = "readwrite"; function y(e) { for (var t = e.length, n = new ArrayBuffer(t), r = new Uint8Array(n), s = 0; s < t; s++)r[s] = e.charCodeAt(s); return n } function v(e) { var t = f[e.name], n = {}; n.promise = new o(function (e, t) { n.resolve = e, n.reject = t }), t.deferredOperations.push(n), t.dbReady = t.dbReady ? t.dbReady.then(function () { return n.promise }) : n.promise } function w(e) { var t = f[e.name].deferredOperations.pop(); if (t) return t.resolve(), t.promise } function b(e, t) { var n = f[e.name].deferredOperations.pop(); if (n) return n.reject(t), n.promise } function _(e, t) { return new o(function (n, r) { if (f[e.name] = f[e.name] || { forages: [], db: null, dbReady: null, deferredOperations: [] }, e.db) { if (!t) return n(e.db); v(e), e.db.close() } var i = [e.name]; t && i.push(e.version); var o = s.open.apply(s, i); t && (o.onupgradeneeded = function (t) { var n = o.result; try { n.createObjectStore(e.storeName), t.oldVersion <= 1 && n.createObjectStore(h) } catch (r) { if ("ConstraintError" !== r.name) throw r; console.warn('The database "' + e.name + '" has been upgraded from version ' + t.oldVersion + " to version " + t.newVersion + ', but the storage "' + e.storeName + '" already exists.') } }), o.onerror = function (e) { e.preventDefault(), r(o.error) }, o.onsuccess = function () { var t = o.result; t.onversionchange = function (e) { e.target.close() }, n(t), w(e) } }) } function E(e) { return _(e, !1) } function C(e) { return _(e, !0) } function S(e, t) { if (!e.db) return !0; var n = !e.db.objectStoreNames.contains(e.storeName), r = e.version > e.db.version; if (e.version < e.db.version && (e.version !== t && console.warn('The database "' + e.name + "\" can't be downgraded from version " + e.db.version + " to version " + e.version + "."), e.version = e.db.version), r || n) { if (n) { var s = e.db.version + 1; s > e.version && (e.version = s) } return !0 } return !1 } function T(e) { return i([y(atob(e.data))], { type: e.type }) } function I(e) { return e && e.__local_forage_encoded_blob } function k(e) { var t = this, n = t._initReady().then(function () { var e = f[t._dbInfo.name]; if (e && e.dbReady) return e.dbReady }); return c(n, e, e), n } function A(e, t, n, r) { void 0 === r && (r = 1); try { var s = e.db.transaction(e.storeName, t); n(null, s) } catch (i) { if (r > 0 && (!e.db || "InvalidStateError" === i.name || "NotFoundError" === i.name)) return o.resolve().then(function () { if (!e.db || "NotFoundError" === i.name && !e.db.objectStoreNames.contains(e.storeName) && e.version <= e.db.version) return e.db && (e.version = e.db.version + 1), C(e) }).then(function () { return function (e) { v(e); for (var t = f[e.name], n = t.forages, r = 0; r < n.length; r++) { var s = n[r]; s._dbInfo.db && (s._dbInfo.db.close(), s._dbInfo.db = null) } return e.db = null, E(e).then(function (t) { return e.db = t, S(e) ? C(e) : t }).then(function (r) { e.db = t.db = r; for (var s = 0; s < n.length; s++)n[s]._dbInfo.db = r }).catch(function (t) { throw b(e, t), t }) }(e).then(function () { A(e, t, n, r - 1) }) }).catch(n); n(i) } } var x = { _driver: "asyncStorage", _initStorage: function (e) { var t = this, n = { db: null }; if (e) for (var r in e) n[r] = e[r]; var s = f[n.name]; s || (f[n.name] = s = { forages: [], db: null, dbReady: null, deferredOperations: [] }), s.forages.push(t), t._initReady || (t._initReady = t.ready, t.ready = k); var i = []; function a() { return o.resolve() } for (var c = 0; c < s.forages.length; c++) { var l = s.forages[c]; l !== t && i.push(l._initReady().catch(a)) } var u = s.forages.slice(0); return o.all(i).then(function () { return n.db = s.db, E(n) }).then(function (e) { return n.db = e, S(n, t._defaultConfig.version) ? C(n) : e }).then(function (e) { n.db = s.db = e, t._dbInfo = n; for (var r = 0; r < u.length; r++) { var i = u[r]; i !== t && (i._dbInfo.db = n.db, i._dbInfo.version = n.version) } }) }, _support: function () { try { if (!s || !s.open) return !1; var e = "undefined" != typeof openDatabase && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), t = "function" == typeof fetch && -1 !== fetch.toString().indexOf("[native code"); return (!e || t) && "undefined" != typeof indexedDB && "undefined" != typeof IDBKeyRange } catch (n) { return !1 } }(), iterate: function (e, t) { var n = this, r = new o(function (t, r) { n.ready().then(function () { A(n._dbInfo, m, function (s, i) { if (s) return r(s); try { var o = i.objectStore(n._dbInfo.storeName).openCursor(), a = 1; o.onsuccess = function () { var n = o.result; if (n) { var r = n.value; I(r) && (r = T(r)); var s = e(r, n.key, a++); void 0 !== s ? t(s) : n.continue() } else t() }, o.onerror = function () { r(o.error) } } catch (c) { r(c) } }) }).catch(r) }); return a(r, t), r }, getItem: function (e, t) { var n = this; e = l(e); var r = new o(function (t, r) { n.ready().then(function () { A(n._dbInfo, m, function (s, i) { if (s) return r(s); try { var o = i.objectStore(n._dbInfo.storeName).get(e); o.onsuccess = function () { var e = o.result; void 0 === e && (e = null), I(e) && (e = T(e)), t(e) }, o.onerror = function () { r(o.error) } } catch (a) { r(a) } }) }).catch(r) }); return a(r, t), r }, setItem: function (e, t, n) { var r = this; e = l(e); var s = new o(function (n, s) { var a; r.ready().then(function () { return a = r._dbInfo, "[object Blob]" === p.call(t) ? function (e) { return "boolean" == typeof d ? o.resolve(d) : function (e) { return new o(function (t) { var n = e.transaction(h, g), r = i([""]); n.objectStore(h).put(r, "key"), n.onabort = function (e) { e.preventDefault(), e.stopPropagation(), t(!1) }, n.oncomplete = function () { var e = navigator.userAgent.match(/Chrome\/(\d+)/), n = navigator.userAgent.match(/Edge\//); t(n || !e || parseInt(e[1], 10) >= 43) } }).catch(function () { return !1 }) }(e).then(function (e) { return d = e }) }(a.db).then(function (e) { return e ? t : (n = t, new o(function (e, t) { var r = new FileReader; r.onerror = t, r.onloadend = function (t) { var r = btoa(t.target.result || ""); e({ __local_forage_encoded_blob: !0, data: r, type: n.type }) }, r.readAsBinaryString(n) })); var n }) : t }).then(function (t) { A(r._dbInfo, g, function (i, o) { if (i) return s(i); try { var a = o.objectStore(r._dbInfo.storeName); null === t && (t = void 0); var c = a.put(t, e); o.oncomplete = function () { void 0 === t && (t = null), n(t) }, o.onabort = o.onerror = function () { s(c.error ? c.error : c.transaction.error) } } catch (l) { s(l) } }) }).catch(s) }); return a(s, n), s }, removeItem: function (e, t) { var n = this; e = l(e); var r = new o(function (t, r) { n.ready().then(function () { A(n._dbInfo, g, function (s, i) { if (s) return r(s); try { var o = i.objectStore(n._dbInfo.storeName).delete(e); i.oncomplete = function () { t() }, i.onerror = function () { r(o.error) }, i.onabort = function () { r(o.error ? o.error : o.transaction.error) } } catch (a) { r(a) } }) }).catch(r) }); return a(r, t), r }, clear: function (e) { var t = this, n = new o(function (e, n) { t.ready().then(function () { A(t._dbInfo, g, function (r, s) { if (r) return n(r); try { var i = s.objectStore(t._dbInfo.storeName).clear(); s.oncomplete = function () { e() }, s.onabort = s.onerror = function () { n(i.error ? i.error : i.transaction.error) } } catch (o) { n(o) } }) }).catch(n) }); return a(n, e), n }, length: function (e) { var t = this, n = new o(function (e, n) { t.ready().then(function () { A(t._dbInfo, m, function (r, s) { if (r) return n(r); try { var i = s.objectStore(t._dbInfo.storeName).count(); i.onsuccess = function () { e(i.result) }, i.onerror = function () { n(i.error) } } catch (o) { n(o) } }) }).catch(n) }); return a(n, e), n }, key: function (e, t) { var n = this, r = new o(function (t, r) { e < 0 ? t(null) : n.ready().then(function () { A(n._dbInfo, m, function (s, i) { if (s) return r(s); try { var o = i.objectStore(n._dbInfo.storeName), a = !1, c = o.openKeyCursor(); c.onsuccess = function () { var n = c.result; n ? 0 === e || a ? t(n.key) : (a = !0, n.advance(e)) : t(null) }, c.onerror = function () { r(c.error) } } catch (l) { r(l) } }) }).catch(r) }); return a(r, t), r }, keys: function (e) { var t = this, n = new o(function (e, n) { t.ready().then(function () { A(t._dbInfo, m, function (r, s) { if (r) return n(r); try { var i = s.objectStore(t._dbInfo.storeName).openKeyCursor(), o = []; i.onsuccess = function () { var t = i.result; t ? (o.push(t.key), t.continue()) : e(o) }, i.onerror = function () { n(i.error) } } catch (a) { n(a) } }) }).catch(n) }); return a(n, e), n }, dropInstance: function (e, t) { t = u.apply(this, arguments); var n = this.config(); (e = "function" != typeof e && e || {}).name || (e.name = e.name || n.name, e.storeName = e.storeName || n.storeName); var r, i = this; if (e.name) { var c = e.name === n.name && i._dbInfo.db ? o.resolve(i._dbInfo.db) : E(e).then(function (t) { var n = f[e.name], r = n.forages; n.db = t; for (var s = 0; s < r.length; s++)r[s]._dbInfo.db = t; return t }); r = c.then(e.storeName ? function (t) { if (t.objectStoreNames.contains(e.storeName)) { var n = t.version + 1; v(e); var r = f[e.name], i = r.forages; t.close(); for (var a = 0; a < i.length; a++) { var c = i[a]; c._dbInfo.db = null, c._dbInfo.version = n } return new o(function (t, r) { var i = s.open(e.name, n); i.onerror = function (e) { i.result.close(), r(e) }, i.onupgradeneeded = function () { i.result.deleteObjectStore(e.storeName) }, i.onsuccess = function () { var e = i.result; e.close(), t(e) } }).then(function (e) { r.db = e; for (var t = 0; t < i.length; t++) { var n = i[t]; n._dbInfo.db = e, w(n._dbInfo) } }).catch(function (t) { throw (b(e, t) || o.resolve()).catch(function () { }), t }) } } : function (t) { v(e); var n = f[e.name], r = n.forages; t.close(); for (var i = 0; i < r.length; i++)r[i]._dbInfo.db = null; return new o(function (t, n) { var r = s.deleteDatabase(e.name); r.onerror = function () { var e = r.result; e && e.close(), n(r.error) }, r.onblocked = function () { console.warn('dropInstance blocked for database "' + e.name + '" until all open connections are closed') }, r.onsuccess = function () { var e = r.result; e && e.close(), t(e) } }).then(function (e) { n.db = e; for (var t = 0; t < r.length; t++)w(r[t]._dbInfo) }).catch(function (t) { throw (b(e, t) || o.resolve()).catch(function () { }), t }) }) } else r = o.reject("Invalid arguments"); return a(r, t), r } }, D = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", O = /^~~local_forage_type~([^~]+)~/, R = "__lfsc__:", N = R.length, P = "arbf", F = "blob", L = "si08", M = "ui08", $ = "uic8", B = "si16", V = "si32", U = "ur16", j = "ui32", q = "fl32", z = "fl64", H = N + P.length, G = Object.prototype.toString; function W(e) { var t, n, r, s, i, o = .75 * e.length, a = e.length, c = 0; "=" === e[e.length - 1] && (o--, "=" === e[e.length - 2] && o--); var l = new ArrayBuffer(o), u = new Uint8Array(l); for (t = 0; t < a; t += 4)n = D.indexOf(e[t]), r = D.indexOf(e[t + 1]), s = D.indexOf(e[t + 2]), i = D.indexOf(e[t + 3]), u[c++] = n << 2 | r >> 4, u[c++] = (15 & r) << 4 | s >> 2, u[c++] = (3 & s) << 6 | 63 & i; return l } function Y(e) { var t, n = new Uint8Array(e), r = ""; for (t = 0; t < n.length; t += 3)r += D[n[t] >> 2], r += D[(3 & n[t]) << 4 | n[t + 1] >> 4], r += D[(15 & n[t + 1]) << 2 | n[t + 2] >> 6], r += D[63 & n[t + 2]]; return n.length % 3 == 2 ? r = r.substring(0, r.length - 1) + "=" : n.length % 3 == 1 && (r = r.substring(0, r.length - 2) + "=="), r } var K = { serialize: function (e, t) { var n = ""; if (e && (n = G.call(e)), e && ("[object ArrayBuffer]" === n || e.buffer && "[object ArrayBuffer]" === G.call(e.buffer))) { var r, s = R; e instanceof ArrayBuffer ? (r = e, s += P) : (r = e.buffer, "[object Int8Array]" === n ? s += L : "[object Uint8Array]" === n ? s += M : "[object Uint8ClampedArray]" === n ? s += $ : "[object Int16Array]" === n ? s += B : "[object Uint16Array]" === n ? s += U : "[object Int32Array]" === n ? s += V : "[object Uint32Array]" === n ? s += j : "[object Float32Array]" === n ? s += q : "[object Float64Array]" === n ? s += z : t(new Error("Failed to get type for BinaryArray"))), t(s + Y(r)) } else if ("[object Blob]" === n) { var i = new FileReader; i.onload = function () { var n = "~~local_forage_type~" + e.type + "~" + Y(this.result); t("__lfsc__:blob" + n) }, i.readAsArrayBuffer(e) } else try { t(JSON.stringify(e)) } catch (o) { console.error("Couldn't convert value into a JSON string: ", e), t(null, o) } }, deserialize: function (e) { if (e.substring(0, N) !== R) return JSON.parse(e); var t, n = e.substring(H), r = e.substring(N, H); if (r === F && O.test(n)) { var s = n.match(O); t = s[1], n = n.substring(s[0].length) } var o = W(n); switch (r) { case P: return o; case F: return i([o], { type: t }); case L: return new Int8Array(o); case M: return new Uint8Array(o); case $: return new Uint8ClampedArray(o); case B: return new Int16Array(o); case U: return new Uint16Array(o); case V: return new Int32Array(o); case j: return new Uint32Array(o); case q: return new Float32Array(o); case z: return new Float64Array(o); default: throw new Error("Unkown type: " + r) } }, stringToBuffer: W, bufferToString: Y }; function X(e, t, n, r) { e.executeSql("CREATE TABLE IF NOT EXISTS " + t.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], n, r) } function Z(e, t, n, r, s, i) { e.executeSql(n, r, s, function (e, o) { o.code === o.SYNTAX_ERR ? e.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [t.storeName], function (e, a) { a.rows.length ? i(e, o) : X(e, t, function () { e.executeSql(n, r, s, i) }, i) }, i) : i(e, o) }, i) } function Q(e, t, n, r) { var s = this; e = l(e); var i = new o(function (i, o) { s.ready().then(function () { void 0 === t && (t = null); var a = t, c = s._dbInfo; c.serializer.serialize(t, function (t, l) { l ? o(l) : c.db.transaction(function (n) { Z(n, c, "INSERT OR REPLACE INTO " + c.storeName + " (key, value) VALUES (?, ?)", [e, t], function () { i(a) }, function (e, t) { o(t) }) }, function (t) { if (t.code === t.QUOTA_ERR) { if (r > 0) return void i(Q.apply(s, [e, a, n, r - 1])); o(t) } }) }) }).catch(o) }); return a(i, n), i } function J(e) { return new o(function (t, n) { e.transaction(function (r) { r.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function (n, r) { for (var s = [], i = 0; i < r.rows.length; i++)s.push(r.rows.item(i).name); t({ db: e, storeNames: s }) }, function (e, t) { n(t) }) }, function (e) { n(e) }) }) } var ee = { _driver: "webSQLStorage", _initStorage: function (e) { var t = this, n = { db: null }; if (e) for (var r in e) n[r] = "string" != typeof e[r] ? e[r].toString() : e[r]; var s = new o(function (e, r) { try { n.db = openDatabase(n.name, String(n.version), n.description, n.size) } catch (s) { return r(s) } n.db.transaction(function (s) { X(s, n, function () { t._dbInfo = n, e() }, function (e, t) { r(t) }) }, r) }); return n.serializer = K, s }, _support: "function" == typeof openDatabase, iterate: function (e, t) { var n = this, r = new o(function (t, r) { n.ready().then(function () { var s = n._dbInfo; s.db.transaction(function (n) { Z(n, s, "SELECT * FROM " + s.storeName, [], function (n, r) { for (var i = r.rows, o = i.length, a = 0; a < o; a++) { var c = i.item(a), l = c.value; if (l && (l = s.serializer.deserialize(l)), void 0 !== (l = e(l, c.key, a + 1))) return void t(l) } t() }, function (e, t) { r(t) }) }) }).catch(r) }); return a(r, t), r }, getItem: function (e, t) { var n = this; e = l(e); var r = new o(function (t, r) { n.ready().then(function () { var s = n._dbInfo; s.db.transaction(function (n) { Z(n, s, "SELECT * FROM " + s.storeName + " WHERE key = ? LIMIT 1", [e], function (e, n) { var r = n.rows.length ? n.rows.item(0).value : null; r && (r = s.serializer.deserialize(r)), t(r) }, function (e, t) { r(t) }) }) }).catch(r) }); return a(r, t), r }, setItem: function (e, t, n) { return Q.apply(this, [e, t, n, 1]) }, removeItem: function (e, t) { var n = this; e = l(e); var r = new o(function (t, r) { n.ready().then(function () { var s = n._dbInfo; s.db.transaction(function (n) { Z(n, s, "DELETE FROM " + s.storeName + " WHERE key = ?", [e], function () { t() }, function (e, t) { r(t) }) }) }).catch(r) }); return a(r, t), r }, clear: function (e) { var t = this, n = new o(function (e, n) { t.ready().then(function () { var r = t._dbInfo; r.db.transaction(function (t) { Z(t, r, "DELETE FROM " + r.storeName, [], function () { e() }, function (e, t) { n(t) }) }) }).catch(n) }); return a(n, e), n }, length: function (e) { var t = this, n = new o(function (e, n) { t.ready().then(function () { var r = t._dbInfo; r.db.transaction(function (t) { Z(t, r, "SELECT COUNT(key) as c FROM " + r.storeName, [], function (t, n) { var r = n.rows.item(0).c; e(r) }, function (e, t) { n(t) }) }) }).catch(n) }); return a(n, e), n }, key: function (e, t) { var n = this, r = new o(function (t, r) { n.ready().then(function () { var s = n._dbInfo; s.db.transaction(function (n) { Z(n, s, "SELECT key FROM " + s.storeName + " WHERE id = ? LIMIT 1", [e + 1], function (e, n) { var r = n.rows.length ? n.rows.item(0).key : null; t(r) }, function (e, t) { r(t) }) }) }).catch(r) }); return a(r, t), r }, keys: function (e) { var t = this, n = new o(function (e, n) { t.ready().then(function () { var r = t._dbInfo; r.db.transaction(function (t) { Z(t, r, "SELECT key FROM " + r.storeName, [], function (t, n) { for (var r = [], s = 0; s < n.rows.length; s++)r.push(n.rows.item(s).key); e(r) }, function (e, t) { n(t) }) }) }).catch(n) }); return a(n, e), n }, dropInstance: function (e, t) { t = u.apply(this, arguments); var n = this.config(); (e = "function" != typeof e && e || {}).name || (e.name = e.name || n.name, e.storeName = e.storeName || n.storeName); var r, s = this; return a(r = e.name ? new o(function (t) { var r; r = e.name === n.name ? s._dbInfo.db : openDatabase(e.name, "", "", 0), t(e.storeName ? { db: r, storeNames: [e.storeName] } : J(r)) }).then(function (e) { return new o(function (t, n) { e.db.transaction(function (r) { function s(e) { return new o(function (t, n) { r.executeSql("DROP TABLE IF EXISTS " + e, [], function () { t() }, function (e, t) { n(t) }) }) } for (var i = [], a = 0, c = e.storeNames.length; a < c; a++)i.push(s(e.storeNames[a])); o.all(i).then(function () { t() }).catch(function (e) { n(e) }) }, function (e) { n(e) }) }) }) : o.reject("Invalid arguments"), t), r } }; function te(e, t) { var n = e.name + "/"; return e.storeName !== t.storeName && (n += e.storeName + "/"), n } var ne = { _driver: "localStorageWrapper", _initStorage: function (e) { var t = {}; if (e) for (var n in e) t[n] = e[n]; return t.keyPrefix = te(e, this._defaultConfig), !function () { var e = "_localforage_support_test"; try { return localStorage.setItem(e, !0), localStorage.removeItem(e), !1 } catch (t) { return !0 } }() || localStorage.length > 0 ? (this._dbInfo = t, t.serializer = K, o.resolve()) : o.reject() }, _support: function () { try { return "undefined" != typeof localStorage && "setItem" in localStorage && !!localStorage.setItem } catch (e) { return !1 } }(), iterate: function (e, t) { var n = this, r = n.ready().then(function () { for (var t = n._dbInfo, r = t.keyPrefix, s = r.length, i = localStorage.length, o = 1, a = 0; a < i; a++) { var c = localStorage.key(a); if (0 === c.indexOf(r)) { var l = localStorage.getItem(c); if (l && (l = t.serializer.deserialize(l)), void 0 !== (l = e(l, c.substring(s), o++))) return l } } }); return a(r, t), r }, getItem: function (e, t) { var n = this; e = l(e); var r = n.ready().then(function () { var t = n._dbInfo, r = localStorage.getItem(t.keyPrefix + e); return r && (r = t.serializer.deserialize(r)), r }); return a(r, t), r }, setItem: function (e, t, n) { var r = this; e = l(e); var s = r.ready().then(function () { void 0 === t && (t = null); var n = t; return new o(function (s, i) { var o = r._dbInfo; o.serializer.serialize(t, function (t, r) { if (r) i(r); else try { localStorage.setItem(o.keyPrefix + e, t), s(n) } catch (a) { "QuotaExceededError" !== a.name && "NS_ERROR_DOM_QUOTA_REACHED" !== a.name || i(a), i(a) } }) }) }); return a(s, n), s }, removeItem: function (e, t) { var n = this; e = l(e); var r = n.ready().then(function () { localStorage.removeItem(n._dbInfo.keyPrefix + e) }); return a(r, t), r }, clear: function (e) { var t = this, n = t.ready().then(function () { for (var e = t._dbInfo.keyPrefix, n = localStorage.length - 1; n >= 0; n--) { var r = localStorage.key(n); 0 === r.indexOf(e) && localStorage.removeItem(r) } }); return a(n, e), n }, length: function (e) { var t = this.keys().then(function (e) { return e.length }); return a(t, e), t }, key: function (e, t) { var n = this, r = n.ready().then(function () { var t, r = n._dbInfo; try { t = localStorage.key(e) } catch (s) { t = null } return t && (t = t.substring(r.keyPrefix.length)), t }); return a(r, t), r }, keys: function (e) { var t = this, n = t.ready().then(function () { for (var e = t._dbInfo, n = localStorage.length, r = [], s = 0; s < n; s++) { var i = localStorage.key(s); 0 === i.indexOf(e.keyPrefix) && r.push(i.substring(e.keyPrefix.length)) } return r }); return a(n, e), n }, dropInstance: function (e, t) { if (t = u.apply(this, arguments), !(e = "function" != typeof e && e || {}).name) { var n = this.config(); e.name = e.name || n.name, e.storeName = e.storeName || n.storeName } var r, s = this; return a(r = e.name ? new o(function (t) { t(e.storeName ? te(e, s._defaultConfig) : e.name + "/") }).then(function (e) { for (var t = localStorage.length - 1; t >= 0; t--) { var n = localStorage.key(t); 0 === n.indexOf(e) && localStorage.removeItem(n) } }) : o.reject("Invalid arguments"), t), r } }, re = function (e, t) { for (var n = e.length, r = 0; r < n;) { if ((s = e[r]) === (i = t) || "number" == typeof s && "number" == typeof i && isNaN(s) && isNaN(i)) return !0; r++ } var s, i; return !1 }, se = Array.isArray || function (e) { return "[object Array]" === Object.prototype.toString.call(e) }, ie = {}, oe = {}, ae = { INDEXEDDB: x, WEBSQL: ee, LOCALSTORAGE: ne }, ce = [ae.INDEXEDDB._driver, ae.WEBSQL._driver, ae.LOCALSTORAGE._driver], le = ["dropInstance"], ue = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(le), he = { description: "", driver: ce.slice(), name: "localforage", size: 4980736, storeName: "keyvaluepairs", version: 1 }; function de(e, t) { e[t] = function () { var n = arguments; return e.ready().then(function () { return e[t].apply(e, n) }) } } function fe() { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; if (t) for (var n in t) t.hasOwnProperty(n) && (arguments[0][n] = se(t[n]) ? t[n].slice() : t[n]) } return arguments[0] } var pe = new (function () { function e(t) { for (var n in function (e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this, e), ae) if (ae.hasOwnProperty(n)) { var r = ae[n], s = r._driver; this[n] = s, ie[s] || this.defineDriver(r) } this._defaultConfig = fe({}, he), this._config = fe({}, this._defaultConfig, t), this._driverSet = null, this._initDriver = null, this._ready = !1, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function () { }) } return e.prototype.config = function (e) { if ("object" === (void 0 === e ? "undefined" : r(e))) { if (this._ready) return new Error("Can't call config() after localforage has been used."); for (var t in e) { if ("storeName" === t && (e[t] = e[t].replace(/\W/g, "_")), "version" === t && "number" != typeof e[t]) return new Error("Database version must be a number."); this._config[t] = e[t] } return !("driver" in e) || !e.driver || this.setDriver(this._config.driver) } return "string" == typeof e ? this._config[e] : this._config }, e.prototype.defineDriver = function (e, t, n) { var r = new o(function (t, n) { try { var r = e._driver, s = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver"); if (!e._driver) return void n(s); for (var i = ue.concat("_initStorage"), c = 0, l = i.length; c < l; c++) { var u = i[c]; if ((!re(le, u) || e[u]) && "function" != typeof e[u]) return void n(s) } !function () { for (var t = function (e) { return function () { var t = new Error("Method " + e + " is not implemented by the current driver"), n = o.reject(t); return a(n, arguments[arguments.length - 1]), n } }, n = 0, r = le.length; n < r; n++) { var s = le[n]; e[s] || (e[s] = t(s)) } }(); var h = function (n) { ie[r] && console.info("Redefining LocalForage driver: " + r), ie[r] = e, oe[r] = n, t() }; "_support" in e ? e._support && "function" == typeof e._support ? e._support().then(h, n) : h(!!e._support) : h(!0) } catch (d) { n(d) } }); return c(r, t, n), r }, e.prototype.driver = function () { return this._driver || null }, e.prototype.getDriver = function (e, t, n) { var r = ie[e] ? o.resolve(ie[e]) : o.reject(new Error("Driver not found.")); return c(r, t, n), r }, e.prototype.getSerializer = function (e) { var t = o.resolve(K); return c(t, e), t }, e.prototype.ready = function (e) { var t = this, n = t._driverSet.then(function () { return null === t._ready && (t._ready = t._initDriver()), t._ready }); return c(n, e, e), n }, e.prototype.setDriver = function (e, t, n) { var r = this; se(e) || (e = [e]); var s = this._getSupportedDrivers(e); function i() { r._config.driver = r.driver() } function a(e) { return r._extend(e), i(), r._ready = r._initStorage(r._config), r._ready } var l = null !== this._driverSet ? this._driverSet.catch(function () { return o.resolve() }) : o.resolve(); return this._driverSet = l.then(function () { var e = s[0]; return r._dbInfo = null, r._ready = null, r.getDriver(e).then(function (e) { r._driver = e._driver, i(), r._wrapLibraryMethodsWithReady(), r._initDriver = function (e) { return function () { var t = 0; return function n() { for (; t < e.length;) { var s = e[t]; return t++, r._dbInfo = null, r._ready = null, r.getDriver(s).then(a).catch(n) } i(); var c = new Error("No available storage method found."); return r._driverSet = o.reject(c), r._driverSet }() } }(s) }) }).catch(function () { i(); var e = new Error("No available storage method found."); return r._driverSet = o.reject(e), r._driverSet }), c(this._driverSet, t, n), this._driverSet }, e.prototype.supports = function (e) { return !!oe[e] }, e.prototype._extend = function (e) { fe(this, e) }, e.prototype._getSupportedDrivers = function (e) { for (var t = [], n = 0, r = e.length; n < r; n++) { var s = e[n]; this.supports(s) && t.push(s) } return t }, e.prototype._wrapLibraryMethodsWithReady = function () { for (var e = 0, t = ue.length; e < t; e++)de(this, ue[e]) }, e.prototype.createInstance = function (t) { return new e(t) }, e }()); t.exports = pe }, { 3: 3 }] }, {}, [4])(4) }, 6215: (e, t, n) => { "use strict"; n.d(t, { X: () => i }); var r = n(9765), s = n(7971); class i extends r.xQ { constructor(e) { super(), this._value = e } get value() { return this.getValue() } _subscribe(e) { const t = super._subscribe(e); return t && !t.closed && e.next(this._value), t } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new s.N; return this._value } next(e) { super.next(this._value = e) } } }, 3098: (e, t, n) => { "use strict"; n.d(t, { P: () => o }); var r = n(9193), s = n(5917), i = n(205); class o { constructor(e, t, n) { this.kind = e, this.value = t, this.error = n, this.hasValue = "N" === e } observe(e) { switch (this.kind) { case "N": return e.next && e.next(this.value); case "E": return e.error && e.error(this.error); case "C": return e.complete && e.complete() } } do(e, t, n) { switch (this.kind) { case "N": return e && e(this.value); case "E": return t && t(this.error); case "C": return n && n() } } accept(e, t, n) { return e && "function" == typeof e.next ? this.observe(e) : this.do(e, t, n) } toObservable() { switch (this.kind) { case "N": return (0, s.of)(this.value); case "E": return (0, i._)(this.error); case "C": return (0, r.c)() }throw new Error("unexpected notification kind value") } static createNext(e) { return void 0 !== e ? new o("N", e) : o.undefinedValueNotification } static createError(e) { return new o("E", void 0, e) } static createComplete() { return o.completeNotification } } o.completeNotification = new o("C"), o.undefinedValueNotification = new o("N", void 0) }, 8891: (e, t, n) => { "use strict"; n.d(t, { y: () => l }); var r = n(7393), s = n(9181), i = n(6490), o = n(6554), a = n(4022), c = n(2494); let l = (() => { class e { constructor(e) { this._isScalar = !1, e && (this._subscribe = e) } lift(t) { const n = new e; return n.source = this, n.operator = t, n } subscribe(e, t, n) { const { operator: o } = this, a = function (e, t, n) { if (e) { if (e instanceof r.L) return e; if (e[s.b]) return e[s.b]() } return e || t || n ? new r.L(e, t, n) : new r.L(i.c) }(e, t, n); if (a.add(o ? o.call(a, this.source) : this.source || c.v.useDeprecatedSynchronousErrorHandling && !a.syncErrorThrowable ? this._subscribe(a) : this._trySubscribe(a)), c.v.useDeprecatedSynchronousErrorHandling && a.syncErrorThrowable && (a.syncErrorThrowable = !1, a.syncErrorThrown)) throw a.syncErrorValue; return a } _trySubscribe(e) { try { return this._subscribe(e) } catch (t) { c.v.useDeprecatedSynchronousErrorHandling && (e.syncErrorThrown = !0, e.syncErrorValue = t), function (e) { for (; e;) { const { closed: t, destination: n, isStopped: s } = e; if (t || s) return !1; e = n && n instanceof r.L ? n : null } return !0 }(e) ? e.error(t) : console.warn(t) } } forEach(e, t) { return new (t = u(t))((t, n) => { let r; r = this.subscribe(t => { try { e(t) } catch (s) { n(s), r && r.unsubscribe() } }, n, t) }) } _subscribe(e) { const { source: t } = this; return t && t.subscribe(e) } [o.L]() { return this } pipe(...e) { return 0 === e.length ? this : (0, a.U)(e)(this) } toPromise(e) { return new (e = u(e))((e, t) => { let n; this.subscribe(e => n = e, e => t(e), () => e(n)) }) } } return e.create = t => new e(t), e })(); function u(e) { if (e || (e = c.v.Promise || Promise), !e) throw new Error("no Promise impl found"); return e } }, 6490: (e, t, n) => { "use strict"; n.d(t, { c: () => i }); var r = n(2494), s = n(4449); const i = { closed: !0, next(e) { }, error(e) { if (r.v.useDeprecatedSynchronousErrorHandling) throw e; (0, s.z)(e) }, complete() { } } }, 9765: (e, t, n) => { "use strict"; n.d(t, { Yc: () => l, xQ: () => u }); var r = n(8891), s = n(7393), i = n(5319), o = n(7971), a = n(8858), c = n(9181); class l extends s.L { constructor(e) { super(e), this.destination = e } } let u = (() => { class e extends r.y { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [c.b]() { return new l(this) } lift(e) { const t = new h(this, this); return t.operator = e, t } next(e) { if (this.closed) throw new o.N; if (!this.isStopped) { const { observers: t } = this, n = t.length, r = t.slice(); for (let s = 0; s < n; s++)r[s].next(e) } } error(e) { if (this.closed) throw new o.N; this.hasError = !0, this.thrownError = e, this.isStopped = !0; const { observers: t } = this, n = t.length, r = t.slice(); for (let s = 0; s < n; s++)r[s].error(e); this.observers.length = 0 } complete() { if (this.closed) throw new o.N; this.isStopped = !0; const { observers: e } = this, t = e.length, n = e.slice(); for (let r = 0; r < t; r++)n[r].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(e) { if (this.closed) throw new o.N; return super._trySubscribe(e) } _subscribe(e) { if (this.closed) throw new o.N; return this.hasError ? (e.error(this.thrownError), i.w.EMPTY) : this.isStopped ? (e.complete(), i.w.EMPTY) : (this.observers.push(e), new a.W(this, e)) } asObservable() { const e = new r.y; return e.source = this, e } } return e.create = (e, t) => new h(e, t), e })(); class h extends u { constructor(e, t) { super(), this.destination = e, this.source = t } next(e) { const { destination: t } = this; t && t.next && t.next(e) } error(e) { const { destination: t } = this; t && t.error && this.destination.error(e) } complete() { const { destination: e } = this; e && e.complete && this.destination.complete() } _subscribe(e) { const { source: t } = this; return t ? this.source.subscribe(e) : i.w.EMPTY } } }, 8858: (e, t, n) => { "use strict"; n.d(t, { W: () => s }); var r = n(5319); class s extends r.w { constructor(e, t) { super(), this.subject = e, this.subscriber = t, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const e = this.subject, t = e.observers; if (this.subject = null, !t || 0 === t.length || e.isStopped || e.closed) return; const n = t.indexOf(this.subscriber); -1 !== n && t.splice(n, 1) } } }, 7393: (e, t, n) => { "use strict"; n.d(t, { L: () => l }); var r = n(9105), s = n(6490), i = n(5319), o = n(9181), a = n(2494), c = n(4449); class l extends i.w { constructor(e, t, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = s.c; break; case 1: if (!e) { this.destination = s.c; break } if ("object" == typeof e) { e instanceof l ? (this.syncErrorThrowable = e.syncErrorThrowable, this.destination = e, e.add(this)) : (this.syncErrorThrowable = !0, this.destination = new u(this, e)); break } default: this.syncErrorThrowable = !0, this.destination = new u(this, e, t, n) } } [o.b]() { return this } static create(e, t, n) { const r = new l(e, t, n); return r.syncErrorThrowable = !1, r } next(e) { this.isStopped || this._next(e) } error(e) { this.isStopped || (this.isStopped = !0, this._error(e)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(e) { this.destination.next(e) } _error(e) { this.destination.error(e), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: e } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = e, this } } class u extends l { constructor(e, t, n, i) { let o; super(), this._parentSubscriber = e; let a = this; (0, r.m)(t) ? o = t : t && (o = t.next, n = t.error, i = t.complete, t !== s.c && (a = Object.create(t), (0, r.m)(a.unsubscribe) && this.add(a.unsubscribe.bind(a)), a.unsubscribe = this.unsubscribe.bind(this))), this._context = a, this._next = o, this._error = n, this._complete = i } next(e) { if (!this.isStopped && this._next) { const { _parentSubscriber: t } = this; a.v.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? this.__tryOrSetError(t, this._next, e) && this.unsubscribe() : this.__tryOrUnsub(this._next, e) } } error(e) { if (!this.isStopped) { const { _parentSubscriber: t } = this, { useDeprecatedSynchronousErrorHandling: n } = a.v; if (this._error) n && t.syncErrorThrowable ? (this.__tryOrSetError(t, this._error, e), this.unsubscribe()) : (this.__tryOrUnsub(this._error, e), this.unsubscribe()); else if (t.syncErrorThrowable) n ? (t.syncErrorValue = e, t.syncErrorThrown = !0) : (0, c.z)(e), this.unsubscribe(); else { if (this.unsubscribe(), n) throw e; (0, c.z)(e) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: e } = this; if (this._complete) { const t = () => this._complete.call(this._context); a.v.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? (this.__tryOrSetError(e, t), this.unsubscribe()) : (this.__tryOrUnsub(t), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(e, t) { try { e.call(this._context, t) } catch (n) { if (this.unsubscribe(), a.v.useDeprecatedSynchronousErrorHandling) throw n; (0, c.z)(n) } } __tryOrSetError(e, t, n) { if (!a.v.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { t.call(this._context, n) } catch (r) { return a.v.useDeprecatedSynchronousErrorHandling ? (e.syncErrorValue = r, e.syncErrorThrown = !0, !0) : ((0, c.z)(r), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: e } = this; this._context = null, this._parentSubscriber = null, e.unsubscribe() } } }, 5319: (e, t, n) => { "use strict"; n.d(t, { w: () => a }); var r = n(9796), s = n(1555), i = n(9105); const o = (() => { function e(e) { return Error.call(this), this.message = e ? `${e.length} errors occurred during unsubscription:\n${e.map((e, t) => `${t + 1}) ${e.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = e, this } return e.prototype = Object.create(Error.prototype), e })(); class a { constructor(e) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, e && (this._ctorUnsubscribe = !0, this._unsubscribe = e) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: t, _ctorUnsubscribe: n, _unsubscribe: c, _subscriptions: u } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, t instanceof a) t.remove(this); else if (null !== t) for (let r = 0; r < t.length; ++r)t[r].remove(this); if ((0, i.m)(c)) { n && (this._unsubscribe = void 0); try { c.call(this) } catch (h) { e = h instanceof o ? l(h.errors) : [h] } } if ((0, r.k)(u)) { let t = -1, n = u.length; for (; ++t < n;) { const n = u[t]; if ((0, s.K)(n)) try { n.unsubscribe() } catch (h) { e = e || [], h instanceof o ? e = e.concat(l(h.errors)) : e.push(h) } } } if (e) throw new o(e) } add(e) { let t = e; if (!e) return a.EMPTY; switch (typeof e) { case "function": t = new a(e); case "object": if (t === this || t.closed || "function" != typeof t.unsubscribe) return t; if (this.closed) return t.unsubscribe(), t; if (!(t instanceof a)) { const e = t; t = new a, t._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: n } = t; if (null === n) t._parentOrParents = this; else if (n instanceof a) { if (n === this) return t; t._parentOrParents = [n, this] } else { if (-1 !== n.indexOf(this)) return t; n.push(this) } const r = this._subscriptions; return null === r ? this._subscriptions = [t] : r.push(t), t } remove(e) { const t = this._subscriptions; if (t) { const n = t.indexOf(e); -1 !== n && t.splice(n, 1) } } } var c; function l(e) { return e.reduce((e, t) => e.concat(t instanceof o ? t.errors : t), []) } a.EMPTY = ((c = new a).closed = !0, c) }, 2494: (e, t, n) => { "use strict"; n.d(t, { v: () => s }); let r = !1; const s = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(e) { if (e) { const e = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + e.stack) } else r && console.log("RxJS: Back to a better error behavior. Thank you. <3"); r = e }, get useDeprecatedSynchronousErrorHandling() { return r } } }, 5345: (e, t, n) => { "use strict"; n.d(t, { IY: () => o, Ds: () => a, ft: () => c }); var r = n(7393), s = n(8891), i = n(7444); class o extends r.L { constructor(e) { super(), this.parent = e } _next(e) { this.parent.notifyNext(e) } _error(e) { this.parent.notifyError(e), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class a extends r.L { notifyNext(e) { this.destination.next(e) } notifyError(e) { this.destination.error(e) } notifyComplete() { this.destination.complete() } } function c(e, t) { if (t.closed) return; if (e instanceof s.y) return e.subscribe(t); let n; try { n = (0, i.s)(e)(t) } catch (r) { t.error(r) } return n } }, 2441: (e, t, n) => { "use strict"; n.d(t, { c: () => a, N: () => c }); var r = n(9765), s = n(8891), i = n(5319), o = n(1307); class a extends s.y { constructor(e, t) { super(), this.source = e, this.subjectFactory = t, this._refCount = 0, this._isComplete = !1 } _subscribe(e) { return this.getSubject().subscribe(e) } getSubject() { const e = this._subject; return e && !e.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let e = this._connection; return e || (this._isComplete = !1, e = this._connection = new i.w, e.add(this.source.subscribe(new l(this.getSubject(), this))), e.closed && (this._connection = null, e = i.w.EMPTY)), e } refCount() { return (0, o.x)()(this) } } const c = (() => { const e = a.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: e._subscribe }, _isComplete: { value: e._isComplete, writable: !0 }, getSubject: { value: e.getSubject }, connect: { value: e.connect }, refCount: { value: e.refCount } } })(); class l extends r.Yc { constructor(e, t) { super(e), this.connectable = t } _error(e) { this._unsubscribe(), super._error(e) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const e = this.connectable; if (e) { this.connectable = null; const t = e._connection; e._refCount = 0, e._subject = null, e._connection = null, t && t.unsubscribe() } } } }, 8071: (e, t, n) => { "use strict"; n.d(t, { z: () => i }); var r = n(5917), s = n(3282); function i(...e) { return (0, s.J)(1)((0, r.of)(...e)) } }, 1439: (e, t, n) => { "use strict"; n.d(t, { P: () => o }); var r = n(8891), s = n(4402), i = n(9193); function o(e) { return new r.y(t => { let n; try { n = e() } catch (r) { return void t.error(r) } return (n ? (0, s.D)(n) : (0, i.c)()).subscribe(t) }) } }, 9193: (e, t, n) => { "use strict"; n.d(t, { E: () => s, c: () => i }); var r = n(8891); const s = new r.y(e => e.complete()); function i(e) { return e ? function (e) { return new r.y(t => e.schedule(() => t.complete())) }(e) : s } }, 4402: (e, t, n) => { "use strict"; n.d(t, { D: () => h }); var r = n(8891), s = n(7444), i = n(5319), o = n(6554), a = n(4087), c = n(377), l = n(4072), u = n(9489); function h(e, t) { return t ? function (e, t) { if (null != e) { if (function (e) { return e && "function" == typeof e[o.L] }(e)) return function (e, t) { return new r.y(n => { const r = new i.w; return r.add(t.schedule(() => { const s = e[o.L](); r.add(s.subscribe({ next(e) { r.add(t.schedule(() => n.next(e))) }, error(e) { r.add(t.schedule(() => n.error(e))) }, complete() { r.add(t.schedule(() => n.complete())) } })) })), r }) }(e, t); if ((0, l.t)(e)) return function (e, t) { return new r.y(n => { const r = new i.w; return r.add(t.schedule(() => e.then(e => { r.add(t.schedule(() => { n.next(e), r.add(t.schedule(() => n.complete())) })) }, e => { r.add(t.schedule(() => n.error(e))) }))), r }) }(e, t); if ((0, u.z)(e)) return (0, a.r)(e, t); if (function (e) { return e && "function" == typeof e[c.hZ] }(e) || "string" == typeof e) return function (e, t) { if (!e) throw new Error("Iterable cannot be null"); return new r.y(n => { const r = new i.w; let s; return r.add(() => { s && "function" == typeof s.return && s.return() }), r.add(t.schedule(() => { s = e[c.hZ](), r.add(t.schedule(function () { if (n.closed) return; let e, t; try { const n = s.next(); e = n.value, t = n.done } catch (r) { return void n.error(r) } t ? n.complete() : (n.next(e), this.schedule()) })) })), r }) }(e, t) } throw new TypeError((null !== e && typeof e || e) + " is not observable") }(e, t) : e instanceof r.y ? e : new r.y((0, s.s)(e)) } }, 6693: (e, t, n) => { "use strict"; n.d(t, { n: () => o }); var r = n(8891), s = n(5015), i = n(4087); function o(e, t) { return t ? (0, i.r)(e, t) : new r.y((0, s.V)(e)) } }, 2759: (e, t, n) => { "use strict"; n.d(t, { R: () => a }); var r = n(8891), s = n(9796), i = n(9105), o = n(8002); function a(e, t, n, l) { return (0, i.m)(n) && (l = n, n = void 0), l ? a(e, t, n).pipe((0, o.U)(e => (0, s.k)(e) ? l(...e) : l(e))) : new r.y(r => { c(e, t, function (e) { r.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : e) }, r, n) }) } function c(e, t, n, r, s) { let i; if (function (e) { return e && "function" == typeof e.addEventListener && "function" == typeof e.removeEventListener }(e)) { const r = e; e.addEventListener(t, n, s), i = () => r.removeEventListener(t, n, s) } else if (function (e) { return e && "function" == typeof e.on && "function" == typeof e.off }(e)) { const r = e; e.on(t, n), i = () => r.off(t, n) } else if (function (e) { return e && "function" == typeof e.addListener && "function" == typeof e.removeListener }(e)) { const r = e; e.addListener(t, n), i = () => r.removeListener(t, n) } else { if (!e || !e.length) throw new TypeError("Invalid event target"); for (let i = 0, o = e.length; i < o; i++)c(e[i], t, n, r, s) } r.add(i) } }, 6682: (e, t, n) => { "use strict"; n.d(t, { T: () => a }); var r = n(8891), s = n(4869), i = n(3282), o = n(6693); function a(...e) { let t = Number.POSITIVE_INFINITY, n = null, a = e[e.length - 1]; return (0, s.K)(a) ? (n = e.pop(), e.length > 1 && "number" == typeof e[e.length - 1] && (t = e.pop())) : "number" == typeof a && (t = e.pop()), null === n && 1 === e.length && e[0] instanceof r.y ? e[0] : (0, i.J)(t)((0, o.n)(e, n)) } }, 5917: (e, t, n) => { "use strict"; n.d(t, { of: () => o }); var r = n(4869), s = n(6693), i = n(4087); function o(...e) { let t = e[e.length - 1]; return (0, r.K)(t) ? (e.pop(), (0, i.r)(e, t)) : (0, s.n)(e) } }, 205: (e, t, n) => { "use strict"; n.d(t, { _: () => s }); var r = n(8891); function s(e, t) { return new r.y(t ? n => t.schedule(i, 0, { error: e, subscriber: n }) : t => t.error(e)) } function i({ error: e, subscriber: t }) { t.error(e) } }, 5304: (e, t, n) => { "use strict"; n.d(t, { K: () => s }); var r = n(5345); function s(e) { return function (t) { const n = new i(e), r = t.lift(n); return n.caught = r } } class i { constructor(e) { this.selector = e } call(e, t) { return t.subscribe(new o(e, this.selector, this.caught)) } } class o extends r.Ds { constructor(e, t, n) { super(e), this.selector = t, this.caught = n } error(e) { if (!this.isStopped) { let n; try { n = this.selector(e, this.caught) } catch (t) { return void super.error(t) } this._unsubscribeAndRecycle(); const s = new r.IY(this); this.add(s); const i = (0, r.ft)(n, s); i !== s && this.add(i) } } } }, 4612: (e, t, n) => { "use strict"; n.d(t, { b: () => s }); var r = n(9773); function s(e, t) { return (0, r.zg)(e, t, 1) } }, 5242: (e, t, n) => { "use strict"; n.d(t, { d: () => s }); var r = n(7393); function s(e = null) { return t => t.lift(new i(e)) } class i { constructor(e) { this.defaultValue = e } call(e, t) { return t.subscribe(new o(e, this.defaultValue)) } } class o extends r.L { constructor(e, t) { super(e), this.defaultValue = t, this.isEmpty = !0 } _next(e) { this.isEmpty = !1, this.destination.next(e) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } }, 7519: (e, t, n) => { "use strict"; n.d(t, { x: () => s }); var r = n(7393); function s(e, t) { return n => n.lift(new i(e, t)) } class i { constructor(e, t) { this.compare = e, this.keySelector = t } call(e, t) { return t.subscribe(new o(e, this.compare, this.keySelector)) } } class o extends r.L { constructor(e, t, n) { super(e), this.keySelector = n, this.hasKey = !1, "function" == typeof t && (this.compare = t) } compare(e, t) { return e === t } _next(e) { let t; try { const { keySelector: n } = this; t = n ? n(e) : e } catch (r) { return this.destination.error(r) } let n = !1; if (this.hasKey) try { const { compare: e } = this; n = e(this.key, t) } catch (r) { return this.destination.error(r) } else this.hasKey = !0; n || (this.key = t, this.destination.next(e)) } } }, 5435: (e, t, n) => { "use strict"; n.d(t, { h: () => s }); var r = n(7393); function s(e, t) { return function (n) { return n.lift(new i(e, t)) } } class i { constructor(e, t) { this.predicate = e, this.thisArg = t } call(e, t) { return t.subscribe(new o(e, this.predicate, this.thisArg)) } } class o extends r.L { constructor(e, t, n) { super(e), this.predicate = t, this.thisArg = n, this.count = 0 } _next(e) { let t; try { t = this.predicate.call(this.thisArg, e, this.count++) } catch (n) { return void this.destination.error(n) } t && this.destination.next(e) } } }, 8049: (e, t, n) => { "use strict"; n.d(t, { P: () => l }); var r = n(3410), s = n(5435), i = n(5257), o = n(5242), a = n(4635), c = n(4487); function l(e, t) { const n = arguments.length >= 2; return l => l.pipe(e ? (0, s.h)((t, n) => e(t, n, l)) : c.y, (0, i.q)(1), n ? (0, o.d)(t) : (0, a.T)(() => new r.K)) } }, 8002: (e, t, n) => { "use strict"; n.d(t, { U: () => s }); var r = n(7393); function s(e, t) { return function (n) { if ("function" != typeof e) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new i(e, t)) } } class i { constructor(e, t) { this.project = e, this.thisArg = t } call(e, t) { return t.subscribe(new o(e, this.project, this.thisArg)) } } class o extends r.L { constructor(e, t, n) { super(e), this.project = t, this.count = 0, this.thisArg = n || this } _next(e) { let t; try { t = this.project.call(this.thisArg, e, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(t) } } }, 3282: (e, t, n) => { "use strict"; n.d(t, { J: () => i }); var r = n(9773), s = n(4487); function i(e = Number.POSITIVE_INFINITY) { return (0, r.zg)(s.y, e) } }, 9773: (e, t, n) => { "use strict"; n.d(t, { zg: () => o }); var r = n(8002), s = n(4402), i = n(5345); function o(e, t, n = Number.POSITIVE_INFINITY) { return "function" == typeof t ? i => i.pipe(o((n, i) => (0, s.D)(e(n, i)).pipe((0, r.U)((e, r) => t(n, e, i, r))), n)) : ("number" == typeof t && (n = t), t => t.lift(new a(e, n))) } class a { constructor(e, t = Number.POSITIVE_INFINITY) { this.project = e, this.concurrent = t } call(e, t) { return t.subscribe(new c(e, this.project, this.concurrent)) } } class c extends i.Ds { constructor(e, t, n = Number.POSITIVE_INFINITY) { super(e), this.project = t, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(e) { this.active < this.concurrent ? this._tryNext(e) : this.buffer.push(e) } _tryNext(e) { let t; const n = this.index++; try { t = this.project(e, n) } catch (r) { return void this.destination.error(r) } this.active++, this._innerSub(t) } _innerSub(e) { const t = new i.IY(this), n = this.destination; n.add(t); const r = (0, i.ft)(e, t); r !== t && n.add(r) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(e) { this.destination.next(e) } notifyComplete() { const e = this.buffer; this.active--, e.length > 0 ? this._next(e.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } }, 4458: (e, t, n) => { "use strict"; n.d(t, { O: () => s }); var r = n(2441); function s(e, t) { return function (n) { let s; if (s = "function" == typeof e ? e : function () { return e }, "function" == typeof t) return n.lift(new i(s, t)); const o = Object.create(n, r.N); return o.source = n, o.subjectFactory = s, o } } class i { constructor(e, t) { this.subjectFactory = e, this.selector = t } call(e, t) { const { selector: n } = this, r = this.subjectFactory(), s = n(r).subscribe(e); return s.add(t.subscribe(r)), s } } }, 9746: (e, t, n) => { "use strict"; n.d(t, { QV: () => i, ht: () => a }); var r = n(7393), s = n(3098); function i(e, t = 0) { return function (n) { return n.lift(new o(e, t)) } } class o { constructor(e, t = 0) { this.scheduler = e, this.delay = t } call(e, t) { return t.subscribe(new a(e, this.scheduler, this.delay)) } } class a extends r.L { constructor(e, t, n = 0) { super(e), this.scheduler = t, this.delay = n } static dispatch(e) { const { notification: t, destination: n } = e; t.observe(n), this.unsubscribe() } scheduleMessage(e) { this.destination.add(this.scheduler.schedule(a.dispatch, this.delay, new c(e, this.destination))) } _next(e) { this.scheduleMessage(s.P.createNext(e)) } _error(e) { this.scheduleMessage(s.P.createError(e)), this.unsubscribe() } _complete() { this.scheduleMessage(s.P.createComplete()), this.unsubscribe() } } class c { constructor(e, t) { this.notification = e, this.destination = t } } }, 1307: (e, t, n) => { "use strict"; n.d(t, { x: () => s }); var r = n(7393); function s() { return function (e) { return e.lift(new i(e)) } } class i { constructor(e) { this.connectable = e } call(e, t) { const { connectable: n } = this; n._refCount++; const r = new o(e, n), s = t.subscribe(r); return r.closed || (r.connection = n.connect()), s } } class o extends r.L { constructor(e, t) { super(e), this.connectable = t } _unsubscribe() { const { connectable: e } = this; if (!e) return void (this.connection = null); this.connectable = null; const t = e._refCount; if (t <= 0) return void (this.connection = null); if (e._refCount = t - 1, t > 1) return void (this.connection = null); const { connection: n } = this, r = e._connection; this.connection = null, !r || n && r !== n || r.unsubscribe() } } }, 2145: (e, t, n) => { "use strict"; n.d(t, { R: () => s }); var r = n(7393); function s(e, t) { let n = !1; return arguments.length >= 2 && (n = !0), function (r) { return r.lift(new i(e, t, n)) } } class i { constructor(e, t, n = !1) { this.accumulator = e, this.seed = t, this.hasSeed = n } call(e, t) { return t.subscribe(new o(e, this.accumulator, this.seed, this.hasSeed)) } } class o extends r.L { constructor(e, t, n, r) { super(e), this.accumulator = t, this._seed = n, this.hasSeed = r, this.index = 0 } get seed() { return this._seed } set seed(e) { this.hasSeed = !0, this._seed = e } _next(e) { if (this.hasSeed) return this._tryNext(e); this.seed = e, this.destination.next(e) } _tryNext(e) { const t = this.index++; let n; try { n = this.accumulator(this.seed, e, t) } catch (r) { this.destination.error(r) } this.seed = n, this.destination.next(n) } } }, 9761: (e, t, n) => { "use strict"; n.d(t, { O: () => i }); var r = n(8071), s = n(4869); function i(...e) { const t = e[e.length - 1]; return (0, s.K)(t) ? (e.pop(), n => (0, r.z)(e, n, t)) : t => (0, r.z)(e, t) } }, 3101: (e, t, n) => { "use strict"; n.d(t, { R: () => p }); var r = n(8891); let s = 1; const i = Promise.resolve(), o = {}; function a(e) { return e in o && (delete o[e], !0) } const c = { setImmediate(e) { const t = s++; return o[t] = !0, i.then(() => a(t) && e()), t }, clearImmediate(e) { a(e) } }; var l = n(6465), u = n(6102); const h = new class extends u.v { flush(e) { this.active = !0, this.scheduled = void 0; const { actions: t } = this; let n, r = -1, s = t.length; e = e || t.shift(); do { if (n = e.execute(e.state, e.delay)) break } while (++r < s && (e = t.shift())); if (this.active = !1, n) { for (; ++r < s && (e = t.shift());)e.unsubscribe(); throw n } } }(class extends l.o { constructor(e, t) { super(e, t), this.scheduler = e, this.work = t } requestAsyncId(e, t, n = 0) { return null !== n && n > 0 ? super.requestAsyncId(e, t, n) : (e.actions.push(this), e.scheduled || (e.scheduled = c.setImmediate(e.flush.bind(e, null)))) } recycleAsyncId(e, t, n = 0) { if (null !== n && n > 0 || null === n && this.delay > 0) return super.recycleAsyncId(e, t, n); 0 === e.actions.length && (c.clearImmediate(t), e.scheduled = void 0) } }); var d = n(9796); class f extends r.y { constructor(e, t = 0, n = h) { var r; super(), this.source = e, this.delayTime = t, this.scheduler = n, ((0, d.k)(r = t) || !(r - parseFloat(r) + 1 >= 0) || t < 0) && (this.delayTime = 0), n && "function" == typeof n.schedule || (this.scheduler = h) } static create(e, t = 0, n = h) { return new f(e, t, n) } static dispatch(e) { const { source: t, subscriber: n } = e; return this.add(t.subscribe(n)) } _subscribe(e) { return this.scheduler.schedule(f.dispatch, this.delayTime, { source: this.source, subscriber: e }) } } function p(e, t = 0) { return function (n) { return n.lift(new m(e, t)) } } class m { constructor(e, t) { this.scheduler = e, this.delay = t } call(e, t) { return new f(t, this.delay, this.scheduler).subscribe(e) } } }, 3190: (e, t, n) => { "use strict"; n.d(t, { w: () => o }); var r = n(8002), s = n(4402), i = n(5345); function o(e, t) { return "function" == typeof t ? n => n.pipe(o((n, i) => (0, s.D)(e(n, i)).pipe((0, r.U)((e, r) => t(n, e, i, r))))) : t => t.lift(new a(e)) } class a { constructor(e) { this.project = e } call(e, t) { return t.subscribe(new c(e, this.project)) } } class c extends i.Ds { constructor(e, t) { super(e), this.project = t, this.index = 0 } _next(e) { let t; const n = this.index++; try { t = this.project(e, n) } catch (r) { return void this.destination.error(r) } this._innerSub(t) } _innerSub(e) { const t = this.innerSubscription; t && t.unsubscribe(); const n = new i.IY(this), r = this.destination; r.add(n), this.innerSubscription = (0, i.ft)(e, n), this.innerSubscription !== n && r.add(this.innerSubscription) } _complete() { const { innerSubscription: e } = this; e && !e.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(e) { this.destination.next(e) } } }, 5257: (e, t, n) => { "use strict"; n.d(t, { q: () => o }); var r = n(7393), s = n(7108), i = n(9193); function o(e) { return t => 0 === e ? (0, i.c)() : t.lift(new a(e)) } class a { constructor(e) { if (this.total = e, this.total < 0) throw new s.W } call(e, t) { return t.subscribe(new c(e, this.total)) } } class c extends r.L { constructor(e, t) { super(e), this.total = t, this.count = 0 } _next(e) { const t = this.total, n = ++this.count; n <= t && (this.destination.next(e), n === t && (this.destination.complete(), this.unsubscribe())) } } }, 6782: (e, t, n) => { "use strict"; n.d(t, { R: () => s }); var r = n(5345); function s(e) { return t => t.lift(new i(e)) } class i { constructor(e) { this.notifier = e } call(e, t) { const n = new o(e), s = (0, r.ft)(this.notifier, new r.IY(n)); return s && !n.seenValue ? (n.add(s), t.subscribe(n)) : n } } class o extends r.Ds { constructor(e) { super(e), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } }, 8307: (e, t, n) => { "use strict"; n.d(t, { b: () => o }); var r = n(7393), s = n(8640), i = n(9105); function o(e, t, n) { return function (r) { return r.lift(new a(e, t, n)) } } class a { constructor(e, t, n) { this.nextOrObserver = e, this.error = t, this.complete = n } call(e, t) { return t.subscribe(new c(e, this.nextOrObserver, this.error, this.complete)) } } class c extends r.L { constructor(e, t, n, r) { super(e), this._tapNext = s.Z, this._tapError = s.Z, this._tapComplete = s.Z, this._tapError = n || s.Z, this._tapComplete = r || s.Z, (0, i.m)(t) ? (this._context = this, this._tapNext = t) : t && (this._context = t, this._tapNext = t.next || s.Z, this._tapError = t.error || s.Z, this._tapComplete = t.complete || s.Z) } _next(e) { try { this._tapNext.call(this._context, e) } catch (t) { return void this.destination.error(t) } this.destination.next(e) } _error(e) { try { this._tapError.call(this._context, e) } catch (e) { return void this.destination.error(e) } this.destination.error(e) } _complete() { try { this._tapComplete.call(this._context) } catch (e) { return void this.destination.error(e) } return this.destination.complete() } } }, 4635: (e, t, n) => { "use strict"; n.d(t, { T: () => i }); var r = n(3410), s = n(7393); function i(e = c) { return t => t.lift(new o(e)) } class o { constructor(e) { this.errorFactory = e } call(e, t) { return t.subscribe(new a(e, this.errorFactory)) } } class a extends s.L { constructor(e, t) { super(e), this.errorFactory = t, this.hasValue = !1 } _next(e) { this.hasValue = !0, this.destination.next(e) } _complete() { if (this.hasValue) return this.destination.complete(); { let t; try { t = this.errorFactory() } catch (e) { t = e } this.destination.error(t) } } } function c() { return new r.K } }, 4087: (e, t, n) => { "use strict"; n.d(t, { r: () => i }); var r = n(8891), s = n(5319); function i(e, t) { return new r.y(n => { const r = new s.w; let i = 0; return r.add(t.schedule(function () { i !== e.length ? (n.next(e[i++]), n.closed || r.add(this.schedule())) : n.complete() })), r }) } }, 6465: (e, t, n) => { "use strict"; n.d(t, { o: () => i }); var r = n(5319); class s extends r.w { constructor(e, t) { super() } schedule(e, t = 0) { return this } } class i extends s { constructor(e, t) { super(e, t), this.scheduler = e, this.work = t, this.pending = !1 } schedule(e, t = 0) { if (this.closed) return this; this.state = e; const n = this.id, r = this.scheduler; return null != n && (this.id = this.recycleAsyncId(r, n, t)), this.pending = !0, this.delay = t, this.id = this.id || this.requestAsyncId(r, this.id, t), this } requestAsyncId(e, t, n = 0) { return setInterval(e.flush.bind(e, this), n) } recycleAsyncId(e, t, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return t; clearInterval(t) } execute(e, t) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(e, t); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(e, t) { let n, r = !1; try { this.work(e) } catch (s) { r = !0, n = !!s && s || new Error(s) } if (r) return this.unsubscribe(), n } _unsubscribe() { const e = this.id, t = this.scheduler, n = t.actions, r = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== r && n.splice(r, 1), null != e && (this.id = this.recycleAsyncId(t, e, null)), this.delay = null } } }, 6102: (e, t, n) => { "use strict"; n.d(t, { v: () => s }); let r = (() => { class e { constructor(t, n = e.now) { this.SchedulerAction = t, this.now = n } schedule(e, t = 0, n) { return new this.SchedulerAction(this, e).schedule(n, t) } } return e.now = () => Date.now(), e })(); class s extends r { constructor(e, t = r.now) { super(e, () => s.delegate && s.delegate !== this ? s.delegate.now() : t()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(e, t = 0, n) { return s.delegate && s.delegate !== this ? s.delegate.schedule(e, t, n) : super.schedule(e, t, n) } flush(e) { const { actions: t } = this; if (this.active) return void t.push(e); let n; this.active = !0; do { if (n = e.execute(e.state, e.delay)) break } while (e = t.shift()); if (this.active = !1, n) { for (; e = t.shift();)e.unsubscribe(); throw n } } } }, 3637: (e, t, n) => { "use strict"; n.d(t, { z: () => s, P: () => i }); var r = n(6465); const s = new (n(6102).v)(r.o), i = s }, 7771: (e, t, n) => { "use strict"; n.d(t, { c: () => o, N: () => i }); var r = n(6465), s = n(6102); const i = new class extends s.v { }(class extends r.o { constructor(e, t) { super(e, t), this.scheduler = e, this.work = t } schedule(e, t = 0) { return t > 0 ? super.schedule(e, t) : (this.delay = t, this.state = e, this.scheduler.flush(this), this) } execute(e, t) { return t > 0 || this.closed ? super.execute(e, t) : this._execute(e, t) } requestAsyncId(e, t, n = 0) { return null !== n && n > 0 || null === n && this.delay > 0 ? super.requestAsyncId(e, t, n) : e.flush(this) } }), o = i }, 377: (e, t, n) => { "use strict"; n.d(t, { hZ: () => r }); const r = "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }, 6554: (e, t, n) => { "use strict"; n.d(t, { L: () => r }); const r = "function" == typeof Symbol && Symbol.observable || "@@observable" }, 9181: (e, t, n) => { "use strict"; n.d(t, { b: () => r }); const r = "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random() }, 7108: (e, t, n) => { "use strict"; n.d(t, { W: () => r }); const r = (() => { function e() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return e.prototype = Object.create(Error.prototype), e })() }, 3410: (e, t, n) => { "use strict"; n.d(t, { K: () => r }); const r = (() => { function e() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return e.prototype = Object.create(Error.prototype), e })() }, 7971: (e, t, n) => { "use strict"; n.d(t, { N: () => r }); const r = (() => { function e() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return e.prototype = Object.create(Error.prototype), e })() }, 4449: (e, t, n) => { "use strict"; function r(e) { setTimeout(() => { throw e }, 0) } n.d(t, { z: () => r }) }, 4487: (e, t, n) => { "use strict"; function r(e) { return e } n.d(t, { y: () => r }) }, 9796: (e, t, n) => { "use strict"; n.d(t, { k: () => r }); const r = Array.isArray || (e => e && "number" == typeof e.length) }, 9489: (e, t, n) => { "use strict"; n.d(t, { z: () => r }); const r = e => e && "number" == typeof e.length && "function" != typeof e }, 9105: (e, t, n) => { "use strict"; function r(e) { return "function" == typeof e } n.d(t, { m: () => r }) }, 1555: (e, t, n) => { "use strict"; function r(e) { return null !== e && "object" == typeof e } n.d(t, { K: () => r }) }, 4072: (e, t, n) => { "use strict"; function r(e) { return !!e && "function" != typeof e.subscribe && "function" == typeof e.then } n.d(t, { t: () => r }) }, 4869: (e, t, n) => { "use strict"; function r(e) { return e && "function" == typeof e.schedule } n.d(t, { K: () => r }) }, 8640: (e, t, n) => { "use strict"; function r() { } n.d(t, { Z: () => r }) }, 4022: (e, t, n) => { "use strict"; n.d(t, { z: () => s, U: () => i }); var r = n(4487); function s(...e) { return i(e) } function i(e) { return 0 === e.length ? r.y : 1 === e.length ? e[0] : function (t) { return e.reduce((e, t) => t(e), t) } } }, 7444: (e, t, n) => { "use strict"; n.d(t, { s: () => u }); var r = n(5015), s = n(4449), i = n(377), o = n(6554), a = n(9489), c = n(4072), l = n(1555); const u = e => { if (e && "function" == typeof e[o.L]) return u = e, e => { const t = u[o.L](); if ("function" != typeof t.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return t.subscribe(e) }; if ((0, a.z)(e)) return (0, r.V)(e); if ((0, c.t)(e)) return n = e, e => (n.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, s.z), e); if (e && "function" == typeof e[i.hZ]) return t = e, e => { const n = t[i.hZ](); for (; ;) { let t; try { t = n.next() } catch (r) { return e.error(r), e } if (t.done) { e.complete(); break } if (e.next(t.value), e.closed) break } return "function" == typeof n.return && e.add(() => { n.return && n.return() }), e }; { const t = (0, l.K)(e) ? "an invalid object" : `'${e}'`; throw new TypeError(`You provided ${t} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var t, n, u } }, 5015: (e, t, n) => { "use strict"; n.d(t, { V: () => r }); const r = e => t => { for (let n = 0, r = e.length; n < r && !t.closed; n++)t.next(e[n]); t.complete() } }, 8259: function (e) { e.exports = function () { "use strict"; const e = "SweetAlert2:", t = e => e.charAt(0).toUpperCase() + e.slice(1), n = e => Array.prototype.slice.call(e), r = t => { console.warn("".concat(e, " ").concat("object" == typeof t ? t.join(" ") : t)) }, s = t => { console.error("".concat(e, " ").concat(t)) }, i = [], o = e => "function" == typeof e ? e() : e, a = e => e && "function" == typeof e.toPromise, c = e => a(e) ? e.toPromise() : Promise.resolve(e), l = e => e && Promise.resolve(e) === e, u = { title: "", titleText: "", text: "", html: "", footer: "", icon: void 0, iconColor: void 0, iconHtml: void 0, template: void 0, toast: !1, showClass: { popup: "swal2-show", backdrop: "swal2-backdrop-show", icon: "swal2-icon-show" }, hideClass: { popup: "swal2-hide", backdrop: "swal2-backdrop-hide", icon: "swal2-icon-hide" }, customClass: {}, target: "body", color: void 0, backdrop: !0, heightAuto: !0, allowOutsideClick: !0, allowEscapeKey: !0, allowEnterKey: !0, stopKeydownPropagation: !0, keydownListenerCapture: !1, showConfirmButton: !0, showDenyButton: !1, showCancelButton: !1, preConfirm: void 0, preDeny: void 0, confirmButtonText: "OK", confirmButtonAriaLabel: "", confirmButtonColor: void 0, denyButtonText: "No", denyButtonAriaLabel: "", denyButtonColor: void 0, cancelButtonText: "Cancel", cancelButtonAriaLabel: "", cancelButtonColor: void 0, buttonsStyling: !0, reverseButtons: !1, focusConfirm: !0, focusDeny: !1, focusCancel: !1, returnFocus: !0, showCloseButton: !1, closeButtonHtml: "&times;", closeButtonAriaLabel: "Close this dialog", loaderHtml: "", showLoaderOnConfirm: !1, showLoaderOnDeny: !1, imageUrl: void 0, imageWidth: void 0, imageHeight: void 0, imageAlt: "", timer: void 0, timerProgressBar: !1, width: void 0, padding: void 0, background: void 0, input: void 0, inputPlaceholder: "", inputLabel: "", inputValue: "", inputOptions: {}, inputAutoTrim: !0, inputAttributes: {}, inputValidator: void 0, returnInputValueOnDeny: !1, validationMessage: void 0, grow: !1, position: "center", progressSteps: [], currentProgressStep: void 0, progressStepsDistance: void 0, willOpen: void 0, didOpen: void 0, didRender: void 0, willClose: void 0, didClose: void 0, didDestroy: void 0, scrollbarPadding: !0 }, h = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"], d = {}, f = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"], p = e => Object.prototype.hasOwnProperty.call(u, e), m = e => -1 !== h.indexOf(e), g = e => d[e], y = e => { p(e) || r('Unknown parameter "'.concat(e, '"')) }, v = e => { f.includes(e) && r('The parameter "'.concat(e, '" is incompatible with toasts')) }, w = e => { var t, n, s; g(e) && (t = e, n = g(e), s = '"'.concat(t, '" is deprecated and will be removed in the next major release. Please use "').concat(n, '" instead.'), i.includes(s) || (i.push(s), r(s))) }, b = e => { const t = {}; for (const n in e) t[e[n]] = "swal2-" + e[n]; return t }, _ = b(["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"]), E = b(["success", "warning", "info", "question", "error"]), C = () => document.body.querySelector(".".concat(_.container)), S = e => { const t = C(); return t ? t.querySelector(e) : null }, T = e => S(".".concat(e)), I = () => T(_.popup), k = () => T(_.icon), A = () => T(_.title), x = () => T(_["html-container"]), D = () => T(_.image), O = () => T(_["progress-steps"]), R = () => T(_["validation-message"]), N = () => S(".".concat(_.actions, " .").concat(_.confirm)), P = () => S(".".concat(_.actions, " .").concat(_.deny)), F = () => S(".".concat(_.loader)), L = () => S(".".concat(_.actions, " .").concat(_.cancel)), M = () => T(_.actions), $ = () => T(_.footer), B = () => T(_["timer-progress-bar"]), V = () => T(_.close), U = () => { const e = n(I().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort((e, t) => { const n = parseInt(e.getAttribute("tabindex")), r = parseInt(t.getAttribute("tabindex")); return n > r ? 1 : n < r ? -1 : 0 }), t = n(I().querySelectorAll('\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n')).filter(e => "-1" !== e.getAttribute("tabindex")); return (e => { const t = []; for (let n = 0; n < e.length; n++)-1 === t.indexOf(e[n]) && t.push(e[n]); return t })(e.concat(t)).filter(e => ie(e)) }, j = () => !G(document.body, _["toast-shown"]) && !G(document.body, _["no-backdrop"]), q = () => I() && G(I(), _.toast), z = { previousBodyPadding: null }, H = (e, t) => { if (e.textContent = "", t) { const r = (new DOMParser).parseFromString(t, "text/html"); n(r.querySelector("head").childNodes).forEach(t => { e.appendChild(t) }), n(r.querySelector("body").childNodes).forEach(t => { e.appendChild(t) }) } }, G = (e, t) => { if (!t) return !1; const n = t.split(/\s+/); for (let r = 0; r < n.length; r++)if (!e.classList.contains(n[r])) return !1; return !0 }, W = (e, t, s) => { if (((e, t) => { n(e.classList).forEach(n => { Object.values(_).includes(n) || Object.values(E).includes(n) || Object.values(t.showClass).includes(n) || e.classList.remove(n) }) })(e, t), t.customClass && t.customClass[s]) { if ("string" != typeof t.customClass[s] && !t.customClass[s].forEach) return r("Invalid type of customClass.".concat(s, '! Expected string or iterable object, got "').concat(typeof t.customClass[s], '"')); Z(e, t.customClass[s]) } }, Y = (e, t) => { if (!t) return null; switch (t) { case "select": case "textarea": case "file": return e.querySelector(".".concat(_.popup, " > .").concat(_[t])); case "checkbox": return e.querySelector(".".concat(_.popup, " > .").concat(_.checkbox, " input")); case "radio": return e.querySelector(".".concat(_.popup, " > .").concat(_.radio, " input:checked")) || e.querySelector(".".concat(_.popup, " > .").concat(_.radio, " input:first-child")); case "range": return e.querySelector(".".concat(_.popup, " > .").concat(_.range, " input")); default: return e.querySelector(".".concat(_.popup, " > .").concat(_.input)) } }, K = e => { if (e.focus(), "file" !== e.type) { const t = e.value; e.value = "", e.value = t } }, X = (e, t, n) => { e && t && ("string" == typeof t && (t = t.split(/\s+/).filter(Boolean)), t.forEach(t => { Array.isArray(e) ? e.forEach(e => { n ? e.classList.add(t) : e.classList.remove(t) }) : n ? e.classList.add(t) : e.classList.remove(t) })) }, Z = (e, t) => { X(e, t, !0) }, Q = (e, t) => { X(e, t, !1) }, J = (e, t) => { const r = n(e.childNodes); for (let n = 0; n < r.length; n++)if (G(r[n], t)) return r[n] }, ee = (e, t, n) => { n === "".concat(parseInt(n)) && (n = parseInt(n)), n || 0 === parseInt(n) ? e.style[t] = "number" == typeof n ? "".concat(n, "px") : n : e.style.removeProperty(t) }, te = function (e) { e.style.display = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "flex" }, ne = e => { e.style.display = "none" }, re = (e, t, n, r) => { const s = e.querySelector(t); s && (s.style[n] = r) }, se = (e, t, n) => { t ? te(e, n) : ne(e) }, ie = e => !(!e || !(e.offsetWidth || e.offsetHeight || e.getClientRects().length)), oe = e => !!(e.scrollHeight > e.clientHeight), ae = e => { const t = window.getComputedStyle(e), n = parseFloat(t.getPropertyValue("animation-duration") || "0"), r = parseFloat(t.getPropertyValue("transition-duration") || "0"); return n > 0 || r > 0 }, ce = function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; const n = B(); ie(n) && (t && (n.style.transition = "none", n.style.width = "100%"), setTimeout(() => { n.style.transition = "width ".concat(e / 1e3, "s linear"), n.style.width = "0%" }, 10)) }, le = () => "undefined" == typeof window || "undefined" == typeof document, ue = {}, he = '\n <div aria-labelledby="'.concat(_.title, '" aria-describedby="').concat(_["html-container"], '" class="').concat(_.popup, '" tabindex="-1">\n   <button type="button" class="').concat(_.close, '"></button>\n   <ul class="').concat(_["progress-steps"], '"></ul>\n   <div class="').concat(_.icon, '"></div>\n   <img class="').concat(_.image, '" />\n   <h2 class="').concat(_.title, '" id="').concat(_.title, '"></h2>\n   <div class="').concat(_["html-container"], '" id="').concat(_["html-container"], '"></div>\n   <input class="').concat(_.input, '" />\n   <input type="file" class="').concat(_.file, '" />\n   <div class="').concat(_.range, '">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="').concat(_.select, '"></select>\n   <div class="').concat(_.radio, '"></div>\n   <label for="').concat(_.checkbox, '" class="').concat(_.checkbox, '">\n     <input type="checkbox" />\n     <span class="').concat(_.label, '"></span>\n   </label>\n   <textarea class="').concat(_.textarea, '"></textarea>\n   <div class="').concat(_["validation-message"], '" id="').concat(_["validation-message"], '"></div>\n   <div class="').concat(_.actions, '">\n     <div class="').concat(_.loader, '"></div>\n     <button type="button" class="').concat(_.confirm, '"></button>\n     <button type="button" class="').concat(_.deny, '"></button>\n     <button type="button" class="').concat(_.cancel, '"></button>\n   </div>\n   <div class="').concat(_.footer, '"></div>\n   <div class="').concat(_["timer-progress-bar-container"], '">\n     <div class="').concat(_["timer-progress-bar"], '"></div>\n   </div>\n </div>\n').replace(/(^|\n)\s*/g, ""), de = () => { ue.currentInstance.resetValidationMessage() }, fe = (e, t) => { e instanceof HTMLElement ? t.appendChild(e) : "object" == typeof e ? pe(e, t) : e && H(t, e) }, pe = (e, t) => { e.jquery ? me(t, e) : H(t, e.toString()) }, me = (e, t) => { if (e.textContent = "", 0 in t) for (let n = 0; n in t; n++)e.appendChild(t[n].cloneNode(!0)); else e.appendChild(t.cloneNode(!0)) }, ge = (() => { if (le()) return !1; const e = document.createElement("div"), t = { WebkitAnimation: "webkitAnimationEnd", animation: "animationend" }; for (const n in t) if (Object.prototype.hasOwnProperty.call(t, n) && void 0 !== e.style[n]) return t[n]; return !1 })(); function ye(e, n, r) { se(e, r["show".concat(t(n), "Button")], "inline-block"), H(e, r["".concat(n, "ButtonText")]), e.setAttribute("aria-label", r["".concat(n, "ButtonAriaLabel")]), e.className = _[n], W(e, r, "".concat(n, "Button")), Z(e, r["".concat(n, "ButtonClass")]) } var ve = { awaitingPromise: new WeakMap, promise: new WeakMap, innerParams: new WeakMap, domCache: new WeakMap }; const we = ["input", "file", "range", "select", "radio", "checkbox", "textarea"], be = (e, t) => { e.placeholder && !t.inputPlaceholder || (e.placeholder = t.inputPlaceholder) }, _e = (e, t, n) => { if (n.inputLabel) { e.id = _.input; const r = document.createElement("label"), s = _["input-label"]; r.setAttribute("for", e.id), r.className = s, Z(r, n.customClass.inputLabel), r.innerText = n.inputLabel, t.insertAdjacentElement("beforebegin", r) } }, Ee = e => { const t = _[e] ? _[e] : _.input; return J(I(), t) }, Ce = {}; Ce.text = Ce.email = Ce.password = Ce.number = Ce.tel = Ce.url = (e, t) => ("string" == typeof t.inputValue || "number" == typeof t.inputValue ? e.value = t.inputValue : l(t.inputValue) || r('Unexpected type of inputValue! Expected "string", "number" or "Promise", got "'.concat(typeof t.inputValue, '"')), _e(e, e, t), be(e, t), e.type = t.input, e), Ce.file = (e, t) => (_e(e, e, t), be(e, t), e), Ce.range = (e, t) => { const n = e.querySelector("input"), r = e.querySelector("output"); return n.value = t.inputValue, n.type = t.input, r.value = t.inputValue, _e(n, e, t), e }, Ce.select = (e, t) => { if (e.textContent = "", t.inputPlaceholder) { const n = document.createElement("option"); H(n, t.inputPlaceholder), n.value = "", n.disabled = !0, n.selected = !0, e.appendChild(n) } return _e(e, e, t), e }, Ce.radio = e => (e.textContent = "", e), Ce.checkbox = (e, t) => { const n = Y(I(), "checkbox"); n.value = "1", n.id = _.checkbox, n.checked = Boolean(t.inputValue); const r = e.querySelector("span"); return H(r, t.inputPlaceholder), e }, Ce.textarea = (e, t) => (e.value = t.inputValue, be(e, t), _e(e, e, t), setTimeout(() => { if ("MutationObserver" in window) { const t = parseInt(window.getComputedStyle(I()).width); new MutationObserver(() => { const n = e.offsetWidth + (r = e, parseInt(window.getComputedStyle(r).marginLeft) + parseInt(window.getComputedStyle(r).marginRight)); var r; I().style.width = n > t ? "".concat(n, "px") : null }).observe(e, { attributes: !0, attributeFilter: ["style"] }) } }), e); const Se = (e, t) => { const n = x(); W(n, t, "htmlContainer"), t.html ? (fe(t.html, n), te(n, "block")) : t.text ? (n.textContent = t.text, te(n, "block")) : ne(n), ((e, t) => { const n = I(), r = ve.innerParams.get(e), i = !r || t.input !== r.input; we.forEach(e => { const r = _[e], s = J(n, r); ((e, t) => { const n = Y(I(), e); if (n) { (e => { for (let t = 0; t < e.attributes.length; t++) { const n = e.attributes[t].name;["type", "value", "style"].includes(n) || e.removeAttribute(n) } })(n); for (const e in t) n.setAttribute(e, t[e]) } })(e, t.inputAttributes), s.className = r, i && ne(s) }), t.input && (i && (e => { if (!Ce[e.input]) return s('Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "'.concat(e.input, '"')); const t = Ee(e.input), n = Ce[e.input](t, e); te(n), setTimeout(() => { K(n) }) })(t), (e => { const t = Ee(e.input); e.customClass && Z(t, e.customClass.input) })(t)) })(e, t) }, Te = (e, t) => { for (const n in E) t.icon !== n && Q(e, E[n]); Z(e, E[t.icon]), Ae(e, t), Ie(), W(e, t, "icon") }, Ie = () => { const e = I(), t = window.getComputedStyle(e).getPropertyValue("background-color"), n = e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix"); for (let r = 0; r < n.length; r++)n[r].style.backgroundColor = t }, ke = (e, t) => { e.textContent = "", H(e, t.iconHtml ? xe(t.iconHtml) : "success" === t.icon ? '\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n' : "error" === t.icon ? '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n' : xe({ question: "?", warning: "!", info: "i" }[t.icon])) }, Ae = (e, t) => { if (t.iconColor) { e.style.color = t.iconColor, e.style.borderColor = t.iconColor; for (const n of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) re(e, n, "backgroundColor", t.iconColor); re(e, ".swal2-success-ring", "borderColor", t.iconColor) } }, xe = e => '<div class="'.concat(_["icon-content"], '">').concat(e, "</div>"), De = (e, t) => { ((e, t) => { const n = C(), r = I(); t.toast ? (ee(n, "width", t.width), r.style.width = "100%", r.insertBefore(F(), k())) : ee(r, "width", t.width), ee(r, "padding", t.padding), t.color && (r.style.color = t.color), t.background && (r.style.background = t.background), ne(R()), ((e, t) => { e.className = "".concat(_.popup, " ").concat(ie(e) ? t.showClass.popup : ""), t.toast ? (Z([document.documentElement, document.body], _["toast-shown"]), Z(e, _.toast)) : Z(e, _.modal), W(e, t, "popup"), "string" == typeof t.customClass && Z(e, t.customClass), t.icon && Z(e, _["icon-".concat(t.icon)]) })(r, t) })(0, t), ((e, t) => { const n = C(); n && (function (e, t) { "string" == typeof t ? e.style.background = t : t || Z([document.documentElement, document.body], _["no-backdrop"]) }(n, t.backdrop), function (e, t) { t in _ ? Z(e, _[t]) : (r('The "position" parameter is not valid, defaulting to "center"'), Z(e, _.center)) }(n, t.position), function (e, t) { if (t && "string" == typeof t) { const n = "grow-".concat(t); n in _ && Z(e, _[n]) } }(n, t.grow), W(n, t, "container")) })(0, t), ((e, t) => { const n = O(); if (!t.progressSteps || 0 === t.progressSteps.length) return ne(n); te(n), n.textContent = "", t.currentProgressStep >= t.progressSteps.length && r("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), t.progressSteps.forEach((e, r) => { const s = (e => { const t = document.createElement("li"); return Z(t, _["progress-step"]), H(t, e), t })(e); if (n.appendChild(s), r === t.currentProgressStep && Z(s, _["active-progress-step"]), r !== t.progressSteps.length - 1) { const e = (e => { const t = document.createElement("li"); return Z(t, _["progress-step-line"]), e.progressStepsDistance && (t.style.width = e.progressStepsDistance), t })(t); n.appendChild(e) } }) })(0, t), ((e, t) => { const n = ve.innerParams.get(e), r = k(); n && t.icon === n.icon ? (ke(r, t), Te(r, t)) : t.icon || t.iconHtml ? t.icon && -1 === Object.keys(E).indexOf(t.icon) ? (s('Unknown icon! Expected "success", "error", "warning", "info" or "question", got "'.concat(t.icon, '"')), ne(r)) : (te(r), ke(r, t), Te(r, t), Z(r, t.showClass.icon)) : ne(r) })(e, t), ((e, t) => { const n = D(); if (!t.imageUrl) return ne(n); te(n, ""), n.setAttribute("src", t.imageUrl), n.setAttribute("alt", t.imageAlt), ee(n, "width", t.imageWidth), ee(n, "height", t.imageHeight), n.className = _.image, W(n, t, "image") })(0, t), ((e, t) => { const n = A(); se(n, t.title || t.titleText, "block"), t.title && fe(t.title, n), t.titleText && (n.innerText = t.titleText), W(n, t, "title") })(0, t), ((e, t) => { const n = V(); H(n, t.closeButtonHtml), W(n, t, "closeButton"), se(n, t.showCloseButton), n.setAttribute("aria-label", t.closeButtonAriaLabel) })(0, t), Se(e, t), ((e, t) => { const n = M(), r = F(); t.showConfirmButton || t.showDenyButton || t.showCancelButton ? te(n) : ne(n), W(n, t, "actions"), function (e, t, n) { const r = N(), s = P(), i = L(); ye(r, "confirm", n), ye(s, "deny", n), ye(i, "cancel", n), function (e, t, n, r) { if (!r.buttonsStyling) return Q([e, t, n], _.styled); Z([e, t, n], _.styled), r.confirmButtonColor && (e.style.backgroundColor = r.confirmButtonColor, Z(e, _["default-outline"])), r.denyButtonColor && (t.style.backgroundColor = r.denyButtonColor, Z(t, _["default-outline"])), r.cancelButtonColor && (n.style.backgroundColor = r.cancelButtonColor, Z(n, _["default-outline"])) }(r, s, i, n), n.reverseButtons && (n.toast ? (e.insertBefore(i, r), e.insertBefore(s, r)) : (e.insertBefore(i, t), e.insertBefore(s, t), e.insertBefore(r, t))) }(n, r, t), H(r, t.loaderHtml), W(r, t, "loader") })(0, t), ((e, t) => { const n = $(); se(n, t.footer), t.footer && fe(t.footer, n), W(n, t, "footer") })(0, t), "function" == typeof t.didRender && t.didRender(I()) }, Oe = Object.freeze({ cancel: "cancel", backdrop: "backdrop", close: "close", esc: "esc", timer: "timer" }), Re = () => { n(document.body.children).forEach(e => { e.hasAttribute("data-previous-aria-hidden") ? (e.setAttribute("aria-hidden", e.getAttribute("data-previous-aria-hidden")), e.removeAttribute("data-previous-aria-hidden")) : e.removeAttribute("aria-hidden") }) }, Ne = ["swal-title", "swal-html", "swal-footer"], Pe = (e, t) => { n(e.attributes).forEach(n => { -1 === t.indexOf(n.name) && r(['Unrecognized attribute "'.concat(n.name, '" on <').concat(e.tagName.toLowerCase(), ">."), "".concat(t.length ? "Allowed attributes are: ".concat(t.join(", ")) : "To set the value, use HTML within the element.")]) }) }; var Fe = { email: (e, t) => /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid email address"), url: (e, t) => /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid URL") }; function Le(e) { (function (e) { e.inputValidator || Object.keys(Fe).forEach(t => { e.input === t && (e.inputValidator = Fe[t]) }) })(e), e.showLoaderOnConfirm && !e.preConfirm && r("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"), function (e) { (!e.target || "string" == typeof e.target && !document.querySelector(e.target) || "string" != typeof e.target && !e.target.appendChild) && (r('Target parameter is not valid, defaulting to "body"'), e.target = "body") }(e), "string" == typeof e.title && (e.title = e.title.split("\n").join("<br />")), (e => { const t = (() => { const e = C(); return !!e && (e.remove(), Q([document.documentElement, document.body], [_["no-backdrop"], _["toast-shown"], _["has-column"]]), !0) })(); if (le()) return void s("SweetAlert2 requires document to initialize"); const n = document.createElement("div"); n.className = _.container, t && Z(n, _["no-transition"]), H(n, he); const r = "string" == typeof (i = e.target) ? document.querySelector(i) : i; var i; r.appendChild(n), (e => { const t = I(); t.setAttribute("role", e.toast ? "alert" : "dialog"), t.setAttribute("aria-live", e.toast ? "polite" : "assertive"), e.toast || t.setAttribute("aria-modal", "true") })(e), (e => { "rtl" === window.getComputedStyle(e).direction && Z(C(), _.rtl) })(r), (() => { const e = I(), t = J(e, _.input), n = J(e, _.file), r = e.querySelector(".".concat(_.range, " input")), s = e.querySelector(".".concat(_.range, " output")), i = J(e, _.select), o = e.querySelector(".".concat(_.checkbox, " input")), a = J(e, _.textarea); t.oninput = de, n.onchange = de, i.onchange = de, o.onchange = de, a.oninput = de, r.oninput = () => { de(), s.value = r.value }, r.onchange = () => { de(), r.nextSibling.value = r.value } })() })(e) } class Me { constructor(e, t) { this.callback = e, this.remaining = t, this.running = !1, this.start() } start() { return this.running || (this.running = !0, this.started = new Date, this.id = setTimeout(this.callback, this.remaining)), this.remaining } stop() { return this.running && (this.running = !1, clearTimeout(this.id), this.remaining -= (new Date).getTime() - this.started.getTime()), this.remaining } increase(e) { const t = this.running; return t && this.stop(), this.remaining += e, t && this.start(), this.remaining } getTimerLeft() { return this.running && (this.stop(), this.start()), this.remaining } isRunning() { return this.running } } const $e = e => { const t = e.target, n = C(); return !(Be(e) || Ve(e) || t !== n && (oe(n) || "INPUT" === t.tagName || "TEXTAREA" === t.tagName || oe(x()) && x().contains(t))) }, Be = e => e.touches && e.touches.length && "stylus" === e.touches[0].touchType, Ve = e => e.touches && e.touches.length > 1, Ue = e => { const t = I(); if (e.target !== t) return; const n = C(); t.removeEventListener(ge, Ue), n.style.overflowY = "auto" }, je = (e, t) => { ge && ae(t) ? (e.style.overflowY = "hidden", t.addEventListener(ge, Ue)) : e.style.overflowY = "auto" }, qe = (e, t, n) => { (() => { if ((/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1) && !G(document.body, _.iosfix)) { const e = document.body.scrollTop; document.body.style.top = "".concat(-1 * e, "px"), Z(document.body, _.iosfix), (() => { const e = C(); let t; e.ontouchstart = e => { t = $e(e) }, e.ontouchmove = e => { t && (e.preventDefault(), e.stopPropagation()) } })(), (() => { const e = navigator.userAgent, t = !!e.match(/iPad/i) || !!e.match(/iPhone/i), n = !!e.match(/WebKit/i); if (t && n && !e.match(/CriOS/i)) { const e = 44; I().scrollHeight > window.innerHeight - e && (C().style.paddingBottom = "".concat(e, "px")) } })() } })(), t && "hidden" !== n && (null === z.previousBodyPadding && document.body.scrollHeight > window.innerHeight && (z.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = "".concat(z.previousBodyPadding + (() => { const e = document.createElement("div"); e.className = _["scrollbar-measure"], document.body.appendChild(e); const t = e.getBoundingClientRect().width - e.clientWidth; return document.body.removeChild(e), t })(), "px"))), setTimeout(() => { e.scrollTop = 0 }) }, ze = (e, t, n) => { Z(e, n.showClass.backdrop), t.style.setProperty("opacity", "0", "important"), te(t, "grid"), setTimeout(() => { Z(t, n.showClass.popup), t.style.removeProperty("opacity") }, 10), Z([document.documentElement, document.body], _.shown), n.heightAuto && n.backdrop && !n.toast && Z([document.documentElement, document.body], _["height-auto"]) }, He = e => { let t = I(); t || new zt, t = I(); const n = F(); q() ? ne(k()) : Ge(t, e), te(n), t.setAttribute("data-loading", !0), t.setAttribute("aria-busy", !0), t.focus() }, Ge = (e, t) => { const n = M(), r = F(); !t && ie(N()) && (t = N()), te(n), t && (ne(t), r.setAttribute("data-button-to-replace", t.className)), r.parentNode.insertBefore(r, t), Z([e, n], _.loading) }, We = { select: (e, t, n) => { const r = J(e, _.select), s = (e, t, r) => { const s = document.createElement("option"); s.value = r, H(s, t), s.selected = Ke(r, n.inputValue), e.appendChild(s) }; t.forEach(e => { const t = e[0], n = e[1]; if (Array.isArray(n)) { const e = document.createElement("optgroup"); e.label = t, e.disabled = !1, r.appendChild(e), n.forEach(t => s(e, t[1], t[0])) } else s(r, n, t) }), r.focus() }, radio: (e, t, n) => { const r = J(e, _.radio); t.forEach(e => { const t = e[0], s = e[1], i = document.createElement("input"), o = document.createElement("label"); i.type = "radio", i.name = _.radio, i.value = t, Ke(t, n.inputValue) && (i.checked = !0); const a = document.createElement("span"); H(a, s), a.className = _.label, o.appendChild(i), o.appendChild(a), r.appendChild(o) }); const s = r.querySelectorAll("input"); s.length && s[0].focus() } }, Ye = e => { const t = []; return "undefined" != typeof Map && e instanceof Map ? e.forEach((e, n) => { let r = e; "object" == typeof r && (r = Ye(r)), t.push([n, r]) }) : Object.keys(e).forEach(n => { let r = e[n]; "object" == typeof r && (r = Ye(r)), t.push([n, r]) }), t }, Ke = (e, t) => t && t.toString() === e.toString(), Xe = (e, n) => { const r = ve.innerParams.get(e); if (!r.input) return s('The "input" parameter is needed to be set when using returnInputValueOn'.concat(t(n))); const i = ((e, t) => { const n = e.getInput(); if (!n) return null; switch (t.input) { case "checkbox": return (e => e.checked ? 1 : 0)(n); case "radio": return (e => e.checked ? e.value : null)(n); case "file": return (e => e.files.length ? null !== e.getAttribute("multiple") ? e.files : e.files[0] : null)(n); default: return t.inputAutoTrim ? n.value.trim() : n.value } })(e, r); r.inputValidator ? Ze(e, i, n) : e.getInput().checkValidity() ? "deny" === n ? Qe(e, i) : tt(e, i) : (e.enableButtons(), e.showValidationMessage(r.validationMessage)) }, Ze = (e, t, n) => { const r = ve.innerParams.get(e); e.disableInput(), Promise.resolve().then(() => c(r.inputValidator(t, r.validationMessage))).then(r => { e.enableButtons(), e.enableInput(), r ? e.showValidationMessage(r) : "deny" === n ? Qe(e, t) : tt(e, t) }) }, Qe = (e, t) => { const n = ve.innerParams.get(e || void 0); n.showLoaderOnDeny && He(P()), n.preDeny ? (ve.awaitingPromise.set(e || void 0, !0), Promise.resolve().then(() => c(n.preDeny(t, n.validationMessage))).then(n => { !1 === n ? e.hideLoading() : e.closePopup({ isDenied: !0, value: void 0 === n ? t : n }) }).catch(t => et(e || void 0, t))) : e.closePopup({ isDenied: !0, value: t }) }, Je = (e, t) => { e.closePopup({ isConfirmed: !0, value: t }) }, et = (e, t) => { e.rejectPromise(t) }, tt = (e, t) => { const n = ve.innerParams.get(e || void 0); n.showLoaderOnConfirm && He(), n.preConfirm ? (e.resetValidationMessage(), ve.awaitingPromise.set(e || void 0, !0), Promise.resolve().then(() => c(n.preConfirm(t, n.validationMessage))).then(n => { ie(R()) || !1 === n ? e.hideLoading() : Je(e, void 0 === n ? t : n) }).catch(t => et(e || void 0, t))) : Je(e, t) }, nt = e => e.showConfirmButton || e.showDenyButton || e.showCancelButton || e.showCloseButton; let rt = !1; const st = () => N() && N().click(), it = (e, t, n) => { const r = U(); if (r.length) return (t += n) === r.length ? t = 0 : -1 === t && (t = r.length - 1), r[t].focus(); I().focus() }, ot = ["ArrowRight", "ArrowDown"], at = ["ArrowLeft", "ArrowUp"], ct = (e, t, n) => { if (o(n.allowEnterKey) && !t.isComposing && t.target && e.getInput() && t.target.outerHTML === e.getInput().outerHTML) { if (["textarea", "file"].includes(n.input)) return; st(), t.preventDefault() } }, lt = (e, t) => { const n = e.target, r = U(); let s = -1; for (let i = 0; i < r.length; i++)if (n === r[i]) { s = i; break } it(0, s, e.shiftKey ? -1 : 1), e.stopPropagation(), e.preventDefault() }, ut = e => { if (![N(), P(), L()].includes(document.activeElement)) return; const t = ot.includes(e) ? "nextElementSibling" : "previousElementSibling", n = document.activeElement[t]; n instanceof HTMLElement && n.focus() }, ht = (e, t, n) => { o(t.allowEscapeKey) && (e.preventDefault(), n(Oe.esc)) }, dt = e => e instanceof Element || (e => "object" == typeof e && e.jquery)(e), ft = () => { if (ue.timeout) return (() => { const e = B(), t = parseInt(window.getComputedStyle(e).width); e.style.removeProperty("transition"), e.style.width = "100%"; const n = t / parseInt(window.getComputedStyle(e).width) * 100; e.style.removeProperty("transition"), e.style.width = "".concat(n, "%") })(), ue.timeout.stop() }, pt = () => { if (ue.timeout) { const e = ue.timeout.start(); return ce(e), e } }; let mt = !1; const gt = {}, yt = e => { for (let t = e.target; t && t !== document; t = t.parentNode)for (const e in gt) { const n = t.getAttribute(e); if (n) return void gt[e].fire({ template: n }) } }; var vt = Object.freeze({ isValidParameter: p, isUpdatableParameter: m, isDeprecatedParameter: g, argsToParams: e => { const t = {}; return "object" != typeof e[0] || dt(e[0]) ? ["title", "html", "icon"].forEach((n, r) => { const i = e[r]; "string" == typeof i || dt(i) ? t[n] = i : void 0 !== i && s("Unexpected type of ".concat(n, '! Expected "string" or "Element", got ').concat(typeof i)) }) : Object.assign(t, e[0]), t }, isVisible: () => ie(I()), clickConfirm: st, clickDeny: () => P() && P().click(), clickCancel: () => L() && L().click(), getContainer: C, getPopup: I, getTitle: A, getHtmlContainer: x, getImage: D, getIcon: k, getInputLabel: () => T(_["input-label"]), getCloseButton: V, getActions: M, getConfirmButton: N, getDenyButton: P, getCancelButton: L, getLoader: F, getFooter: $, getTimerProgressBar: B, getFocusableElements: U, getValidationMessage: R, isLoading: () => I().hasAttribute("data-loading"), fire: function () { const e = this; for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)n[r] = arguments[r]; return new e(...n) }, mixin: function (e) { return class extends (this) { _main(t, n) { return super._main(t, Object.assign({}, e, n)) } } }, showLoading: He, enableLoading: He, getTimerLeft: () => ue.timeout && ue.timeout.getTimerLeft(), stopTimer: ft, resumeTimer: pt, toggleTimer: () => { const e = ue.timeout; return e && (e.running ? ft() : pt()) }, increaseTimer: e => { if (ue.timeout) { const t = ue.timeout.increase(e); return ce(t, !0), t } }, isTimerRunning: () => ue.timeout && ue.timeout.isRunning(), bindClickHandler: function () { gt[arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "data-swal-template"] = this, mt || (document.body.addEventListener("click", yt), mt = !0) } }); function wt() { const e = ve.innerParams.get(this); if (!e) return; const t = ve.domCache.get(this); ne(t.loader), q() ? e.icon && te(k()) : bt(t), Q([t.popup, t.actions], _.loading), t.popup.removeAttribute("aria-busy"), t.popup.removeAttribute("data-loading"), t.confirmButton.disabled = !1, t.denyButton.disabled = !1, t.cancelButton.disabled = !1 } const bt = e => { const t = e.popup.getElementsByClassName(e.loader.getAttribute("data-button-to-replace")); t.length ? te(t[0], "inline-block") : !ie(N()) && !ie(P()) && !ie(L()) && ne(e.actions) }; var _t = { swalPromiseResolve: new WeakMap, swalPromiseReject: new WeakMap }; function Et(e, t, n, r) { q() ? xt(e, r) : ((e => new Promise(t => { if (!e) return t(); const n = window.scrollX, r = window.scrollY; ue.restoreFocusTimeout = setTimeout(() => { ue.previousActiveElement && ue.previousActiveElement.focus ? (ue.previousActiveElement.focus(), ue.previousActiveElement = null) : document.body && document.body.focus(), t() }, 100), window.scrollTo(n, r) }))(n).then(() => xt(e, r)), ue.keydownTarget.removeEventListener("keydown", ue.keydownHandler, { capture: ue.keydownListenerCapture }), ue.keydownHandlerAdded = !1), /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? (t.setAttribute("style", "display:none !important"), t.removeAttribute("class"), t.innerHTML = "") : t.remove(), j() && (null !== z.previousBodyPadding && (document.body.style.paddingRight = "".concat(z.previousBodyPadding, "px"), z.previousBodyPadding = null), (() => { if (G(document.body, _.iosfix)) { const e = parseInt(document.body.style.top, 10); Q(document.body, _.iosfix), document.body.style.top = "", document.body.scrollTop = -1 * e } })(), Re()), Q([document.documentElement, document.body], [_.shown, _["height-auto"], _["no-backdrop"], _["toast-shown"]]) } function Ct(e) { e = It(e); const t = _t.swalPromiseResolve.get(this), n = St(this); this.isAwaitingPromise() ? e.isDismissed || (Tt(this), t(e)) : n && t(e) } const St = e => { const t = I(); if (!t) return !1; const n = ve.innerParams.get(e); if (!n || G(t, n.hideClass.popup)) return !1; Q(t, n.showClass.popup), Z(t, n.hideClass.popup); const r = C(); return Q(r, n.showClass.backdrop), Z(r, n.hideClass.backdrop), kt(e, t, n), !0 }, Tt = e => { e.isAwaitingPromise() && (ve.awaitingPromise.delete(e), ve.innerParams.get(e) || e._destroy()) }, It = e => void 0 === e ? { isConfirmed: !1, isDenied: !1, isDismissed: !0 } : Object.assign({ isConfirmed: !1, isDenied: !1, isDismissed: !1 }, e), kt = (e, t, n) => { const r = C(), s = ge && ae(t); "function" == typeof n.willClose && n.willClose(t), s ? At(e, t, r, n.returnFocus, n.didClose) : Et(e, r, n.returnFocus, n.didClose) }, At = (e, t, n, r, s) => { ue.swalCloseEventFinishedCallback = Et.bind(null, e, n, r, s), t.addEventListener(ge, function (e) { e.target === t && (ue.swalCloseEventFinishedCallback(), delete ue.swalCloseEventFinishedCallback) }) }, xt = (e, t) => { setTimeout(() => { "function" == typeof t && t.bind(e.params)(), e._destroy() }) }; function Dt(e, t, n) { const r = ve.domCache.get(e); t.forEach(e => { r[e].disabled = n }) } function Ot(e, t) { if (!e) return !1; if ("radio" === e.type) { const n = e.parentNode.parentNode.querySelectorAll("input"); for (let e = 0; e < n.length; e++)n[e].disabled = t } else e.disabled = t } const Rt = e => { e.isAwaitingPromise() ? (Nt(ve, e), ve.awaitingPromise.set(e, !0)) : (Nt(_t, e), Nt(ve, e)) }, Nt = (e, t) => { for (const n in e) e[n].delete(t) }; var Pt = Object.freeze({ hideLoading: wt, disableLoading: wt, getInput: function (e) { const t = ve.innerParams.get(e || this), n = ve.domCache.get(e || this); return n ? Y(n.popup, t.input) : null }, close: Ct, isAwaitingPromise: function () { return !!ve.awaitingPromise.get(this) }, rejectPromise: function (e) { const t = _t.swalPromiseReject.get(this); Tt(this), t && t(e) }, closePopup: Ct, closeModal: Ct, closeToast: Ct, enableButtons: function () { Dt(this, ["confirmButton", "denyButton", "cancelButton"], !1) }, disableButtons: function () { Dt(this, ["confirmButton", "denyButton", "cancelButton"], !0) }, enableInput: function () { return Ot(this.getInput(), !1) }, disableInput: function () { return Ot(this.getInput(), !0) }, showValidationMessage: function (e) { const t = ve.domCache.get(this), n = ve.innerParams.get(this); H(t.validationMessage, e), t.validationMessage.className = _["validation-message"], n.customClass && n.customClass.validationMessage && Z(t.validationMessage, n.customClass.validationMessage), te(t.validationMessage); const r = this.getInput(); r && (r.setAttribute("aria-invalid", !0), r.setAttribute("aria-describedby", _["validation-message"]), K(r), Z(r, _.inputerror)) }, resetValidationMessage: function () { const e = ve.domCache.get(this); e.validationMessage && ne(e.validationMessage); const t = this.getInput(); t && (t.removeAttribute("aria-invalid"), t.removeAttribute("aria-describedby"), Q(t, _.inputerror)) }, getProgressSteps: function () { return ve.domCache.get(this).progressSteps }, update: function (e) { const t = I(), n = ve.innerParams.get(this); if (!t || G(t, n.hideClass.popup)) return r("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup."); const s = (e => { const t = {}; return Object.keys(e).forEach(n => { m(n) ? t[n] = e[n] : r('Invalid parameter to update: "'.concat(n, '". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\n\nIf you think this parameter should be updatable, request it here: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md')) }), t })(e), i = Object.assign({}, n, s); De(this, i), ve.innerParams.set(this, i), Object.defineProperties(this, { params: { value: Object.assign({}, this.params, e), writable: !1, enumerable: !0 } }) }, _destroy: function () { const e = ve.domCache.get(this), t = ve.innerParams.get(this); var n; t ? (e.popup && ue.swalCloseEventFinishedCallback && (ue.swalCloseEventFinishedCallback(), delete ue.swalCloseEventFinishedCallback), ue.deferDisposalTimer && (clearTimeout(ue.deferDisposalTimer), delete ue.deferDisposalTimer), "function" == typeof t.didDestroy && t.didDestroy(), Rt(n = this), delete n.params, delete ue.keydownHandler, delete ue.keydownTarget, delete ue.currentInstance) : Rt(this) } }); let Ft; class Lt { constructor() { if ("undefined" == typeof window) return; Ft = this; for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; const r = Object.freeze(this.constructor.argsToParams(t)); Object.defineProperties(this, { params: { value: r, writable: !1, enumerable: !0, configurable: !0 } }); const s = this._main(this.params); ve.promise.set(this, s) } _main(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; (e => { !e.backdrop && e.allowOutsideClick && r('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`'); for (const t in e) y(t), e.toast && v(t), w(t) })(Object.assign({}, t, e)), ue.currentInstance && (ue.currentInstance._destroy(), j() && Re()), ue.currentInstance = this; const n = $t(e, t); Le(n), Object.freeze(n), ue.timeout && (ue.timeout.stop(), delete ue.timeout), clearTimeout(ue.restoreFocusTimeout); const s = Bt(this); return De(this, n), ve.innerParams.set(this, n), Mt(this, s, n) } then(e) { return ve.promise.get(this).then(e) } finally(e) { return ve.promise.get(this).finally(e) } } const Mt = (e, t, r) => new Promise((i, u) => { const h = t => { e.closePopup({ isDismissed: !0, dismiss: t }) }; _t.swalPromiseResolve.set(e, i), _t.swalPromiseReject.set(e, u), t.confirmButton.onclick = () => (e => { const t = ve.innerParams.get(e); e.disableButtons(), t.input ? Xe(e, "confirm") : tt(e, !0) })(e), t.denyButton.onclick = () => (e => { const t = ve.innerParams.get(e); e.disableButtons(), t.returnInputValueOnDeny ? Xe(e, "deny") : Qe(e, !1) })(e), t.cancelButton.onclick = () => ((e, t) => { e.disableButtons(), t(Oe.cancel) })(e, h), t.closeButton.onclick = () => h(Oe.close), ((e, t, n) => { ve.innerParams.get(e).toast ? ((e, t, n) => { t.popup.onclick = () => { const t = ve.innerParams.get(e); t && (nt(t) || t.timer || t.input) || n(Oe.close) } })(e, t, n) : ((e => { e.popup.onmousedown = () => { e.container.onmouseup = function (t) { e.container.onmouseup = void 0, t.target === e.container && (rt = !0) } } })(t), (e => { e.container.onmousedown = () => { e.popup.onmouseup = function (t) { e.popup.onmouseup = void 0, (t.target === e.popup || e.popup.contains(t.target)) && (rt = !0) } } })(t), ((e, t, n) => { t.container.onclick = r => { const s = ve.innerParams.get(e); rt ? rt = !1 : r.target === t.container && o(s.allowOutsideClick) && n(Oe.backdrop) } })(e, t, n)) })(e, t, h), ((e, t, n, r) => { t.keydownTarget && t.keydownHandlerAdded && (t.keydownTarget.removeEventListener("keydown", t.keydownHandler, { capture: t.keydownListenerCapture }), t.keydownHandlerAdded = !1), n.toast || (t.keydownHandler = t => ((e, t, n) => { const r = ve.innerParams.get(e); r && (r.stopKeydownPropagation && t.stopPropagation(), "Enter" === t.key ? ct(e, t, r) : "Tab" === t.key ? lt(t, r) : [...ot, ...at].includes(t.key) ? ut(t.key) : "Escape" === t.key && ht(t, r, n)) })(e, t, r), t.keydownTarget = n.keydownListenerCapture ? window : I(), t.keydownListenerCapture = n.keydownListenerCapture, t.keydownTarget.addEventListener("keydown", t.keydownHandler, { capture: t.keydownListenerCapture }), t.keydownHandlerAdded = !0) })(e, ue, r, h), ((e, t) => { "select" === t.input || "radio" === t.input ? ((e, t) => { const n = I(), r = e => We[t.input](n, Ye(e), t); a(t.inputOptions) || l(t.inputOptions) ? (He(N()), c(t.inputOptions).then(t => { e.hideLoading(), r(t) })) : "object" == typeof t.inputOptions ? r(t.inputOptions) : s("Unexpected type of inputOptions! Expected object, Map or Promise, got ".concat(typeof t.inputOptions)) })(e, t) : ["text", "email", "number", "tel", "textarea"].includes(t.input) && (a(t.inputValue) || l(t.inputValue)) && (He(N()), ((e, t) => { const n = e.getInput(); ne(n), c(t.inputValue).then(r => { n.value = "number" === t.input ? parseFloat(r) || 0 : "".concat(r), te(n), n.focus(), e.hideLoading() }).catch(t => { s("Error in inputValue promise: ".concat(t)), n.value = "", te(n), n.focus(), e.hideLoading() }) })(e, t)) })(e, r), (e => { const t = C(), r = I(); "function" == typeof e.willOpen && e.willOpen(r); const s = window.getComputedStyle(document.body).overflowY; ze(t, r, e), setTimeout(() => { je(t, r) }, 10), j() && (qe(t, e.scrollbarPadding, s), n(document.body.children).forEach(e => { e === C() || e.contains(C()) || (e.hasAttribute("aria-hidden") && e.setAttribute("data-previous-aria-hidden", e.getAttribute("aria-hidden")), e.setAttribute("aria-hidden", "true")) })), q() || ue.previousActiveElement || (ue.previousActiveElement = document.activeElement), "function" == typeof e.didOpen && setTimeout(() => e.didOpen(r)), Q(t, _["no-transition"]) })(r), Vt(ue, r, h), Ut(t, r), setTimeout(() => { t.container.scrollTop = 0 }) }), $t = (e, s) => { const i = (e => { const s = "string" == typeof e.template ? document.querySelector(e.template) : e.template; if (!s) return {}; const i = s.content; return (e => { const t = Ne.concat(["swal-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]); n(e.children).forEach(e => { const n = e.tagName.toLowerCase(); -1 === t.indexOf(n) && r("Unrecognized element <".concat(n, ">")) }) })(i), Object.assign((e => { const t = {}; return n(e.querySelectorAll("swal-param")).forEach(e => { Pe(e, ["name", "value"]); const n = e.getAttribute("name"), r = e.getAttribute("value"); "boolean" == typeof u[n] && "false" === r && (t[n] = !1), "object" == typeof u[n] && (t[n] = JSON.parse(r)) }), t })(i), (e => { const r = {}; return n(e.querySelectorAll("swal-button")).forEach(e => { Pe(e, ["type", "color", "aria-label"]); const n = e.getAttribute("type"); r["".concat(n, "ButtonText")] = e.innerHTML, r["show".concat(t(n), "Button")] = !0, e.hasAttribute("color") && (r["".concat(n, "ButtonColor")] = e.getAttribute("color")), e.hasAttribute("aria-label") && (r["".concat(n, "ButtonAriaLabel")] = e.getAttribute("aria-label")) }), r })(i), (e => { const t = {}, n = e.querySelector("swal-image"); return n && (Pe(n, ["src", "width", "height", "alt"]), n.hasAttribute("src") && (t.imageUrl = n.getAttribute("src")), n.hasAttribute("width") && (t.imageWidth = n.getAttribute("width")), n.hasAttribute("height") && (t.imageHeight = n.getAttribute("height")), n.hasAttribute("alt") && (t.imageAlt = n.getAttribute("alt"))), t })(i), (e => { const t = {}, n = e.querySelector("swal-icon"); return n && (Pe(n, ["type", "color"]), n.hasAttribute("type") && (t.icon = n.getAttribute("type")), n.hasAttribute("color") && (t.iconColor = n.getAttribute("color")), t.iconHtml = n.innerHTML), t })(i), (e => { const t = {}, r = e.querySelector("swal-input"); r && (Pe(r, ["type", "label", "placeholder", "value"]), t.input = r.getAttribute("type") || "text", r.hasAttribute("label") && (t.inputLabel = r.getAttribute("label")), r.hasAttribute("placeholder") && (t.inputPlaceholder = r.getAttribute("placeholder")), r.hasAttribute("value") && (t.inputValue = r.getAttribute("value"))); const s = e.querySelectorAll("swal-input-option"); return s.length && (t.inputOptions = {}, n(s).forEach(e => { Pe(e, ["value"]); const n = e.getAttribute("value"); t.inputOptions[n] = e.innerHTML })), t })(i), ((e, t) => { const n = {}; for (const r in t) { const s = t[r], i = e.querySelector(s); i && (Pe(i, []), n[s.replace(/^swal-/, "")] = i.innerHTML.trim()) } return n })(i, Ne)) })(e), o = Object.assign({}, u, s, i, e); return o.showClass = Object.assign({}, u.showClass, o.showClass), o.hideClass = Object.assign({}, u.hideClass, o.hideClass), o }, Bt = e => { const t = { popup: I(), container: C(), actions: M(), confirmButton: N(), denyButton: P(), cancelButton: L(), loader: F(), closeButton: V(), validationMessage: R(), progressSteps: O() }; return ve.domCache.set(e, t), t }, Vt = (e, t, n) => { const r = B(); ne(r), t.timer && (e.timeout = new Me(() => { n("timer"), delete e.timeout }, t.timer), t.timerProgressBar && (te(r), setTimeout(() => { e.timeout && e.timeout.running && ce(t.timer) }))) }, Ut = (e, t) => { if (!t.toast) return o(t.allowEnterKey) ? void (jt(e, t) || it(0, -1, 1)) : qt() }, jt = (e, t) => t.focusDeny && ie(e.denyButton) ? (e.denyButton.focus(), !0) : t.focusCancel && ie(e.cancelButton) ? (e.cancelButton.focus(), !0) : !(!t.focusConfirm || !ie(e.confirmButton) || (e.confirmButton.focus(), 0)), qt = () => { document.activeElement instanceof HTMLElement && "function" == typeof document.activeElement.blur && document.activeElement.blur() }; Object.assign(Lt.prototype, Pt), Object.assign(Lt, vt), Object.keys(Pt).forEach(e => { Lt[e] = function () { if (Ft) return Ft[e](...arguments) } }), Lt.DismissReason = Oe, Lt.version = "11.3.10"; const zt = Lt; return zt.default = zt, zt }(), void 0 !== this && this.Sweetalert2 && (this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2), "undefined" != typeof document && function (e, t) { var n = e.createElement("style"); if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t); else try { n.innerHTML = t } catch (e) { n.innerText = t } }(document, '.swal2-popup.swal2-toast{box-sizing:border-box;grid-column:1/4!important;grid-row:1/4!important;grid-template-columns:1fr 99fr 1fr;padding:1em;overflow-y:hidden;background:#fff;box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-popup.swal2-toast>*{grid-column:2}.swal2-popup.swal2-toast .swal2-title{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-loading{justify-content:center}.swal2-popup.swal2-toast .swal2-input{height:2em;margin:.5em;font-size:1em}.swal2-popup.swal2-toast .swal2-validation-message{font-size:1em}.swal2-popup.swal2-toast .swal2-footer{margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-popup.swal2-toast .swal2-close{grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-popup.swal2-toast .swal2-html-container{margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-popup.swal2-toast .swal2-html-container:empty{padding:0}.swal2-popup.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-popup.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-popup.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:700}.swal2-popup.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-popup.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-popup.swal2-toast .swal2-actions{justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-popup.swal2-toast .swal2-styled{margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-popup.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;transform:rotate(45deg);border-radius:50%}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.8em;left:-.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-popup.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-popup.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-popup.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-toast-animate-success-line-tip .75s;animation:swal2-toast-animate-success-line-tip .75s}.swal2-popup.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-toast-animate-success-line-long .75s;animation:swal2-toast-animate-success-line-long .75s}.swal2-popup.swal2-toast.swal2-show{-webkit-animation:swal2-toast-show .5s;animation:swal2-toast-show .5s}.swal2-popup.swal2-toast.swal2-hide{-webkit-animation:swal2-toast-hide .1s forwards;animation:swal2-toast-hide .1s forwards}.swal2-container{display:grid;position:fixed;z-index:1060;top:0;right:0;bottom:0;left:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto) minmax(-webkit-min-content,auto);grid-template-rows:minmax(min-content,auto) minmax(min-content,auto) minmax(min-content,auto);height:100%;padding:.625em;overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}.swal2-container.swal2-backdrop-show,.swal2-container.swal2-noanimation{background:rgba(0,0,0,.4)}.swal2-container.swal2-backdrop-hide{background:0 0!important}.swal2-container.swal2-bottom-start,.swal2-container.swal2-center-start,.swal2-container.swal2-top-start{grid-template-columns:minmax(0,1fr) auto auto}.swal2-container.swal2-bottom,.swal2-container.swal2-center,.swal2-container.swal2-top{grid-template-columns:auto minmax(0,1fr) auto}.swal2-container.swal2-bottom-end,.swal2-container.swal2-center-end,.swal2-container.swal2-top-end{grid-template-columns:auto auto minmax(0,1fr)}.swal2-container.swal2-top-start>.swal2-popup{align-self:start}.swal2-container.swal2-top>.swal2-popup{grid-column:2;align-self:start;justify-self:center}.swal2-container.swal2-top-end>.swal2-popup,.swal2-container.swal2-top-right>.swal2-popup{grid-column:3;align-self:start;justify-self:end}.swal2-container.swal2-center-left>.swal2-popup,.swal2-container.swal2-center-start>.swal2-popup{grid-row:2;align-self:center}.swal2-container.swal2-center>.swal2-popup{grid-column:2;grid-row:2;align-self:center;justify-self:center}.swal2-container.swal2-center-end>.swal2-popup,.swal2-container.swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;align-self:center;justify-self:end}.swal2-container.swal2-bottom-left>.swal2-popup,.swal2-container.swal2-bottom-start>.swal2-popup{grid-column:1;grid-row:3;align-self:end}.swal2-container.swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;justify-self:center;align-self:end}.swal2-container.swal2-bottom-end>.swal2-popup,.swal2-container.swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;align-self:end;justify-self:end}.swal2-container.swal2-grow-fullscreen>.swal2-popup,.swal2-container.swal2-grow-row>.swal2-popup{grid-column:1/4;width:100%}.swal2-container.swal2-grow-column>.swal2-popup,.swal2-container.swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}.swal2-container.swal2-no-transition{transition:none!important}.swal2-popup{display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0,100%);width:32em;max-width:100%;padding:0 0 1.25em;border:none;border-radius:5px;background:#fff;color:#545454;font-family:inherit;font-size:1rem}.swal2-popup:focus{outline:0}.swal2-popup.swal2-loading{overflow-y:hidden}.swal2-title{position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word}.swal2-actions{display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}.swal2-actions:not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}.swal2-actions:not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0,0,0,.1),rgba(0,0,0,.1))}.swal2-actions:not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0,0,0,.2),rgba(0,0,0,.2))}.swal2-loader{display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;-webkit-animation:swal2-rotate-loading 1.5s linear 0s infinite normal;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 transparent #2778c4 transparent}.swal2-styled{margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px transparent;font-weight:500}.swal2-styled:not([disabled]){cursor:pointer}.swal2-styled.swal2-confirm{border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}.swal2-styled.swal2-confirm:focus{box-shadow:0 0 0 3px rgba(112,102,224,.5)}.swal2-styled.swal2-deny{border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}.swal2-styled.swal2-deny:focus{box-shadow:0 0 0 3px rgba(220,55,65,.5)}.swal2-styled.swal2-cancel{border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}.swal2-styled.swal2-cancel:focus{box-shadow:0 0 0 3px rgba(110,120,129,.5)}.swal2-styled.swal2-default-outline:focus{box-shadow:0 0 0 3px rgba(100,150,200,.5)}.swal2-styled:focus{outline:0}.swal2-styled::-moz-focus-inner{border:0}.swal2-footer{justify-content:center;margin:1em 0 0;padding:1em 1em 0;border-top:1px solid #eee;color:inherit;font-size:1em}.swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto!important;height:.25em;overflow:hidden;border-bottom-right-radius:5px;border-bottom-left-radius:5px}.swal2-timer-progress-bar{width:100%;height:.25em;background:rgba(0,0,0,.2)}.swal2-image{max-width:100%;margin:2em auto 1em}.swal2-close{z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:5px;background:0 0;color:#ccc;font-family:serif;font-family:monospace;font-size:2.5em;cursor:pointer;justify-self:end}.swal2-close:hover{transform:none;background:0 0;color:#f27474}.swal2-close:focus{outline:0;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}.swal2-close::-moz-focus-inner{border:0}.swal2-html-container{z-index:1;justify-content:center;margin:1em 1.6em .3em;padding:0;overflow:auto;color:inherit;font-size:1.125em;font-weight:400;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word}.swal2-checkbox,.swal2-file,.swal2-input,.swal2-radio,.swal2-select,.swal2-textarea{margin:1em 2em 3px}.swal2-file,.swal2-input,.swal2-textarea{box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:inherit;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px transparent;color:inherit;font-size:1.125em}.swal2-file.swal2-inputerror,.swal2-input.swal2-inputerror,.swal2-textarea.swal2-inputerror{border-color:#f27474!important;box-shadow:0 0 2px #f27474!important}.swal2-file:focus,.swal2-input:focus,.swal2-textarea:focus{border:1px solid #b4dbed;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}.swal2-file::-moz-placeholder,.swal2-input::-moz-placeholder,.swal2-textarea::-moz-placeholder{color:#ccc}.swal2-file:-ms-input-placeholder,.swal2-input:-ms-input-placeholder,.swal2-textarea:-ms-input-placeholder{color:#ccc}.swal2-file::placeholder,.swal2-input::placeholder,.swal2-textarea::placeholder{color:#ccc}.swal2-range{margin:1em 2em 3px;background:#fff}.swal2-range input{width:80%}.swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}.swal2-range input,.swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}.swal2-input{height:2.625em;padding:0 .75em}.swal2-file{width:75%;margin-right:auto;margin-left:auto;background:inherit;font-size:1.125em}.swal2-textarea{height:6.75em;padding:.75em}.swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:inherit;color:inherit;font-size:1.125em}.swal2-checkbox,.swal2-radio{align-items:center;justify-content:center;background:#fff;color:inherit}.swal2-checkbox label,.swal2-radio label{margin:0 .6em;font-size:1.125em}.swal2-checkbox input,.swal2-radio input{flex-shrink:0;margin:0 .4em}.swal2-input-label{display:flex;justify-content:center;margin:1em auto 0}.swal2-validation-message{align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:#f0f0f0;color:#666;font-size:1em;font-weight:300}.swal2-validation-message::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}.swal2-icon{position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid transparent;border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}.swal2-icon.swal2-error{border-color:#f27474;color:#f27474}.swal2-icon.swal2-error .swal2-x-mark{position:relative;flex-grow:1}.swal2-icon.swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}.swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}.swal2-icon.swal2-error.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-error.swal2-icon-show .swal2-x-mark{-webkit-animation:swal2-animate-error-x-mark .5s;animation:swal2-animate-error-x-mark .5s}.swal2-icon.swal2-warning{border-color:#facea8;color:#f8bb86}.swal2-icon.swal2-warning.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-warning.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .5s;animation:swal2-animate-i-mark .5s}.swal2-icon.swal2-info{border-color:#9de0f6;color:#3fc3ee}.swal2-icon.swal2-info.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-info.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-i-mark .8s;animation:swal2-animate-i-mark .8s}.swal2-icon.swal2-question{border-color:#c9dae1;color:#87adbd}.swal2-icon.swal2-question.swal2-icon-show{-webkit-animation:swal2-animate-error-icon .5s;animation:swal2-animate-error-icon .5s}.swal2-icon.swal2-question.swal2-icon-show .swal2-icon-content{-webkit-animation:swal2-animate-question-mark .8s;animation:swal2-animate-question-mark .8s}.swal2-icon.swal2-success{border-color:#a5dc86;color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;transform:rotate(45deg);border-radius:50%}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=left]{top:-.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}.swal2-icon.swal2-success [class^=swal2-success-circular-line][class$=right]{top:-.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}.swal2-icon.swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-.25em;left:-.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}.swal2-icon.swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}.swal2-icon.swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}.swal2-icon.swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}.swal2-icon.swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-tip{-webkit-animation:swal2-animate-success-line-tip .75s;animation:swal2-animate-success-line-tip .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-line-long{-webkit-animation:swal2-animate-success-line-long .75s;animation:swal2-animate-success-line-long .75s}.swal2-icon.swal2-success.swal2-icon-show .swal2-success-circular-line-right{-webkit-animation:swal2-rotate-success-circular-line 4.25s ease-in;animation:swal2-rotate-success-circular-line 4.25s ease-in}.swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:inherit;font-weight:600}.swal2-progress-steps li{display:inline-block;position:relative}.swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:#add8e6;color:#fff}.swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:#add8e6}.swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}[class^=swal2]{-webkit-tap-highlight-color:transparent}.swal2-show{-webkit-animation:swal2-show .3s;animation:swal2-show .3s}.swal2-hide{-webkit-animation:swal2-hide .15s forwards;animation:swal2-hide .15s forwards}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}@-webkit-keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@keyframes swal2-toast-show{0%{transform:translateY(-.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0)}}@-webkit-keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@-webkit-keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@-webkit-keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}@-webkit-keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@keyframes swal2-show{0%{transform:scale(.7)}45%{transform:scale(1.05)}80%{transform:scale(.95)}100%{transform:scale(1)}}@-webkit-keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(.5);opacity:0}}@-webkit-keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@-webkit-keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@-webkit-keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@-webkit-keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(.4);opacity:0}50%{margin-top:1.625em;transform:scale(.4);opacity:0}80%{margin-top:-.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@-webkit-keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0);opacity:1}}@-webkit-keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes swal2-rotate-loading{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@-webkit-keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@-webkit-keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto!important}body.swal2-no-backdrop .swal2-container{background-color:transparent!important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px rgba(0,0,0,.4)}@media print{body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown){overflow-y:scroll!important}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop):not(.swal2-toast-shown) .swal2-container{position:static!important}}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:transparent;pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{top:0;right:auto;bottom:auto;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{top:0;right:0;bottom:auto;left:auto}body.swal2-toast-shown .swal2-container.swal2-top-left,body.swal2-toast-shown .swal2-container.swal2-top-start{top:0;right:auto;bottom:auto;left:0}body.swal2-toast-shown .swal2-container.swal2-center-left,body.swal2-toast-shown .swal2-container.swal2-center-start{top:50%;right:auto;bottom:auto;left:0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{top:50%;right:auto;bottom:auto;left:50%;transform:translate(-50%,-50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{top:50%;right:0;bottom:auto;left:auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-left,body.swal2-toast-shown .swal2-container.swal2-bottom-start{top:auto;right:auto;bottom:0;left:0}body.swal2-toast-shown .swal2-container.swal2-bottom{top:auto;right:auto;bottom:0;left:50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{top:auto;right:0;bottom:0;left:auto}') }, 7556: (e, t, n) => { "use strict"; n.d(t, { e: () => o }); var r = n(4762), s = n(8720), i = n(8006); let o = (() => { class e { constructor(e) { this.afAuth = e } loginConCorreo(e, t) { return this.afAuth.signInWithEmailAndPassword(e, t) } recuperarPassword(e) { return (0, r.mG)(this, void 0, void 0, function* () { return yield this.afAuth.sendPasswordResetEmail(e) }) } logout() { return (0, r.mG)(this, void 0, void 0, function* () { return this.afAuth.signOut() }) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(i.zQ)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })() }, 338: (e, t, n) => { "use strict"; n.d(t, { O: () => a }); var r = n(4762), s = n(8259), i = n.n(s), o = n(8720); let a = (() => { class e { constructor() { } mensajeCarga(e, t) { i().fire({ title: e, text: t, icon: "info", showConfirmButton: !1, timerProgressBar: !0 }) } mensajeInfo(e, t) { i().fire({ title: e, text: t, icon: "info", timer: 4e3, confirmButtonColor: "#d33", allowOutsideClick: !1, confirmButtonText: "Aceptar" }) } mensajeError(e, t) { i().fire({ title: e, text: t, icon: "error", confirmButtonColor: "#d33", confirmButtonText: "Aceptar", timer: 4e3, allowOutsideClick: !1 }) } mensajeExito(e, t) { i().fire({ title: e, text: t, icon: "success", confirmButtonColor: "#1d365f", confirmButtonText: "Aceptar", allowOutsideClick: !1 }) } mostrarLoading() { i().showLoading() } cerrarMensaje() { i().close() } validarDecision(e, t) { return (0, r.mG)(this, void 0, void 0, function* () { return yield i().fire({ title: e, html: t, showCancelButton: !0, cancelButtonColor: "#d33", cancelButtonText: "Cancelar", confirmButtonColor: "#1d365f", confirmButtonText: "Confirmar" }) }) } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275prov = o.Yz7({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })() }, 1188: (e, t, n) => { "use strict"; n.d(t, { V: () => o }); var r = n(4762), s = n(8720), i = n(1628); let o = (() => { class e { constructor(e) { this.storageService = e, this.storage = null, this.initStorage() } initStorage() { return (0, r.mG)(this, void 0, void 0, function* () { const e = yield this.storageService.create(); this.storage = e }) } setVariableLocal(e, t) { var n; return null === (n = this.storage) || void 0 === n ? void 0 : n.set(e, t) } getVariableLocal(e) { var t; return null === (t = this.storage) || void 0 === t ? void 0 : t.get(e) } removerVariableLocal() { var e; return null === (e = this.storage) || void 0 === e ? void 0 : e.clear() } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(i.K)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })() }, 2340: (e, t, n) => { "use strict"; n.d(t, { N: () => r }); const r = { production: !0, firebaseConfig: { apiKey: "AIzaSyC5JrMN-Z3wgnUr5EXso0z-JypkvzeklQI", authDomain: "dbs-tracker.firebaseapp.com", projectId: "dbs-tracker", storageBucket: "dbs-tracker.appspot.com", messagingSenderId: "337205848820", appId: "1:337205848820:web:ab3622c460177423894ca1", measurementId: "G-MH51PS25G4" }, ipApiBackend: "https://apitracker.dbs.cl:3005/api/v1" } }, 5627: (e, t, n) => { "use strict"; var r = n(9075), s = n(8720), i = n(4026), o = n(1841), a = n(2859), c = n(4022), l = n(8002), u = n(5257), h = n(8006); n(7841); const d = (0, l.U)(e => !!e), f = [{ path: "", canActivate: [(() => { class e { constructor(e, t) { this.router = e, this.auth = t, this.canActivate = (e, t) => { const n = e.data.authGuardPipe || (() => d); return this.auth.user.pipe((0, u.q)(1), n(e, t), (0, l.U)(e => "boolean" == typeof e ? e : Array.isArray(e) ? this.router.createUrlTree(e) : this.router.parseUrl(e))) } } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(i.F0), s.LFG(h.zQ)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac, providedIn: "any" }), e })()], data: { authGuardPipe: () => { return e = ["login"], (0, c.z)(d, (0, l.U)(t => t || e)); var e } }, loadChildren: () => Promise.all([n.e(8592), n.e(6243)]).then(n.bind(n, 6243)).then(e => e.TabsPageModule) }, { path: "perfil", loadChildren: () => Promise.all([n.e(8592), n.e(6195)]).then(n.bind(n, 6195)).then(e => e.PerfilPageModule) }, { path: "mensajes", loadChildren: () => n.e(5982).then(n.bind(n, 5982)).then(e => e.MensajesPageModule) }, { path: "billetera", loadChildren: () => n.e(7202).then(n.bind(n, 7202)).then(e => e.BilleteraPageModule) }, { path: "config", loadChildren: () => n.e(2700).then(n.bind(n, 2700)).then(e => e.ConfigPageModule) }, { path: "login", loadChildren: () => Promise.all([n.e(8592), n.e(6591)]).then(n.bind(n, 6591)).then(e => e.LoginPageModule) }, { path: "recuperar-password", loadChildren: () => n.e(823).then(n.bind(n, 823)).then(e => e.RecuperarPasswordPageModule) }]; let p = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({ imports: [[i.Bz.forRoot(f, { preloadingStrategy: i.wm })], i.Bz] }), e })(); var m = n(4762), g = n(7556), y = n(338), v = n(1188); let w = (() => { class e { constructor(e, t, n, r, s) { this.auth = e, this.mjs = t, this.router = n, this.menu = r, this.storageService = s } logout() { return (0, m.mG)(this, void 0, void 0, function* () { yield this.auth.logout().then(() => { this.storageService.removerVariableLocal().then(() => { this.mjs.mensajeExito("Te has desconectado", "Nos vemos pronto."), this.menu.close(), this.router.navigate(["/login"]) }) }).catch(() => { this.mjs.mensajeError("Ocurrio un error", "No hemos podido cerrar tu sesi\xf3n.") }) }) } } return e.\u0275fac = function (t) { return new (t || e)(s.Y36(g.e), s.Y36(y.O), s.Y36(i.F0), s.Y36(a._q), s.Y36(v.V)) }, e.\u0275cmp = s.Xpm({ type: e, selectors: [["app-root"]], decls: 40, vars: 0, consts: [["side", "start", "menuId", "menuId", "contentId", "main"], [1, "ion-text-center", "ion-padding-top"], ["disabled", "", "routerLink", "perfil", "color", "dark", 1, "ion-padding-bottom"], ["size", "12"], [1, "fas", "fa-user-circle"], ["disabled", "", "routerLink", "mensajes", "color", "dark", 1, "ion-padding-bottom"], [1, "fas", "fa-envelope"], ["disabled", "", "routerLink", "billetera", "color", "dark", 1, "ion-padding-bottom"], [1, "fas", "fa-wallet"], ["disabled", "", "routerLink", "config", "color", "dark", 1, "ion-padding-bottom"], [1, "fas", "fa-cog"], ["color", "dark", 1, "ion-padding-bottom", 3, "click"], [1, "fas", "fa-sign-out-alt"], ["id", "main"]], template: function (e, t) { 1 & e && (s.TgZ(0, "ion-app"), s.TgZ(1, "ion-menu", 0), s.TgZ(2, "ion-content", 1), s.TgZ(3, "ion-buttons"), s.TgZ(4, "ion-button", 2), s.TgZ(5, "ion-row"), s.TgZ(6, "ion-col", 3), s._UZ(7, "i", 4), s.qZA(), s.TgZ(8, "ion-col", 3), s.TgZ(9, "ion-label"), s._uU(10, "Perfil"), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.TgZ(11, "ion-button", 5), s.TgZ(12, "ion-row"), s.TgZ(13, "ion-col", 3), s._UZ(14, "i", 6), s.qZA(), s.TgZ(15, "ion-col", 3), s.TgZ(16, "ion-label"), s._uU(17, "Msjs"), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.TgZ(18, "ion-button", 7), s.TgZ(19, "ion-row"), s.TgZ(20, "ion-col", 3), s._UZ(21, "i", 8), s.qZA(), s.TgZ(22, "ion-col", 3), s.TgZ(23, "ion-label"), s._uU(24, "Billetera"), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.TgZ(25, "ion-button", 9), s.TgZ(26, "ion-row"), s.TgZ(27, "ion-col", 3), s._UZ(28, "i", 10), s.qZA(), s.TgZ(29, "ion-col", 3), s.TgZ(30, "ion-label"), s._uU(31, "Config"), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.TgZ(32, "ion-button", 11), s.NdJ("click", function () { return t.logout() }), s.TgZ(33, "ion-row"), s.TgZ(34, "ion-col", 3), s._UZ(35, "i", 12), s.qZA(), s.TgZ(36, "ion-col", 3), s.TgZ(37, "ion-label"), s._uU(38, "Salir"), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s.qZA(), s._UZ(39, "ion-router-outlet", 13), s.qZA()) }, directives: [a.dr, a.z0, a.W2, a.Sm, a.YG, a.YI, i.rH, a.Nd, a.wI, a.Q$, a.jP], styles: ["ion-menu[_ngcontent-%COMP%]{--width:22%}ion-menu[_ngcontent-%COMP%]   ion-buttons[_ngcontent-%COMP%]{display:contents}ion-menu[_ngcontent-%COMP%]   ion-buttons[_ngcontent-%COMP%]   ion-button[_ngcontent-%COMP%]{height:-moz-fit-content;height:fit-content;text-transform:capitalize}ion-menu[_ngcontent-%COMP%]   ion-buttons[_ngcontent-%COMP%]   ion-button[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-size:3em}ion-menu[_ngcontent-%COMP%]   ion-buttons[_ngcontent-%COMP%]   ion-button[_ngcontent-%COMP%]   ion-label[_ngcontent-%COMP%]{font-size:1em}ion-item[_ngcontent-%COMP%]   i[_ngcontent-%COMP%]{font-size:1.5em}ion-item[_ngcontent-%COMP%]   ion-label[_ngcontent-%COMP%]{font-size:1em;font-family:Roboto;font-weight:700;margin-left:1em}"] }), e })(); var b = n(8939), _ = n(2278), E = n(8534), C = n(2340), S = n(9765), T = (n(6782), n(8583)); const I = new s.OlP("@sweetalert2/ngx-sweetalert2#swalProvider"), k = new s.OlP("@sweetalert2/ngx-sweetalert2#fireOnInit"), A = new s.OlP("@sweetalert2/ngx-sweetalert2#dismissOnDestroy"); let x = (() => { class e { constructor(e) { this.swalProvider = e } get swal() { return this.swalPromiseCache || this.preloadSweetAlertLibrary(), this.swalPromiseCache } preloadSweetAlertLibrary() { if (this.swalPromiseCache) return; const e = "function" == typeof (t = this.swalProvider) && void 0 === t.version ? this.swalProvider() : Promise.resolve(this.swalProvider); var t; this.swalPromiseCache = e.then(e => function (e) { return "function" == typeof e }(e) ? e : e.default) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(I)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); function D() { return Promise.resolve().then(n.t.bind(n, 8259, 23)) } let O = (() => { class e { static forRoot(t = {}) { return { ngModule: e, providers: [x, { provide: I, useValue: t.provideSwal || D }, { provide: k, useValue: t.fireOnInit || !1 }, { provide: A, useValue: t.dismissOnDestroy || !0 }] } } static forChild(t = {}) { return { ngModule: e, providers: [...t.provideSwal ? [x, { provide: I, useValue: t.provideSwal }] : [], ...void 0 !== t.fireOnInit ? [{ provide: k, useValue: t.fireOnInit }] : [], ...void 0 !== t.dismissOnDestroy ? [{ provide: A, useValue: t.dismissOnDestroy }] : []] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({ imports: [[T.ez]] }), e })(); function R(e, t, n, r) { return new (n || (n = Promise))(function (s, i) { function o(e) { try { c(r.next(e)) } catch (t) { i(t) } } function a(e) { try { c(r.throw(e)) } catch (t) { i(t) } } function c(e) { var t; e.done ? s(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) { e(t) })).then(o, a) } c((r = r.apply(e, t || [])).next()) }) } var N, P = n(1628); const F = new s.OlP("STORAGE_CONFIG_TOKEN"); class L extends P.K { constructor() { super() } create() { return R(this, void 0, void 0, function* () { return this }) } defineDriver() { return R(this, void 0, void 0, function* () { }) } get driver() { return "noop" } get(e) { return R(this, void 0, void 0, function* () { return null }) } set(e, t) { return R(this, void 0, void 0, function* () { }) } remove(e) { return R(this, void 0, void 0, function* () { }) } clear() { return R(this, void 0, void 0, function* () { }) } length() { return R(this, void 0, void 0, function* () { return 0 }) } keys() { return R(this, void 0, void 0, function* () { return [] }) } forEach(e) { return R(this, void 0, void 0, function* () { }) } setEncryptionKey(e) { } } function M(e) { return (0, T.PM)(this.platformId) ? new L : new P.K(e) } let $ = N = class { static forRoot(e = null) { return { ngModule: N, providers: [{ provide: F, useValue: e }, { provide: P.K, useFactory: M, deps: [F] }] } } }; $.\u0275fac = function (e) { return new (e || $) }, $.\u0275mod = s.oAB({ type: $ }), $.\u0275inj = s.cJS({}); var B = n(1439), V = n(205), U = n(2759), j = n(5917), q = n(8071), z = n(8891), H = n(8640); const G = new z.y(H.Z); var W = n(6682), Y = n(5435), K = n(3190), X = n(4458), Z = n(8307), Q = n(3637), J = n(7393), ee = n(3098); class te { constructor(e, t) { this.delay = e, this.scheduler = t } call(e, t) { return t.subscribe(new ne(e, this.delay, this.scheduler)) } } class ne extends J.L { constructor(e, t, n) { super(e), this.delay = t, this.scheduler = n, this.queue = [], this.active = !1, this.errored = !1 } static dispatch(e) { const t = e.source, n = t.queue, r = e.scheduler, s = e.destination; for (; n.length > 0 && n[0].time - r.now() <= 0;)n.shift().notification.observe(s); if (n.length > 0) { const t = Math.max(0, n[0].time - r.now()); this.schedule(e, t) } else this.unsubscribe(), t.active = !1 } _schedule(e) { this.active = !0, this.destination.add(e.schedule(ne.dispatch, this.delay, { source: this, destination: this.destination, scheduler: e })) } scheduleNotification(e) { if (!0 === this.errored) return; const t = this.scheduler, n = new re(t.now() + this.delay, e); this.queue.push(n), !1 === this.active && this._schedule(t) } _next(e) { this.scheduleNotification(ee.P.createNext(e)) } _error(e) { this.errored = !0, this.queue = [], this.destination.error(e), this.unsubscribe() } _complete() { this.scheduleNotification(ee.P.createComplete()), this.unsubscribe() } } class re { constructor(e, t) { this.time = e, this.notification = t } } const se = "Service workers are disabled or not supported by this browser"; class ie { constructor(e) { if (this.serviceWorker = e, e) { const t = (0, U.R)(e, "controllerchange").pipe((0, l.U)(() => e.controller)), n = (0, B.P)(() => (0, j.of)(e.controller)), r = (0, q.z)(n, t); this.worker = r.pipe((0, Y.h)(e => !!e)), this.registration = this.worker.pipe((0, K.w)(() => e.getRegistration())); const s = (0, U.R)(e, "message").pipe((0, l.U)(e => e.data)).pipe((0, Y.h)(e => e && e.type)).pipe((0, X.O)(new S.xQ)); s.connect(), this.events = s } else this.worker = this.events = this.registration = (0, B.P)(() => (0, V._)(new Error("Service workers are disabled or not supported by this browser"))) } postMessage(e, t) { return this.worker.pipe((0, u.q)(1), (0, Z.b)(n => { n.postMessage(Object.assign({ action: e }, t)) })).toPromise().then(() => { }) } postMessageWithStatus(e, t, n) { const r = this.waitForStatus(n), s = this.postMessage(e, t); return Promise.all([r, s]).then(() => { }) } generateNonce() { return Math.round(1e7 * Math.random()) } eventsOfType(e) { return this.events.pipe((0, Y.h)(t => t.type === e)) } nextEventOfType(e) { return this.eventsOfType(e).pipe((0, u.q)(1)) } waitForStatus(e) { return this.eventsOfType("STATUS").pipe((0, Y.h)(t => t.nonce === e), (0, u.q)(1), (0, l.U)(e => { if (!e.status) throw new Error(e.error) })).toPromise() } get isEnabled() { return !!this.serviceWorker } } let oe = (() => { class e { constructor(e) { if (this.sw = e, this.subscriptionChanges = new S.xQ, !e.isEnabled) return this.messages = G, this.notificationClicks = G, void (this.subscription = G); this.messages = this.sw.eventsOfType("PUSH").pipe((0, l.U)(e => e.data)), this.notificationClicks = this.sw.eventsOfType("NOTIFICATION_CLICK").pipe((0, l.U)(e => e.data)), this.pushManager = this.sw.registration.pipe((0, l.U)(e => e.pushManager)); const t = this.pushManager.pipe((0, K.w)(e => e.getSubscription())); this.subscription = (0, W.T)(t, this.subscriptionChanges) } get isEnabled() { return this.sw.isEnabled } requestSubscription(e) { if (!this.sw.isEnabled) return Promise.reject(new Error(se)); const t = { userVisibleOnly: !0 }; let n = this.decodeBase64(e.serverPublicKey.replace(/_/g, "/").replace(/-/g, "+")), r = new Uint8Array(new ArrayBuffer(n.length)); for (let s = 0; s < n.length; s++)r[s] = n.charCodeAt(s); return t.applicationServerKey = r, this.pushManager.pipe((0, K.w)(e => e.subscribe(t)), (0, u.q)(1)).toPromise().then(e => (this.subscriptionChanges.next(e), e)) } unsubscribe() { return this.sw.isEnabled ? this.subscription.pipe((0, u.q)(1), (0, K.w)(e => { if (null === e) throw new Error("Not subscribed to push notifications."); return e.unsubscribe().then(e => { if (!e) throw new Error("Unsubscribe failed!"); this.subscriptionChanges.next(null) }) })).toPromise() : Promise.reject(new Error(se)) } decodeBase64(e) { return atob(e) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(ie)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(), ae = (() => { class e { constructor(e) { if (this.sw = e, !e.isEnabled) return this.available = G, this.activated = G, void (this.unrecoverable = G); this.available = this.sw.eventsOfType("UPDATE_AVAILABLE"), this.activated = this.sw.eventsOfType("UPDATE_ACTIVATED"), this.unrecoverable = this.sw.eventsOfType("UNRECOVERABLE_STATE") } get isEnabled() { return this.sw.isEnabled } checkForUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(se)); const e = this.sw.generateNonce(); return this.sw.postMessageWithStatus("CHECK_FOR_UPDATES", { statusNonce: e }, e) } activateUpdate() { if (!this.sw.isEnabled) return Promise.reject(new Error(se)); const e = this.sw.generateNonce(); return this.sw.postMessageWithStatus("ACTIVATE_UPDATE", { statusNonce: e }, e) } } return e.\u0275fac = function (t) { return new (t || e)(s.LFG(ie)) }, e.\u0275prov = s.Yz7({ token: e, factory: e.\u0275fac }), e })(); class ce { } const le = new s.OlP("NGSW_REGISTER_SCRIPT"); function ue(e, t, n, r) { return () => { if (!(0, T.NF)(r) || !("serviceWorker" in navigator) || !1 === n.enabled) return; let i; if (navigator.serviceWorker.addEventListener("controllerchange", () => { null !== navigator.serviceWorker.controller && navigator.serviceWorker.controller.postMessage({ action: "INITIALIZE" }) }), "function" == typeof n.registrationStrategy) i = n.registrationStrategy(); else { const [t, ...r] = (n.registrationStrategy || "registerWhenStable:30000").split(":"); switch (t) { case "registerImmediately": i = (0, j.of)(null); break; case "registerWithDelay": i = he(+r[0] || 0); break; case "registerWhenStable": i = r[0] ? (0, W.T)(de(e), he(+r[0])) : de(e); break; default: throw new Error(`Unknown ServiceWorker registration strategy: ${n.registrationStrategy}`) } } e.get(s.R0b).runOutsideAngular(() => i.pipe((0, u.q)(1)).subscribe(() => navigator.serviceWorker.register(t, { scope: n.scope }).catch(e => console.error("Service worker registration failed with:", e)))) } } function he(e) { return (0, j.of)(null).pipe(function (e, t = Q.P) { var n; const r = (n = e) instanceof Date && !isNaN(+n) ? +e - t.now() : Math.abs(e); return e => e.lift(new te(r, t)) }(e)) } function de(e) { return e.get(s.z2F).isStable.pipe((0, Y.h)(e => e)) } function fe(e, t) { return new ie((0, T.NF)(t) && !1 !== e.enabled ? navigator.serviceWorker : void 0) } let pe = (() => { class e { static register(t, n = {}) { return { ngModule: e, providers: [{ provide: le, useValue: t }, { provide: ce, useValue: n }, { provide: ie, useFactory: fe, deps: [ce, s.Lbi] }, { provide: s.ip1, useFactory: ue, deps: [s.zs3, le, ce, s.Lbi], multi: !0 }] } } } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = s.oAB({ type: e }), e.\u0275inj = s.cJS({ providers: [oe, ae] }), e })(), me = (() => { class e { } return e.\u0275fac = function (t) { return new (t || e) }, e.\u0275mod = s.oAB({ type: e, bootstrap: [w] }), e.\u0275inj = s.cJS({ providers: [{ provide: i.wN, useClass: a.r4 }], imports: [[r.b2, a.Pc.forRoot(), p, b.hO.initializeApp(C.N.firebaseConfig), h.ww, _.yb, E.TE, O.forRoot(), o.JF, $.forRoot(), pe.register("ngsw-worker.js", { enabled: C.N.production, registrationStrategy: "registerWhenStable:30000" })]] }), e })(); C.N.production && (0, s.G48)(), r.q6().bootstrapModule(me).catch(e => console.log(e)) }, 863: (e, t, n) => { var r = { "./ion-action-sheet.entry.js": [7321, 8592, 7321], "./ion-alert.entry.js": [6108, 8592, 6108], "./ion-app_8.entry.js": [1489, 8592, 1489], "./ion-avatar_3.entry.js": [305, 8592, 305], "./ion-back-button.entry.js": [5830, 8592, 5830], "./ion-backdrop.entry.js": [7757, 7757], "./ion-button_2.entry.js": [392, 8592, 392], "./ion-card_5.entry.js": [6911, 8592, 6911], "./ion-checkbox.entry.js": [937, 8592, 937], "./ion-chip.entry.js": [8695, 8592, 8695], "./ion-col_3.entry.js": [6034, 6034], "./ion-datetime_3.entry.js": [8837, 8592, 8837], "./ion-fab_3.entry.js": [4195, 8592, 4195], "./ion-img.entry.js": [1709, 1709], "./ion-infinite-scroll_2.entry.js": [5931, 8592, 3087], "./ion-input.entry.js": [4513, 8592, 4513], "./ion-item-option_3.entry.js": [8056, 8592, 8056], "./ion-item_8.entry.js": [862, 8592, 862], "./ion-loading.entry.js": [7509, 8592, 7509], "./ion-menu_3.entry.js": [6272, 8592, 6272], "./ion-modal.entry.js": [1855, 8592, 1855], "./ion-nav_2.entry.js": [8708, 8592, 8708], "./ion-popover.entry.js": [3527, 8592, 3527], "./ion-progress-bar.entry.js": [4694, 8592, 4694], "./ion-radio_2.entry.js": [9222, 8592, 9222], "./ion-range.entry.js": [5277, 8592, 5277], "./ion-refresher_2.entry.js": [9921, 8592, 9921], "./ion-reorder_2.entry.js": [3122, 8592, 3122], "./ion-ripple-effect.entry.js": [1602, 1602], "./ion-route_4.entry.js": [5174, 8592, 5174], "./ion-searchbar.entry.js": [7895, 8592, 7895], "./ion-segment_2.entry.js": [6164, 8592, 6164], "./ion-select_3.entry.js": [592, 8592, 592], "./ion-slide_2.entry.js": [7162, 7162], "./ion-spinner.entry.js": [1374, 8592, 1374], "./ion-split-pane.entry.js": [7896, 7896], "./ion-tab-bar_2.entry.js": [5043, 8592, 5043], "./ion-tab_2.entry.js": [7802, 8592, 7802], "./ion-text.entry.js": [9072, 8592, 9072], "./ion-textarea.entry.js": [2191, 8592, 2191], "./ion-toast.entry.js": [801, 8592, 801], "./ion-toggle.entry.js": [7110, 8592, 7110], "./ion-virtual-scroll.entry.js": [431, 431] }; function s(e) { if (!n.o(r, e)) return Promise.resolve().then(() => { var t = new Error("Cannot find module '" + e + "'"); throw t.code = "MODULE_NOT_FOUND", t }); var t = r[e], s = t[0]; return Promise.all(t.slice(1).map(n.e)).then(() => n(s)) } s.keys = () => Object.keys(r), s.id = 863, e.exports = s }, 4762: (e, t, n) => { "use strict"; function r(e, t) { var n = {}; for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]); if (null != e && "function" == typeof Object.getOwnPropertySymbols) { var s = 0; for (r = Object.getOwnPropertySymbols(e); s < r.length; s++)t.indexOf(r[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[s]) && (n[r[s]] = e[r[s]]) } return n } function s(e, t, n, r) { return new (n || (n = Promise))(function (s, i) { function o(e) { try { c(r.next(e)) } catch (t) { i(t) } } function a(e) { try { c(r.throw(e)) } catch (t) { i(t) } } function c(e) { var t; e.done ? s(e.value) : (t = e.value, t instanceof n ? t : new n(function (e) { e(t) })).then(o, a) } c((r = r.apply(e, t || [])).next()) }) } n.d(t, { _T: () => r, mG: () => s }) } }, e => { "use strict"; e(e.s = 5627) }]);